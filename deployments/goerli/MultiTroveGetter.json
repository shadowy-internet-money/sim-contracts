{
  "address": "0xF4fcD9079b7c96b8365e4CA80D696ee697dC2757",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract TroveManager",
          "name": "_troveManager",
          "type": "address"
        },
        {
          "internalType": "contract ISortedTroves",
          "name": "_sortedTroves",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "_startIdx",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "_count",
          "type": "uint256"
        }
      ],
      "name": "getMultipleSortedTroves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "coll",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stake",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "snapshotETH",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "snapshotLUSDDebt",
              "type": "uint256"
            }
          ],
          "internalType": "struct MultiTroveGetter.CombinedTroveData[]",
          "name": "_troves",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sortedTroves",
      "outputs": [
        {
          "internalType": "contract ISortedTroves",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "troveManager",
      "outputs": [
        {
          "internalType": "contract TroveManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x79cb06af425c8d3103a1a3398bb4c577c4e0882d9e3b67fbf0c5a7809462ac67",
  "receipt": {
    "to": null,
    "from": "0x88888887C3ebD4a33E34a15Db4254C74C75E5D4A",
    "contractAddress": "0xF4fcD9079b7c96b8365e4CA80D696ee697dC2757",
    "transactionIndex": 33,
    "gasUsed": "748904",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcc77b6671463470f8ad31a29c5afce2e3a204638987ab67e66c0bd621e3362c3",
    "transactionHash": "0x79cb06af425c8d3103a1a3398bb4c577c4e0882d9e3b67fbf0c5a7809462ac67",
    "logs": [],
    "blockNumber": 9555307,
    "cumulativeGasUsed": "5649989",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x67952505E536A83C4916a3F44728DE92e0E3EBBc",
    "0xbf2da16f66a21f0AFF8365b98C19eD73D7f11da4"
  ],
  "numDeployments": 1,
  "solcInputHash": "2d10d8ca88b5a3f61543e463b1cba125",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"contract ISortedTroves\",\"name\":\"_sortedTroves\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_startIdx\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getMultipleSortedTroves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotLUSDDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiTroveGetter.CombinedTroveData[]\",\"name\":\"_troves\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MultiTroveGetter.sol\":\"MultiTroveGetter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"contracts/MultiTroveGetter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./TroveManager.sol\\\";\\nimport \\\"./SortedTroves.sol\\\";\\n\\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/MultiTroveGetter.sol\\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core system. */\\ncontract MultiTroveGetter {\\n    struct CombinedTroveData {\\n        address owner;\\n\\n        uint debt;\\n        uint coll;\\n        uint stake;\\n\\n        uint snapshotETH;\\n        uint snapshotLUSDDebt;\\n    }\\n\\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\\n    ISortedTroves public sortedTroves;\\n\\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\\n        troveManager = _troveManager;\\n        sortedTroves = _sortedTroves;\\n    }\\n\\n    function getMultipleSortedTroves(int _startIdx, uint _count)\\n        external view returns (CombinedTroveData[] memory _troves)\\n    {\\n        uint startIdx;\\n        bool descend;\\n\\n        if (_startIdx >= 0) {\\n            startIdx = uint(_startIdx);\\n            descend = true;\\n        } else {\\n            startIdx = uint(-(_startIdx + 1));\\n            descend = false;\\n        }\\n\\n        uint sortedTrovesSize = sortedTroves.getSize();\\n\\n        if (startIdx >= sortedTrovesSize) {\\n            _troves = new CombinedTroveData[](0);\\n        } else {\\n            uint maxCount = sortedTrovesSize - startIdx;\\n\\n            if (_count > maxCount) {\\n                _count = maxCount;\\n            }\\n\\n            if (descend) {\\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\\n            } else {\\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\\n            }\\n        }\\n    }\\n\\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\\n        internal view returns (CombinedTroveData[] memory _troves)\\n    {\\n        address currentTroveowner = sortedTroves.getFirst();\\n\\n        for (uint idx = 0; idx < _startIdx; ++idx) {\\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\\n        }\\n\\n        _troves = new CombinedTroveData[](_count);\\n\\n        for (uint idx = 0; idx < _count; ++idx) {\\n            _troves[idx].owner = currentTroveowner;\\n            (\\n                _troves[idx].debt,\\n                _troves[idx].coll,\\n                _troves[idx].stake,\\n                /* status */,\\n                /* arrayIndex */\\n            ) = troveManager.Troves(currentTroveowner);\\n            (\\n                _troves[idx].snapshotETH,\\n                _troves[idx].snapshotLUSDDebt\\n            ) = troveManager.rewardSnapshots(currentTroveowner);\\n\\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\\n        }\\n    }\\n\\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\\n        internal view returns (CombinedTroveData[] memory _troves)\\n    {\\n        address currentTroveowner = sortedTroves.getLast();\\n\\n        for (uint idx = 0; idx < _startIdx; ++idx) {\\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\\n        }\\n\\n        _troves = new CombinedTroveData[](_count);\\n\\n        for (uint idx = 0; idx < _count; ++idx) {\\n            _troves[idx].owner = currentTroveowner;\\n            (\\n                _troves[idx].debt,\\n                _troves[idx].coll,\\n                _troves[idx].stake,\\n                /* status */,\\n                /* arrayIndex */\\n            ) = troveManager.Troves(currentTroveowner);\\n            (\\n                _troves[idx].snapshotETH,\\n                _troves[idx].snapshotLUSDDebt\\n            ) = troveManager.rewardSnapshots(currentTroveowner);\\n\\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf4b3cbdcb8161974aa4688b001a183b6ce6283dd67cc207d43f3ec7758610d10\",\"license\":\"MIT\"},\"contracts/SortedTroves.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\n\\n/*\\n* https://github.com/liquity/dev/blob/main/packages/contracts/contracts/SortedTroves.sol\\n* A sorted doubly linked list with nodes sorted in descending order.\\n*\\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\\n* which is like the ICR but without the price, i.e., just collateral / debt.\\n*\\n* The list optionally accepts insert position hints.\\n*\\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\\n* change dynamically as liquidation events occur.\\n*\\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\\n* Thus, Nodes remain sorted by current NICR.\\n*\\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\\n* to their position.\\n*\\n* The list is a modification of the following audited SortedDoublyLinkedList:\\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\\n*\\n*\\n* Changes made in the Liquity implementation:\\n*\\n* - Keys have been removed from nodes\\n*\\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\\n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\\n*\\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\\n*/\\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\\n    string constant public NAME = \\\"SortedTroves\\\";\\n\\n    address public borrowerOperationsAddress;\\n\\n    ITroveManager public troveManager;\\n\\n    // Information for a node in the list\\n    struct Node {\\n        bool exists;\\n        address nextId;                  // Id of next node (smaller NICR) in the list\\n        address prevId;                  // Id of previous node (larger NICR) in the list\\n    }\\n\\n    // Information for the list\\n    struct Data {\\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\\n        uint256 maxSize;                     // Maximum size of the list\\n        uint256 size;                        // Current size of the list\\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\\n    }\\n\\n    Data public data;\\n\\n    // --- Dependency setters ---\\n\\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\\n        require(_size > 0, \\\"SortedTroves: Size cant be zero\\\");\\n        _checkContract(_troveManagerAddress);\\n        _checkContract(_borrowerOperationsAddress);\\n\\n        data.maxSize = _size;\\n\\n        troveManager = ITroveManager(_troveManagerAddress);\\n        borrowerOperationsAddress = _borrowerOperationsAddress;\\n\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n\\n        renounceOwnership();\\n    }\\n\\n    /*\\n     * @dev Add a node to the list\\n     * @param _id Node's id\\n     * @param _NICR Node's NICR\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     */\\n\\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\\n        ITroveManager troveManagerCached = troveManager;\\n\\n        _requireCallerIsBOorTroveM(troveManagerCached);\\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\\n    }\\n\\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\\n        // List must not be full\\n        require(!isFull(), \\\"SortedTroves: List is full\\\");\\n        // List must not already contain node\\n        require(!contains(_id), \\\"SortedTroves: List already contains the node\\\");\\n        // Node id must not be null\\n        require(_id != address(0), \\\"SortedTroves: Id cannot be zero\\\");\\n        // NICR must be non-zero\\n        require(_NICR > 0, \\\"SortedTroves: NICR must be positive\\\");\\n\\n        address prevId = _prevId;\\n        address nextId = _nextId;\\n\\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\n            // Sender's hint was not a valid insert position\\n            // Use sender's hint to find a valid insert position\\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\\n        }\\n\\n         data.nodes[_id].exists = true;\\n\\n        if (prevId == address(0) && nextId == address(0)) {\\n            // Insert as head and tail\\n            data.head = _id;\\n            data.tail = _id;\\n        } else if (prevId == address(0)) {\\n            // Insert before `prevId` as the head\\n            data.nodes[_id].nextId = data.head;\\n            data.nodes[data.head].prevId = _id;\\n            data.head = _id;\\n        } else if (nextId == address(0)) {\\n            // Insert after `nextId` as the tail\\n            data.nodes[_id].prevId = data.tail;\\n            data.nodes[data.tail].nextId = _id;\\n            data.tail = _id;\\n        } else {\\n            // Insert at insert position between `prevId` and `nextId`\\n            data.nodes[_id].nextId = nextId;\\n            data.nodes[_id].prevId = prevId;\\n            data.nodes[prevId].nextId = _id;\\n            data.nodes[nextId].prevId = _id;\\n        }\\n\\n        data.size = data.size + 1;\\n        emit NodeAdded(_id, _NICR);\\n    }\\n\\n    function remove(address _id) external override {\\n        _requireCallerIsTroveManager();\\n        _remove(_id);\\n    }\\n\\n    /*\\n     * @dev Remove a node from the list\\n     * @param _id Node's id\\n     */\\n    function _remove(address _id) internal {\\n        // List must contain the node\\n        require(contains(_id), \\\"SortedTroves: List does not contain the id\\\");\\n\\n        if (data.size > 1) {\\n            // List contains more than a single node\\n            if (_id == data.head) {\\n                // The removed node is the head\\n                // Set head to next node\\n                data.head = data.nodes[_id].nextId;\\n                // Set prev pointer of new head to null\\n                data.nodes[data.head].prevId = address(0);\\n            } else if (_id == data.tail) {\\n                // The removed node is the tail\\n                // Set tail to previous node\\n                data.tail = data.nodes[_id].prevId;\\n                // Set next pointer of new tail to null\\n                data.nodes[data.tail].nextId = address(0);\\n            } else {\\n                // The removed node is neither the head nor the tail\\n                // Set next pointer of previous node to the next node\\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\\n                // Set prev pointer of next node to the previous node\\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\\n            }\\n        } else {\\n            // List contains a single node\\n            // Set the head and tail to null\\n            data.head = address(0);\\n            data.tail = address(0);\\n        }\\n\\n        delete data.nodes[_id];\\n        data.size = data.size - 1;\\n        emit NodeRemoved(_id);\\n    }\\n\\n    /*\\n     * @dev Re-insert the node at a new position, based on its new NICR\\n     * @param _id Node's id\\n     * @param _newNICR Node's new NICR\\n     * @param _prevId Id of previous node for the new insert position\\n     * @param _nextId Id of next node for the new insert position\\n     */\\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\\n        ITroveManager troveManagerCached = troveManager;\\n\\n        _requireCallerIsBOorTroveM(troveManagerCached);\\n        // List must contain the node\\n        require(contains(_id), \\\"SortedTroves: List does not contain the id\\\");\\n        // NICR must be non-zero\\n        require(_newNICR > 0, \\\"SortedTroves: NICR must be positive\\\");\\n\\n        // Remove node from the list\\n        _remove(_id);\\n\\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\\n    }\\n\\n    /*\\n     * @dev Checks if the list contains a node\\n     */\\n    function contains(address _id) public view override returns (bool) {\\n        return data.nodes[_id].exists;\\n    }\\n\\n    /*\\n     * @dev Checks if the list is full\\n     */\\n    function isFull() public view override returns (bool) {\\n        return data.size == data.maxSize;\\n    }\\n\\n    /*\\n     * @dev Checks if the list is empty\\n     */\\n    function isEmpty() public view override returns (bool) {\\n        return data.size == 0;\\n    }\\n\\n    /*\\n     * @dev Returns the current size of the list\\n     */\\n    function getSize() external view override returns (uint256) {\\n        return data.size;\\n    }\\n\\n    /*\\n     * @dev Returns the maximum size of the list\\n     */\\n    function getMaxSize() external view override returns (uint256) {\\n        return data.maxSize;\\n    }\\n\\n    /*\\n     * @dev Returns the first node in the list (node with the largest NICR)\\n     */\\n    function getFirst() external view override returns (address) {\\n        return data.head;\\n    }\\n\\n    /*\\n     * @dev Returns the last node in the list (node with the smallest NICR)\\n     */\\n    function getLast() external view override returns (address) {\\n        return data.tail;\\n    }\\n\\n    /*\\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\\n     * @param _id Node's id\\n     */\\n    function getNext(address _id) external view override returns (address) {\\n        return data.nodes[_id].nextId;\\n    }\\n\\n    /*\\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\\n     * @param _id Node's id\\n     */\\n    function getPrev(address _id) external view override returns (address) {\\n        return data.nodes[_id].prevId;\\n    }\\n\\n    /*\\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\\n     * @param _NICR Node's NICR\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     */\\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\\n    }\\n\\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\\n        if (_prevId == address(0) && _nextId == address(0)) {\\n            // `(null, null)` is a valid insert position if the list is empty\\n            return isEmpty();\\n        } else if (_prevId == address(0)) {\\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\\n        } else if (_nextId == address(0)) {\\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\\n        } else {\\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\\n            return data.nodes[_prevId].nextId == _nextId &&\\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\\n                   _NICR >= _troveManager.getNominalICR(_nextId);\\n        }\\n    }\\n\\n    /*\\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\\u2019s\\n     * @param _NICR Node's NICR\\n     * @param _startId Id of node to start descending the list from\\n     */\\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\\n        // If `_startId` is the head, check if the insert position is before the head\\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\\n            return (address(0), _startId);\\n        }\\n\\n        address prevId = _startId;\\n        address nextId = data.nodes[prevId].nextId;\\n\\n        // Descend the list until we reach the end or until we find a valid insert position\\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\n            prevId = data.nodes[prevId].nextId;\\n            nextId = data.nodes[prevId].nextId;\\n        }\\n\\n        return (prevId, nextId);\\n    }\\n\\n    /*\\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\\u2019s\\n     * @param _NICR Node's NICR\\n     * @param _startId Id of node to start ascending the list from\\n     */\\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\\n        // If `_startId` is the tail, check if the insert position is after the tail\\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\\n            return (_startId, address(0));\\n        }\\n\\n        address nextId = _startId;\\n        address prevId = data.nodes[nextId].prevId;\\n\\n        // Ascend the list until we reach the end or until we find a valid insertion point\\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\n            nextId = data.nodes[nextId].prevId;\\n            prevId = data.nodes[nextId].prevId;\\n        }\\n\\n        return (prevId, nextId);\\n    }\\n\\n    /*\\n     * @dev Find the insert position for a new node with the given NICR\\n     * @param _NICR Node's NICR\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     */\\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\\n    }\\n\\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\\n        address prevId = _prevId;\\n        address nextId = _nextId;\\n\\n        if (prevId != address(0)) {\\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\\n                prevId = address(0);\\n            }\\n        }\\n\\n        if (nextId != address(0)) {\\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\\n                nextId = address(0);\\n            }\\n        }\\n\\n        if (prevId == address(0) && nextId == address(0)) {\\n            // No hint - descend list starting from head\\n            return _descendList(_troveManager, _NICR, data.head);\\n        } else if (prevId == address(0)) {\\n            // No `prevId` for hint - ascend list starting from `nextId`\\n            return _ascendList(_troveManager, _NICR, nextId);\\n        } else if (nextId == address(0)) {\\n            // No `nextId` for hint - descend list starting from `prevId`\\n            return _descendList(_troveManager, _NICR, prevId);\\n        } else {\\n            // Descend list starting from `prevId`\\n            return _descendList(_troveManager, _NICR, prevId);\\n        }\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsTroveManager() internal view {\\n        require(msg.sender == address(troveManager), \\\"SortedTroves: Caller is not the TroveManager\\\");\\n    }\\n\\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\\n                \\\"SortedTroves: Caller is neither BO nor TroveM\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x16223c2cb75b9fb1f776cbe32c4239b3e3e486c357c047cb1085188f10a5c4a2\",\"license\":\"MIT\"},\"contracts/TroveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/IStabilityPool.sol\\\";\\nimport \\\"./interfaces/ICollSurplusPool.sol\\\";\\nimport \\\"./interfaces/ISIMToken.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./interfaces/ISHADYToken.sol\\\";\\nimport \\\"./interfaces/IVeDistributor.sol\\\";\\nimport \\\"./dependencies/Base.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\nimport \\\"./VeDistributor.sol\\\";\\n\\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\\ncontract TroveManager is Base, Ownable, CheckContract, ITroveManager {\\n    string constant public NAME = \\\"TroveManager\\\";\\n\\n    // --- Connected contract declarations ---\\n\\n    address public borrowerOperationsAddress;\\n\\n    IStabilityPool public override stabilityPool;\\n\\n    ICollSurplusPool public collSurplusPool;\\n\\n    ISIMToken public override simToken;\\n\\n    ISHADYToken public override shadyToken;\\n\\n    address public override wstETHVeDistributor;\\n\\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\\n    ISortedTroves public sortedTroves;\\n\\n    // --- Data structures ---\\n\\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\\n    /*\\n     * Half-life of 12h. 12h = 720 min\\n     * (1/2) = d^720 => d = (1/2)^(1/720)\\n     */\\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\\n    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\\n\\n    // During bootsrap period redemptions are not allowed\\n    uint constant public BOOTSTRAP_PERIOD = 30 days;\\n\\n    /*\\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\\n    * Corresponds to (1 / ALPHA) in the white paper.\\n    */\\n    uint constant public BETA = 2;\\n\\n    uint public baseRate;\\n\\n    // The timestamp of the latest fee operation (redemption or new SIM issuance)\\n    uint public lastFeeOperationTime;\\n\\n    enum Status {\\n        nonExistent,\\n        active,\\n        closedByOwner,\\n        closedByLiquidation,\\n        closedByRedemption\\n    }\\n\\n    // Store the necessary data for a trove\\n    struct Trove {\\n        uint debt;\\n        uint coll;\\n        uint stake;\\n        Status status;\\n        uint128 arrayIndex;\\n    }\\n\\n    mapping (address => Trove) public Troves;\\n\\n    uint public totalStakes;\\n\\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\\n    uint public totalStakesSnapshot;\\n\\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\\n    uint public totalCollateralSnapshot;\\n\\n    /*\\n    * L_WSTETH and L_SIMDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\\n    *\\n    * An WSTETH gain of ( stake * [L_WSTETH - L_WSTETH(0)] )\\n    * A SIMDebt increase  of ( stake * [L_SIMDebt - L_SIMDebt(0)] )\\n    *\\n    * Where L_WSTETH(0) and L_SIMDebt(0) are snapshots of L_WSTETH and L_SIMDebt for the active Trove taken at the instant the stake was made\\n    */\\n    uint public L_WSTETH;\\n    uint public L_SIMDebt;\\n\\n    // Map addresses with active troves to their RewardSnapshot\\n    mapping (address => RewardSnapshot) public rewardSnapshots;\\n\\n    // Object containing the WSTETH and SIM snapshots for a given active trove\\n    struct RewardSnapshot { uint WSTETH; uint SIMDebt;}\\n\\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\\n    address[] public TroveOwners;\\n\\n    // Error trackers for the trove redistribution calculation\\n    uint public lastWSTETHError_Redistribution;\\n    uint public lastSIMDebtError_Redistribution;\\n\\n    /*\\n    * --- Variable container structs for liquidations ---\\n    *\\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\\n    * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\n    **/\\n\\n    struct LocalVariables_OuterLiquidationFunction {\\n        uint price;\\n        uint SIMInStabPool;\\n        bool recoveryModeAtStart;\\n        uint liquidatedDebt;\\n        uint liquidatedColl;\\n    }\\n\\n    struct LocalVariables_InnerSingleLiquidateFunction {\\n        uint collToLiquidate;\\n        uint pendingDebtReward;\\n        uint pendingCollReward;\\n    }\\n\\n    struct LocalVariables_LiquidationSequence {\\n        uint remainingSIMInStabPool;\\n        uint i;\\n        uint ICR;\\n        address user;\\n        bool backToNormalMode;\\n        uint entireSystemDebt;\\n        uint entireSystemColl;\\n    }\\n\\n    struct LiquidationValues {\\n        uint entireTroveDebt;\\n        uint entireTroveColl;\\n        uint collGasCompensation;\\n        uint debtToOffset;\\n        uint collToSendToSP;\\n        uint debtToRedistribute;\\n        uint collToRedistribute;\\n        uint collSurplus;\\n    }\\n\\n    struct LiquidationTotals {\\n        uint totalCollInSequence;\\n        uint totalDebtInSequence;\\n        uint totalCollGasCompensation;\\n        uint totalDebtToOffset;\\n        uint totalCollToSendToSP;\\n        uint totalDebtToRedistribute;\\n        uint totalCollToRedistribute;\\n        uint totalCollSurplus;\\n    }\\n\\n    struct ContractsCache {\\n        IActivePool activePool;\\n        IDefaultPool defaultPool;\\n        ISIMToken simToken;\\n        ISortedTroves sortedTroves;\\n        ICollSurplusPool collSurplusPool;\\n    }\\n    // --- Variable container structs for redemptions ---\\n\\n    struct RedemptionTotals {\\n        uint remainingSIM;\\n        uint totalSIMToRedeem;\\n        uint totalWSTETHDrawn;\\n        uint WSTETHFee;\\n        uint WSTETHToSendToRedeemer;\\n        uint decayedBaseRate;\\n        uint price;\\n        uint totalSIMSupplyAtStart;\\n    }\\n\\n    struct SingleRedemptionValues {\\n        uint SIMLot;\\n        uint WSTETHLot;\\n        bool cancelledPartial;\\n    }\\n\\n    enum TroveManagerOperation {\\n        applyPendingRewards,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral\\n    }\\n\\n\\n    // --- Dependency setter ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _simTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _shadyTokenAddress,\\n        address _wstEthVeDistributor\\n    )\\n        external\\n        override\\n        onlyOwner\\n    {\\n        _checkContract(_borrowerOperationsAddress);\\n        _checkContract(_activePoolAddress);\\n        _checkContract(_defaultPoolAddress);\\n        _checkContract(_stabilityPoolAddress);\\n        _checkContract(_collSurplusPoolAddress);\\n        _checkContract(_priceFeedAddress);\\n        _checkContract(_simTokenAddress);\\n        _checkContract(_sortedTrovesAddress);\\n        _checkContract(_shadyTokenAddress);\\n        _checkContract(_wstEthVeDistributor);\\n\\n        borrowerOperationsAddress = _borrowerOperationsAddress;\\n        activePool = IActivePool(_activePoolAddress);\\n        defaultPool = IDefaultPool(_defaultPoolAddress);\\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        simToken = ISIMToken(_simTokenAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        shadyToken = ISHADYToken(_shadyTokenAddress);\\n        wstETHVeDistributor = _wstEthVeDistributor;\\n\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit SIMTokenAddressChanged(_simTokenAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit SHADYTokenAddressChanged(_shadyTokenAddress);\\n        emit WSTETHVeDistibutorAddressChanged(_wstEthVeDistributor);\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Getters ---\\n\\n    function getTroveOwnersCount() external view override returns (uint) {\\n        return TroveOwners.length;\\n    }\\n\\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\\n        return TroveOwners[_index];\\n    }\\n\\n    // --- Trove Liquidation functions ---\\n\\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\\n    function liquidate(address _borrower) external override {\\n        _requireTroveIsActive(_borrower);\\n\\n        address[] memory borrowers = new address[](1);\\n        borrowers[0] = _borrower;\\n        batchLiquidateTroves(borrowers);\\n    }\\n\\n    // --- Inner single liquidation functions ---\\n\\n    // Liquidate one trove, in Normal Mode.\\n    function _liquidateNormalMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        address _borrower,\\n        uint _SIMInStabPool\\n    )\\n        internal\\n        returns (LiquidationValues memory singleLiquidation)\\n    {\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\n\\n        (singleLiquidation.entireTroveDebt,\\n        singleLiquidation.entireTroveColl,\\n        vars.pendingDebtReward,\\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\\n\\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\n        _removeStake(_borrower);\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\\n        uint collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\\n\\n        (singleLiquidation.debtToOffset,\\n        singleLiquidation.collToSendToSP,\\n        singleLiquidation.debtToRedistribute,\\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _SIMInStabPool);\\n\\n        _closeTrove(_borrower, Status.closedByLiquidation);\\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInNormalMode));\\n        emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInNormalMode));\\n        return singleLiquidation;\\n    }\\n\\n    // Liquidate one trove, in Recovery Mode.\\n    function _liquidateRecoveryMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        address _borrower,\\n        uint _ICR,\\n        uint _SIMInStabPool,\\n        uint _TCR,\\n        uint _price\\n    )\\n        internal\\n        returns (LiquidationValues memory singleLiquidation)\\n    {\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\\n        (singleLiquidation.entireTroveDebt,\\n        singleLiquidation.entireTroveColl,\\n        vars.pendingDebtReward,\\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\\n        vars.collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\\n\\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\\n        if (_ICR <= _100pct) {\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\n            _removeStake(_borrower);\\n\\n            singleLiquidation.debtToOffset = 0;\\n            singleLiquidation.collToSendToSP = 0;\\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n\\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\n            _removeStake(_borrower);\\n\\n            (singleLiquidation.debtToOffset,\\n            singleLiquidation.collToSendToSP,\\n            singleLiquidation.debtToRedistribute,\\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _SIMInStabPool);\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n        /*\\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\\n        * and there is SIM in the Stability Pool, only offset, with no redistribution,\\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\\n        * The remainder due to the capped rate will be claimable as collateral surplus.\\n        */\\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _SIMInStabPool)) {\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\n            assert(_SIMInStabPool != 0);\\n\\n            _removeStake(_borrower);\\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            if (singleLiquidation.collSurplus > 0) {\\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\\n            }\\n\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\\n\\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _SIMInStabPool))\\n            LiquidationValues memory zeroVals;\\n            return zeroVals;\\n        }\\n\\n        return singleLiquidation;\\n    }\\n\\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\\n    * redistributed to active troves.\\n    */\\n    function _getOffsetAndRedistributionVals\\n    (\\n        uint _debt,\\n        uint _coll,\\n        uint _SIMInStabPool\\n    )\\n        internal\\n        pure\\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\\n    {\\n        if (_SIMInStabPool > 0) {\\n        /*\\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\\n        * between all active troves.\\n        *\\n        *  If the trove's debt is larger than the deposited SIM in the Stability Pool:\\n        *\\n        *  - Offset an amount of the trove's debt equal to the SIM in the Stability Pool\\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\\n        *\\n        */\\n            debtToOffset = LiquityMath._min(_debt, _SIMInStabPool);\\n            collToSendToSP = _coll * debtToOffset / _debt;\\n            debtToRedistribute = _debt - debtToOffset;\\n            collToRedistribute = _coll - collToSendToSP;\\n        } else {\\n            debtToOffset = 0;\\n            collToSendToSP = 0;\\n            debtToRedistribute = _debt;\\n            collToRedistribute = _coll;\\n        }\\n    }\\n\\n    /*\\n    *  Get its offset coll/debt and WSTETH gas comp, and close the trove.\\n    */\\n    function _getCappedOffsetVals\\n    (\\n        uint _entireTroveDebt,\\n        uint _entireTroveColl,\\n        uint _price\\n    )\\n        internal\\n        pure\\n        returns (LiquidationValues memory singleLiquidation)\\n    {\\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\\n        singleLiquidation.entireTroveColl = _entireTroveColl;\\n        uint cappedCollPortion = _entireTroveDebt * MCR / _price;\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\\n\\n        singleLiquidation.debtToOffset = _entireTroveDebt;\\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\\n        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;\\n        singleLiquidation.debtToRedistribute = 0;\\n        singleLiquidation.collToRedistribute = 0;\\n    }\\n\\n    /*\\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\\n    */\\n    function liquidateTroves(uint _n) external override {\\n        ContractsCache memory contractsCache = ContractsCache(\\n            activePool,\\n            defaultPool,\\n            ISIMToken(address(0)),\\n//            IVe(address(0)),\\n            sortedTroves,\\n            ICollSurplusPool(address(0))/*,\\n            address(0)*/\\n        );\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\n\\n        LocalVariables_OuterLiquidationFunction memory vars;\\n\\n        LiquidationTotals memory totals;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\n\\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\\n        if (vars.recoveryModeAtStart) {\\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.SIMInStabPool, _n);\\n        } else { // if !vars.recoveryModeAtStart\\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.SIMInStabPool, _n);\\n        }\\n\\n        require(totals.totalDebtInSequence > 0, \\\"TroveManager: nothing to liquidate\\\");\\n\\n        // Move liquidated WSTETH and SIM to the appropriate pools\\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\\n        if (totals.totalCollSurplus > 0) {\\n            contractsCache.activePool.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\\n        }\\n\\n        // Update system snapshots\\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\\n\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\\n\\n        // Send gas compensation to caller\\n        _sendGasCompensation(contractsCache.activePool, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\\n    }\\n\\n    /*\\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\n    */\\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\\n    (\\n        ContractsCache memory _contractsCache,\\n        uint _price,\\n        uint _SIMInStabPool,\\n        uint _n\\n    )\\n        internal\\n        returns(LiquidationTotals memory totals)\\n    {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingSIMInStabPool = _SIMInStabPool;\\n        vars.backToNormalMode = false;\\n        vars.entireSystemDebt = getEntireSystemDebt();\\n        vars.entireSystemColl = getEntireSystemColl();\\n\\n        vars.user = _contractsCache.sortedTroves.getLast();\\n        address firstUser = _contractsCache.sortedTroves.getFirst();\\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\\n            // we need to cache it, because current user is likely going to be deleted\\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\\n\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (!vars.backToNormalMode) {\\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { break; }\\n\\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\\n\\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\\n\\n                // Update aggregate trackers\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\\n            }\\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingSIMInStabPool);\\n\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n\\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\\n\\n            vars.user = nextUser;\\n        }\\n    }\\n\\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\\n    (\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _SIMInStabPool,\\n        uint _n\\n    )\\n        internal\\n        returns(LiquidationTotals memory totals)\\n    {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n        ISortedTroves sortedTrovesCached = sortedTroves;\\n\\n        vars.remainingSIMInStabPool = _SIMInStabPool;\\n\\n        for (vars.i = 0; vars.i < _n; vars.i++) {\\n            vars.user = sortedTrovesCached.getLast();\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\\n\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n\\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\\n        }\\n    }\\n\\n    /*\\n    * Attempt to liquidate a custom list of troves provided by the caller.\\n    */\\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\\n        require(_troveArray.length != 0, \\\"TroveManager: Calldata address array must not be empty\\\");\\n\\n        IActivePool activePoolCached = activePool;\\n        IDefaultPool defaultPoolCached = defaultPool;\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\n\\n        LocalVariables_OuterLiquidationFunction memory vars;\\n        LiquidationTotals memory totals;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\n\\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\\n        if (vars.recoveryModeAtStart) {\\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\\n        } else {  //  if !vars.recoveryModeAtStart\\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\\n        }\\n\\n        require(totals.totalDebtInSequence > 0, \\\"TroveManager: nothing to liquidate\\\");\\n\\n        // Move liquidated WSTETH and SIM to the appropriate pools\\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\\n        if (totals.totalCollSurplus > 0) {\\n            activePoolCached.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\\n        }\\n\\n        // Update system snapshots\\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\\n\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\\n\\n        // Send gas compensation to caller\\n        _sendGasCompensation(activePoolCached, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\\n    }\\n\\n    /*\\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\n    */\\n    function _getTotalFromBatchLiquidate_RecoveryMode\\n    (\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _SIMInStabPool,\\n        address[] memory _troveArray\\n    )\\n        internal\\n        returns(LiquidationTotals memory totals)\\n    {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingSIMInStabPool = _SIMInStabPool;\\n        vars.backToNormalMode = false;\\n        vars.entireSystemDebt = getEntireSystemDebt();\\n        vars.entireSystemColl = getEntireSystemColl();\\n\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\n            vars.user = _troveArray[vars.i];\\n            // Skip non-active troves\\n            if (Troves[vars.user].status != Status.active) { continue; }\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (!vars.backToNormalMode) {\\n\\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { continue; }\\n\\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\\n\\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\\n\\n                // Update aggregate trackers\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\\n            }\\n\\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n\\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\\n        }\\n    }\\n\\n    function _getTotalsFromBatchLiquidate_NormalMode\\n    (\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _SIMInStabPool,\\n        address[] memory _troveArray\\n    )\\n        internal\\n        returns(LiquidationTotals memory totals)\\n    {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingSIMInStabPool = _SIMInStabPool;\\n\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\n            vars.user = _troveArray[vars.i];\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\n            }\\n        }\\n    }\\n\\n    // --- Liquidation helper functions ---\\n\\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\\n    internal pure returns(LiquidationTotals memory newTotals) {\\n\\n        // Tally all the values with their respective running totals\\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\\n//        newTotals.totalSIMGasCompensation = oldTotals.totalSIMGasCompensation + singleLiquidation.SIMGasCompensation;\\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence + singleLiquidation.entireTroveColl;\\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;\\n\\n        return newTotals;\\n    }\\n\\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, /*uint _SIM,*/ uint _WSTETH) internal {\\n        /*if (_SIM > 0) {\\n            simToken.returnFromPool(gasPoolAddress, _liquidator, _SIM);\\n        }*/\\n\\n        if (_WSTETH > 0) {\\n            _activePool.sendWSTETH(_liquidator, _WSTETH);\\n        }\\n    }\\n\\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _SIM, uint _WSTETH) internal {\\n        _defaultPool.decreaseSIMDebt(_SIM);\\n        _activePool.increaseSIMDebt(_SIM);\\n        _defaultPool.sendWSTETHToActivePool(_WSTETH);\\n    }\\n\\n    // --- Redemption functions ---\\n\\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for SIM up to _maxSIMamount\\n    function _redeemCollateralFromTrove(\\n        ContractsCache memory _contractsCache,\\n        address _borrower,\\n        uint _maxSIMamount,\\n        uint _price,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR\\n    )\\n        internal returns (SingleRedemptionValues memory singleRedemption)\\n    {\\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\\n        singleRedemption.SIMLot = LiquityMath._min(_maxSIMamount, Troves[_borrower].debt);\\n\\n        // Get the WSTETHLot of equivalent value in USD\\n        singleRedemption.WSTETHLot = singleRedemption.SIMLot * DECIMAL_PRECISION / _price;\\n\\n        // Decrease the debt and collateral of the current Trove according to the SIM lot and corresponding WSTETH to send\\n        uint newDebt = (Troves[_borrower].debt) - singleRedemption.SIMLot;\\n        uint newColl = (Troves[_borrower].coll) - singleRedemption.WSTETHLot;\\n\\n        if (newDebt == 0) {\\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\\n            _removeStake(_borrower);\\n            _closeTrove(_borrower, Status.closedByRedemption);\\n            _redeemCloseTrove(_contractsCache, _borrower, newColl);\\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.redeemCollateral));\\n        } else {\\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\\n\\n            /*\\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\\n            * certainly result in running out of gas.\\n            *\\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\\n            */\\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\\n                singleRedemption.cancelledPartial = true;\\n                return singleRedemption;\\n            }\\n\\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\\n\\n            Troves[_borrower].debt = newDebt;\\n            Troves[_borrower].coll = newColl;\\n            _updateStakeAndTotalStakes(_borrower);\\n\\n            emit TroveUpdated(\\n                _borrower,\\n                newDebt, newColl,\\n                Troves[_borrower].stake,\\n                uint8(TroveManagerOperation.redeemCollateral)\\n            );\\n        }\\n\\n        return singleRedemption;\\n    }\\n\\n    /*\\n    * Called when a full redemption occurs, and closes the trove.\\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\\n    * Any surplus WSTETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\\n    */\\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint _WSTETH) internal {\\n        // send WSTETH from Active Pool to CollSurplus Pool\\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _WSTETH);\\n        _contractsCache.activePool.sendWSTETH(address(_contractsCache.collSurplusPool), _WSTETH);\\n    }\\n\\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint _price) internal view returns (bool) {\\n        if (_firstRedemptionHint == address(0) ||\\n            !_sortedTroves.contains(_firstRedemptionHint) ||\\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\\n        ) {\\n            return false;\\n        }\\n\\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\\n    }\\n\\n    /* Send _SIMamount SIM to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\\n    *\\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\\n    *\\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it\\u2019s zero, it will be ignored).This makes it easier to\\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the \\u201ctopology\\u201d\\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\\n    * costs can vary.\\n    *\\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\\n    * in the sortedTroves list along with the ICR value that the hint was found for.\\n    *\\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining SIM amount, which they can attempt\\n    * to redeem later.\\n    */\\n    function redeemCollateral(\\n        uint _SIMamount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFeePercentage\\n    )\\n        external\\n        override\\n    {\\n        ContractsCache memory contractsCache = ContractsCache(\\n            activePool,\\n            defaultPool,\\n            simToken,\\n            sortedTroves,\\n            collSurplusPool\\n        );\\n        RedemptionTotals memory totals;\\n\\n        _requireValidMaxFeePercentage(_maxFeePercentage);\\n        _requireAfterBootstrapPeriod();\\n        totals.price = priceFeed.fetchPrice();\\n        _requireTCRoverMCR(totals.price);\\n        _requireAmountGreaterThanZero(_SIMamount);\\n        _requireSIMBalanceCoversRedemption(contractsCache.simToken, msg.sender, _SIMamount);\\n\\n        totals.totalSIMSupplyAtStart = getEntireSystemDebt();\\n        // Confirm redeemer's balance is less than total SIM supply\\n        assert(contractsCache.simToken.balanceOf(msg.sender) <= totals.totalSIMSupplyAtStart);\\n\\n        totals.remainingSIM = _SIMamount;\\n        address currentBorrower;\\n\\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\\n            currentBorrower = _firstRedemptionHint;\\n        } else {\\n            currentBorrower = contractsCache.sortedTroves.getLast();\\n            // Find the first trove with ICR >= MCR\\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\\n            }\\n        }\\n\\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of SIM is exchanged for collateral\\n        if (_maxIterations == 0) { _maxIterations = type(uint).max; }\\n        while (currentBorrower != address(0) && totals.remainingSIM > 0 && _maxIterations > 0) {\\n            _maxIterations--;\\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\\n\\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\\n\\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\\n                contractsCache,\\n                currentBorrower,\\n                totals.remainingSIM,\\n                totals.price,\\n                _upperPartialRedemptionHint,\\n                _lowerPartialRedemptionHint,\\n                _partialRedemptionHintNICR\\n            );\\n\\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\\n\\n            totals.totalSIMToRedeem  = totals.totalSIMToRedeem + singleRedemption.SIMLot;\\n            totals.totalWSTETHDrawn = totals.totalWSTETHDrawn + singleRedemption.WSTETHLot;\\n\\n            totals.remainingSIM = totals.remainingSIM - singleRedemption.SIMLot;\\n            currentBorrower = nextUserToCheck;\\n        }\\n        require(totals.totalWSTETHDrawn > 0, \\\"TroveManager: Unable to redeem any amount\\\");\\n\\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\\n        // Use the saved total SIM supply value, from before it was reduced by the redemption.\\n        _updateBaseRateFromRedemption(totals.totalWSTETHDrawn, totals.price, totals.totalSIMSupplyAtStart);\\n\\n        // Calculate the WSTETH fee\\n        totals.WSTETHFee = _getRedemptionFee(totals.totalWSTETHDrawn);\\n\\n        _requireUserAcceptsFee(totals.WSTETHFee, totals.totalWSTETHDrawn, _maxFeePercentage);\\n\\n        // Send the WSTETH fee to the VeDistributor contract\\n        contractsCache.activePool.sendWSTETH(wstETHVeDistributor, totals.WSTETHFee);\\n        IVeDistributor(wstETHVeDistributor).checkpoint();\\n\\n        totals.WSTETHToSendToRedeemer = totals.totalWSTETHDrawn - totals.WSTETHFee;\\n\\n        emit Redemption(_SIMamount, totals.totalSIMToRedeem, totals.totalWSTETHDrawn, totals.WSTETHFee);\\n\\n        // Burn the total SIM that is cancelled with debt, and send the redeemed WSTETH to msg.sender\\n        contractsCache.simToken.burn(msg.sender, totals.totalSIMToRedeem);\\n        // Update Active Pool SIM, and send WSTETH to account\\n        contractsCache.activePool.decreaseSIMDebt(totals.totalSIMToRedeem);\\n        contractsCache.activePool.sendWSTETH(msg.sender, totals.WSTETHToSendToRedeemer);\\n    }\\n\\n    // --- Helper functions ---\\n\\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\\n    function getNominalICR(address _borrower) public view override returns (uint) {\\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\\n\\n        uint NICR = LiquityMath._computeNominalCR(currentWSTETH, currentSIMDebt);\\n        return NICR;\\n    }\\n\\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\\n\\n        uint ICR = LiquityMath._computeCR(currentWSTETH, currentSIMDebt, _price);\\n        return ICR;\\n    }\\n\\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\\n        uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\\n        uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\\n\\n        uint currentWSTETH = Troves[_borrower].coll + pendingWSTETHReward;\\n        uint currentSIMDebt = Troves[_borrower].debt + pendingSIMDebtReward;\\n\\n        return (currentWSTETH, currentSIMDebt);\\n    }\\n\\n    function applyPendingRewards(address _borrower) external override {\\n        _requireCallerIsBorrowerOperations();\\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\\n    }\\n\\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\\n        if (hasPendingRewards(_borrower)) {\\n            _requireTroveIsActive(_borrower);\\n\\n            // Compute pending rewards\\n            uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\\n            uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\\n\\n            // Apply pending rewards to trove's state\\n            Troves[_borrower].coll = Troves[_borrower].coll + pendingWSTETHReward;\\n            Troves[_borrower].debt = Troves[_borrower].debt + pendingSIMDebtReward;\\n\\n            _updateTroveRewardSnapshots(_borrower);\\n\\n            // Transfer from DefaultPool to ActivePool\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingSIMDebtReward, pendingWSTETHReward);\\n\\n            emit TroveUpdated(\\n                _borrower,\\n                Troves[_borrower].debt,\\n                Troves[_borrower].coll,\\n                Troves[_borrower].stake,\\n                uint8(TroveManagerOperation.applyPendingRewards)\\n            );\\n        }\\n    }\\n\\n    // Update borrower's snapshots of L_WSTETH and L_SIMDebt to reflect the current values\\n    function updateTroveRewardSnapshots(address _borrower) external override {\\n        _requireCallerIsBorrowerOperations();\\n       return _updateTroveRewardSnapshots(_borrower);\\n    }\\n\\n    function _updateTroveRewardSnapshots(address _borrower) internal {\\n        rewardSnapshots[_borrower].WSTETH = L_WSTETH;\\n        rewardSnapshots[_borrower].SIMDebt = L_SIMDebt;\\n        emit TroveSnapshotsUpdated(L_WSTETH, L_SIMDebt);\\n    }\\n\\n    // Get the borrower's pending accumulated WSTETH reward, earned by their stake\\n    function getPendingWSTETHReward(address _borrower) public view override returns (uint) {\\n        uint snapshotWSTETH = rewardSnapshots[_borrower].WSTETH;\\n        uint rewardPerUnitStaked = L_WSTETH - snapshotWSTETH;\\n\\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\\n\\n        uint stake = Troves[_borrower].stake;\\n\\n        uint pendingWSTETHReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\\n\\n        return pendingWSTETHReward;\\n    }\\n\\n    // Get the borrower's pending accumulated SIM reward, earned by their stake\\n    function getPendingSIMDebtReward(address _borrower) public view override returns (uint) {\\n        uint snapshotSIMDebt = rewardSnapshots[_borrower].SIMDebt;\\n        uint rewardPerUnitStaked = L_SIMDebt - snapshotSIMDebt;\\n\\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\\n\\n        uint stake =  Troves[_borrower].stake;\\n\\n        uint pendingSIMDebtReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\\n\\n        return pendingSIMDebtReward;\\n    }\\n\\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\\n        /*\\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\\n        * pending rewards\\n        */\\n        if (Troves[_borrower].status != Status.active) {return false;}\\n\\n        return (rewardSnapshots[_borrower].WSTETH < L_WSTETH);\\n    }\\n\\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    )\\n        public\\n        view\\n        override\\n        returns (uint debt, uint coll, uint pendingSIMDebtReward, uint pendingWSTETHReward)\\n    {\\n        debt = Troves[_borrower].debt;\\n        coll = Troves[_borrower].coll;\\n\\n        pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\\n        pendingWSTETHReward = getPendingWSTETHReward(_borrower);\\n\\n        debt = debt + pendingSIMDebtReward;\\n        coll = coll + pendingWSTETHReward;\\n    }\\n\\n    function removeStake(address _borrower) external override {\\n        _requireCallerIsBorrowerOperations();\\n        return _removeStake(_borrower);\\n    }\\n\\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\\n    function _removeStake(address _borrower) internal {\\n        uint stake = Troves[_borrower].stake;\\n        totalStakes = totalStakes - stake;\\n        Troves[_borrower].stake = 0;\\n    }\\n\\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        return _updateStakeAndTotalStakes(_borrower);\\n    }\\n\\n    // Update borrower's stake based on their latest collateral value\\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\\n        uint oldStake = Troves[_borrower].stake;\\n        Troves[_borrower].stake = newStake;\\n\\n        totalStakes = totalStakes - oldStake + newStake;\\n        emit TotalStakesUpdated(totalStakes);\\n\\n        return newStake;\\n    }\\n\\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\\n    function _computeNewStake(uint _coll) internal view returns (uint) {\\n        uint stake;\\n        if (totalCollateralSnapshot == 0) {\\n            stake = _coll;\\n        } else {\\n            /*\\n            * The following assert() holds true because:\\n            * - The system always contains >= 1 trove\\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\\n            * rewards would\\u2019ve been emptied and totalCollateralSnapshot would be zero too.\\n            */\\n            assert(totalStakesSnapshot > 0);\\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\\n        }\\n        return stake;\\n    }\\n\\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, uint _coll) internal {\\n        if (_debt == 0) { return; }\\n\\n        /*\\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \\\"feedback\\\"\\n        * error correction, to keep the cumulative error low in the running totals L_WSTETH and L_SIMDebt:\\n        *\\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\n        * function was called.\\n        * 2) Calculate \\\"per-unit-staked\\\" ratios.\\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\n        * 4) Store these errors for use in the next correction when this function is called.\\n        * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n        */\\n        uint WSTETHNumerator = _coll * DECIMAL_PRECISION + lastWSTETHError_Redistribution;\\n        uint SIMDebtNumerator = _debt * DECIMAL_PRECISION + lastSIMDebtError_Redistribution;\\n\\n        // Get the per-unit-staked terms\\n        uint WSTETHRewardPerUnitStaked = WSTETHNumerator / totalStakes;\\n        uint SIMDebtRewardPerUnitStaked = SIMDebtNumerator / totalStakes;\\n\\n        lastWSTETHError_Redistribution = WSTETHNumerator - WSTETHRewardPerUnitStaked * totalStakes;\\n        lastSIMDebtError_Redistribution = SIMDebtNumerator - SIMDebtRewardPerUnitStaked * totalStakes;\\n\\n        // Add per-unit-staked terms to the running totals\\n        L_WSTETH = L_WSTETH + WSTETHRewardPerUnitStaked;\\n        L_SIMDebt = L_SIMDebt + SIMDebtRewardPerUnitStaked;\\n\\n        emit LTermsUpdated(L_WSTETH, L_SIMDebt);\\n\\n        // Transfer coll and debt from ActivePool to DefaultPool\\n        _activePool.decreaseSIMDebt(_debt);\\n        _defaultPool.increaseSIMDebt(_debt);\\n        _activePool.sendWSTETH(address(_defaultPool), _coll);\\n    }\\n\\n    function closeTrove(address _borrower) external override {\\n        _requireCallerIsBorrowerOperations();\\n        return _closeTrove(_borrower, Status.closedByOwner);\\n    }\\n\\n    function _closeTrove(address _borrower, Status closedStatus) internal {\\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\\n\\n        uint TroveOwnersArrayLength = TroveOwners.length;\\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\\n\\n        Troves[_borrower].status = closedStatus;\\n        Troves[_borrower].coll = 0;\\n        Troves[_borrower].debt = 0;\\n\\n        rewardSnapshots[_borrower].WSTETH = 0;\\n        rewardSnapshots[_borrower].SIMDebt = 0;\\n\\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\\n        sortedTroves.remove(_borrower);\\n    }\\n\\n    /*\\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\\n    * Used in a liquidation sequence.\\n    *\\n    * The calculation excludes a portion of collateral that is in the ActivePool:\\n    *\\n    * the total WSTETH gas compensation from the liquidation sequence\\n    *\\n    * The WSTETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\\n    */\\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint _collRemainder) internal {\\n        totalStakesSnapshot = totalStakes;\\n\\n        uint activeColl = _activePool.getWSTETH();\\n        uint liquidatedColl = defaultPool.getWSTETH();\\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\\n\\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\\n    }\\n\\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\\n        _requireCallerIsBorrowerOperations();\\n        return _addTroveOwnerToArray(_borrower);\\n    }\\n\\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum SIM\\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 SIM dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\\n\\n        // Push the Troveowner to the array\\n        TroveOwners.push(_borrower);\\n\\n        // Record the index of the new Troveowner on their Trove struct\\n        index = uint128(TroveOwners.length - 1);\\n        Troves[_borrower].arrayIndex = index;\\n\\n        return index;\\n    }\\n\\n    /*\\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\\n    */\\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\\n        Status troveStatus = Troves[_borrower].status;\\n        // It\\u2019s set in caller function `_closeTrove`\\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\\n\\n        uint128 index = Troves[_borrower].arrayIndex;\\n        uint length = TroveOwnersArrayLength;\\n        uint idxLast = length - 1;\\n\\n        assert(index <= idxLast);\\n\\n        address addressToMove = TroveOwners[idxLast];\\n\\n        TroveOwners[index] = addressToMove;\\n        Troves[addressToMove].arrayIndex = index;\\n        emit TroveIndexUpdated(addressToMove, index);\\n\\n        TroveOwners.pop();\\n    }\\n\\n    // --- Recovery Mode and TCR functions ---\\n\\n    function getTCR(uint _price) external view override returns (uint) {\\n        return _getTCR(_price);\\n    }\\n\\n    function checkRecoveryMode(uint _price) external view override returns (bool) {\\n        return _checkRecoveryMode(_price);\\n    }\\n\\n    // Check whether or not the system *would be* in Recovery Mode, given an WSTETH:USD price, and the entire system coll and debt.\\n    function _checkPotentialRecoveryMode(\\n        uint _entireSystemColl,\\n        uint _entireSystemDebt,\\n        uint _price\\n    )\\n        internal\\n        pure\\n    returns (bool)\\n    {\\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\\n\\n        return TCR < CCR;\\n    }\\n\\n    // --- Redemption fee functions ---\\n\\n    /*\\n    * This function has two impacts on the baseRate state variable:\\n    * 1) decays the baseRate based on time passed since last redemption or SIM borrowing operation.\\n    * then,\\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\\n    */\\n    function _updateBaseRateFromRedemption(uint _WSTETHDrawn,  uint _price, uint _totalSIMSupply) internal returns (uint) {\\n        uint decayedBaseRate = _calcDecayedBaseRate();\\n\\n        /* Convert the drawn WSTETH back to SIM at face value rate (1 SIM:1 USD), in order to get\\n        * the fraction of total supply that was redeemed at face value. */\\n        uint redeemedSIMFraction = _WSTETHDrawn * _price / _totalSIMSupply;\\n\\n        uint newBaseRate = decayedBaseRate + redeemedSIMFraction / BETA;\\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\\n\\n        // Update the baseRate state variable\\n        baseRate = newBaseRate;\\n        emit BaseRateUpdated(newBaseRate);\\n\\n        _updateLastFeeOpTime();\\n\\n        return newBaseRate;\\n    }\\n\\n    function getRedemptionRate() public view override returns (uint) {\\n        return _calcRedemptionRate(baseRate);\\n    }\\n\\n    function getRedemptionRateWithDecay() public view override returns (uint) {\\n        return _calcRedemptionRate(_calcDecayedBaseRate());\\n    }\\n\\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\\n        return LiquityMath._min(\\n            REDEMPTION_FEE_FLOOR + _baseRate,\\n            DECIMAL_PRECISION // cap at a maximum of 100%\\n        );\\n    }\\n\\n    function _getRedemptionFee(uint _WSTETHDrawn) internal view returns (uint) {\\n        return _calcRedemptionFee(getRedemptionRate(), _WSTETHDrawn);\\n    }\\n\\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view override returns (uint) {\\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _WSTETHDrawn);\\n    }\\n\\n    function _calcRedemptionFee(uint _redemptionRate, uint _WSTETHDrawn) internal pure returns (uint) {\\n        uint redemptionFee = _redemptionRate * _WSTETHDrawn / DECIMAL_PRECISION;\\n        require(redemptionFee < _WSTETHDrawn, \\\"TroveManager: Fee would eat up all returned collateral\\\");\\n        return redemptionFee;\\n    }\\n\\n    // --- Borrowing fee functions ---\\n\\n    function getBorrowingRate() public view override returns (uint) {\\n        return _calcBorrowingRate(baseRate);\\n    }\\n\\n    function getBorrowingRateWithDecay() public view override returns (uint) {\\n        return _calcBorrowingRate(_calcDecayedBaseRate());\\n    }\\n\\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\\n        return LiquityMath._min(\\n            BORROWING_FEE_FLOOR + _baseRate,\\n            MAX_BORROWING_FEE\\n        );\\n    }\\n\\n    function getBorrowingFee(uint _SIMDebt) external view override returns (uint) {\\n        return _calcBorrowingFee(getBorrowingRate(), _SIMDebt);\\n    }\\n\\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view override returns (uint) {\\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _SIMDebt);\\n    }\\n\\n    function _calcBorrowingFee(uint _borrowingRate, uint _SIMDebt) internal pure returns (uint) {\\n        return _borrowingRate * _SIMDebt / DECIMAL_PRECISION;\\n    }\\n\\n\\n    // Updates the baseRate state variable based on time elapsed since the last redemption or SIM borrowing operation.\\n    function decayBaseRateFromBorrowing() external override {\\n        _requireCallerIsBorrowerOperations();\\n\\n        uint decayedBaseRate = _calcDecayedBaseRate();\\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\\n\\n        baseRate = decayedBaseRate;\\n        emit BaseRateUpdated(decayedBaseRate);\\n\\n        _updateLastFeeOpTime();\\n    }\\n\\n    // --- Internal fee functions ---\\n\\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\\n    function _updateLastFeeOpTime() internal {\\n        uint timePassed = block.timestamp - lastFeeOperationTime;\\n\\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\\n            lastFeeOperationTime = block.timestamp;\\n            emit LastFeeOpTimeUpdated(block.timestamp);\\n        }\\n    }\\n\\n    function _calcDecayedBaseRate() internal view returns (uint) {\\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\\n\\n        return baseRate * decayFactor / DECIMAL_PRECISION;\\n    }\\n\\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\\n        return (block.timestamp - lastFeeOperationTime) / SECONDS_IN_ONE_MINUTE;\\n    }\\n\\n    // --- 'require' wrapper functions ---\\n\\n    function _requireCallerIsBorrowerOperations() internal view {\\n        require(msg.sender == borrowerOperationsAddress, \\\"TroveManager: Caller is not the BorrowerOperations contract\\\");\\n    }\\n\\n    function _requireTroveIsActive(address _borrower) internal view {\\n        require(Troves[_borrower].status == Status.active, \\\"TroveManager: Trove does not exist or is closed\\\");\\n    }\\n\\n    function _requireSIMBalanceCoversRedemption(ISIMToken _simToken, address _redeemer, uint _amount) internal view {\\n        require(_simToken.balanceOf(_redeemer) >= _amount, \\\"TroveManager: Requested redemption amount must be <= user's SIM token balance\\\");\\n    }\\n\\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \\\"TroveManager: Only one trove in the system\\\");\\n    }\\n\\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\\n        require(_amount > 0, \\\"TroveManager: Amount must be greater than zero\\\");\\n    }\\n\\n    function _requireTCRoverMCR(uint _price) internal view {\\n        require(_getTCR(_price) >= MCR, \\\"TroveManager: Cannot redeem when TCR < MCR\\\");\\n    }\\n\\n    function _requireAfterBootstrapPeriod() internal view {\\n        uint systemDeploymentTime = shadyToken.getDeploymentStartTime();\\n        require(block.timestamp >= systemDeploymentTime + BOOTSTRAP_PERIOD, \\\"TroveManager: Redemptions are not allowed during bootstrap phase\\\");\\n    }\\n\\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal pure {\\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\\n            \\\"Max fee percentage must be between 0.5% and 100%\\\");\\n    }\\n\\n    // --- Trove property getters ---\\n\\n    function getTroveStatus(address _borrower) external view override returns (uint) {\\n        return uint(Troves[_borrower].status);\\n    }\\n\\n    function getTroveStake(address _borrower) external view override returns (uint) {\\n        return Troves[_borrower].stake;\\n    }\\n\\n    function getTroveDebt(address _borrower) external view override returns (uint) {\\n        return Troves[_borrower].debt;\\n    }\\n\\n    function getTroveColl(address _borrower) external view override returns (uint) {\\n        return Troves[_borrower].coll;\\n    }\\n\\n    // --- Trove property setters, called by BorrowerOperations ---\\n\\n    function setTroveStatus(address _borrower, uint _num) external override {\\n        _requireCallerIsBorrowerOperations();\\n        Troves[_borrower].status = Status(_num);\\n    }\\n\\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newColl = Troves[_borrower].coll + _collIncrease;\\n        Troves[_borrower].coll = newColl;\\n        return newColl;\\n    }\\n\\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newColl = Troves[_borrower].coll - _collDecrease;\\n        Troves[_borrower].coll = newColl;\\n        return newColl;\\n    }\\n\\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newDebt = Troves[_borrower].debt + _debtIncrease;\\n        Troves[_borrower].debt = newDebt;\\n        return newDebt;\\n    }\\n\\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newDebt = Troves[_borrower].debt - _debtDecrease;\\n        Troves[_borrower].debt = newDebt;\\n        return newDebt;\\n    }\\n}\\n\",\"keccak256\":\"0xc19ecd8bb9573c8155b3a012cf404c7566cec09ed4046ec6bee764b46feff6f2\",\"license\":\"MIT\"},\"contracts/VeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./interfaces/IVe.sol\\\";\\nimport \\\"./interfaces/IVeDistributor.sol\\\";\\nimport \\\"./dependencies/ControllableV3.sol\\\";\\n\\n// https://github.com/tetu-io/tetu-contracts-v2/blob/master/contracts/ve/VeDistributor.sol\\n/// @title Contract for distributing rewards to ve holders.\\n///        Rewards will be staked to the veNFT without extending lock period.\\n///        Based on Solidly contract.\\n/// @author belbix\\ncontract VeDistributor is ControllableV3, IVeDistributor {\\n  using SafeERC20 for IERC20;\\n\\n  // for contract internal purposes, don't need to store in the interface\\n  struct ClaimCalculationResult {\\n    uint toDistribute;\\n    uint userEpoch;\\n    uint weekCursor;\\n    uint maxUserEpoch;\\n    bool success;\\n  }\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\n  string public constant VE_DIST_VERSION = \\\"1.0.0\\\";\\n  uint internal constant WEEK = 7 * 86400;\\n\\n  // *************************************************************\\n  //                        VARIABLES\\n  //                Keep names and ordering!\\n  //                 Add only in the bottom.\\n  // *************************************************************\\n\\n  /// @dev Voting escrow token address\\n  IVe public ve;\\n  /// @dev Token for ve rewards\\n  address public override rewardToken;\\n\\n  // --- CHECKPOINT\\n\\n  /// @dev Cursor for the current epoch\\n  uint public activePeriod;\\n  /// @dev Tokens per week stored on checkpoint call. Predefined array size = max weeks size\\n  uint[1000000000000000] public tokensPerWeek;\\n  /// @dev Ve supply checkpoints. Predefined array size = max weeks size\\n  uint[1000000000000000] public veSupply;\\n  /// @dev Ve supply checkpoint time cursor\\n  uint public timeCursor;\\n  /// @dev Token balance updated on checkpoint/claim\\n  uint public tokenLastBalance;\\n  /// @dev Last checkpoint time\\n  uint public lastTokenTime;\\n\\n  // --- CLAIM\\n\\n  /// @dev Timestamp when this contract was inited\\n  uint public startTime;\\n  /// @dev veID => week cursor stored on the claim action\\n  mapping(uint => uint) public timeCursorOf;\\n  /// @dev veID => epoch stored on the claim action\\n  mapping(uint => uint) public userEpochOf;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CheckpointToken(\\n    uint time,\\n    uint tokens\\n  );\\n\\n  event Claimed(\\n    uint tokenId,\\n    uint amount,\\n    uint claimEpoch,\\n    uint maxEpoch\\n  );\\n\\n  // *************************************************************\\n  //                        INIT\\n  // *************************************************************\\n\\n  /// @dev Proxy initialization. Call it after contract deploy.\\n  function init(\\n    address controller_,\\n    address _ve,\\n    address _rewardToken\\n  ) external initializer {\\n    __Controllable_init(controller_);\\n    _requireERC20(_rewardToken);\\n    _requireInterface(_ve, InterfaceIds.I_VE);\\n\\n    uint _t = block.timestamp / WEEK * WEEK;\\n    startTime = _t;\\n    lastTokenTime = _t;\\n    timeCursor = _t;\\n\\n    rewardToken = _rewardToken;\\n    ve = IVe(_ve);\\n\\n//    IERC20(_rewardToken).safeApprove(_ve, type(uint).max);\\n  }\\n\\n  // *************************************************************\\n  //                      CHECKPOINT\\n  // *************************************************************\\n\\n  function checkpoint() external override {\\n    uint _period = activePeriod;\\n    // only trigger if new week\\n    if (block.timestamp >= _period + 1 weeks) {\\n      // set new period rounded to weeks\\n      activePeriod = block.timestamp / 1 weeks * 1 weeks;\\n      // checkpoint token balance that was just minted in veDist\\n      _checkpointToken();\\n      // checkpoint supply\\n      _checkpointTotalSupply();\\n    }\\n  }\\n\\n  /// @dev Update tokensPerWeek value\\n  function _checkpointToken() internal {\\n    uint tokenBalance = IERC20(rewardToken).balanceOf(address(this));\\n    uint toDistribute = tokenBalance - tokenLastBalance;\\n    tokenLastBalance = tokenBalance;\\n\\n    uint t = lastTokenTime;\\n    uint sinceLast = block.timestamp - t;\\n    lastTokenTime = block.timestamp;\\n    uint thisWeek = t / WEEK * WEEK;\\n    uint nextWeek = 0;\\n\\n    // checkpoint should be called at least once per 20 weeks\\n    for (uint i = 0; i < 20; i++) {\\n      nextWeek = thisWeek + WEEK;\\n      if (block.timestamp < nextWeek) {\\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\\n        break;\\n      } else {\\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\\n      }\\n      t = nextWeek;\\n      thisWeek = nextWeek;\\n    }\\n    emit CheckpointToken(block.timestamp, toDistribute);\\n  }\\n\\n  /// @dev Adjust value based on time since last update\\n  function adjustToDistribute(\\n    uint toDistribute,\\n    uint t0,\\n    uint t1,\\n    uint sinceLast\\n  ) public pure returns (uint) {\\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\\n      return toDistribute;\\n    }\\n    return toDistribute * (t0 - t1) / sinceLast;\\n  }\\n\\n  /// @dev Search in the loop given timestamp through ve points history.\\n  ///      Return minimal possible epoch.\\n  function findTimestampEpoch(IVe _ve, uint _timestamp) public view returns (uint) {\\n    uint _min = 0;\\n    uint _max = _ve.epoch();\\n    for (uint i = 0; i < 128; i++) {\\n      if (_min >= _max) break;\\n      uint _mid = (_min + _max + 2) / 2;\\n      IVe.Point memory pt = _ve.pointHistory(_mid);\\n      if (pt.ts <= _timestamp) {\\n        _min = _mid;\\n      } else {\\n        _max = _mid - 1;\\n      }\\n    }\\n    return _min;\\n  }\\n\\n  /// @dev Search in the loop given timestamp through ve user points history.\\n  ///      Return minimal possible epoch.\\n  function findTimestampUserEpoch(\\n    IVe _ve,\\n    uint tokenId,\\n    uint _timestamp,\\n    uint maxUserEpoch\\n  ) public view returns (uint) {\\n    uint _min = 0;\\n    uint _max = maxUserEpoch;\\n    for (uint i = 0; i < 128; i++) {\\n      if (_min >= _max) break;\\n      uint _mid = (_min + _max + 2) / 2;\\n      IVe.Point memory pt = _ve.userPointHistory(tokenId, _mid);\\n      if (pt.ts <= _timestamp) {\\n        _min = _mid;\\n      } else {\\n        _max = _mid - 1;\\n      }\\n    }\\n    return _min;\\n  }\\n\\n  /// @dev Return ve power at given timestamp\\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\\n    IVe _ve = ve;\\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\\n    uint epoch = findTimestampUserEpoch(_ve, _tokenId, _timestamp, maxUserEpoch);\\n    IVe.Point memory pt = _ve.userPointHistory(_tokenId, epoch);\\n    return uint(int256(_positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\\n  }\\n\\n  /// @dev Call ve checkpoint and write veSupply at the current timeCursor\\n  function checkpointTotalSupply() external override {\\n    _checkpointTotalSupply();\\n  }\\n\\n  function _checkpointTotalSupply() internal {\\n    IVe _ve = ve;\\n    uint t = timeCursor;\\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\\n    _ve.checkpoint();\\n\\n    // assume will be called more frequently than 20 weeks\\n    for (uint i = 0; i < 20; i++) {\\n      if (t > roundedTimestamp) {\\n        break;\\n      } else {\\n        uint epoch = findTimestampEpoch(_ve, t);\\n        IVe.Point memory pt = _ve.pointHistory(epoch);\\n        veSupply[t] = adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\\n      }\\n      t += WEEK;\\n    }\\n    timeCursor = t;\\n  }\\n\\n  /// @dev Calculate ve supply based on bias and slop for the given timestamp\\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) public pure returns (uint) {\\n    if (t < ptTs) {\\n      return 0;\\n    }\\n    int128 dt = int128(int256(t - ptTs));\\n    if (ptBias < ptSlope * dt) {\\n      return 0;\\n    }\\n    return uint(int256(_positiveInt128(ptBias - ptSlope * dt)));\\n  }\\n\\n  // *************************************************************\\n  //                      CLAIM\\n  // *************************************************************\\n\\n  /// @dev Return available to claim earned amount\\n  function claimable(uint _tokenId) external view returns (uint) {\\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\\n    return result.toDistribute;\\n  }\\n\\n  /// @dev Claim rewards for given veID\\n  function claim(uint _tokenId) external override returns (uint) {\\n    IVe _ve = ve;\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\n    uint _lastTokenTime = lastTokenTime;\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\n    uint amount = _claim(_tokenId, _ve, _lastTokenTime);\\n    if (amount != 0) {\\n      IERC20(rewardToken).safeTransfer(IERC721(address(_ve)).ownerOf(_tokenId), amount);\\n//      _ve.increaseAmount(rewardToken, _tokenId, amount);\\n      tokenLastBalance -= amount;\\n    }\\n    return amount;\\n  }\\n\\n  /// @dev Claim rewards for given veIDs\\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\n    uint _lastTokenTime = lastTokenTime;\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\n    IVe _votingEscrow = ve;\\n    uint total = 0;\\n\\n    for (uint i = 0; i < _tokenIds.length; i++) {\\n      uint _tokenId = _tokenIds[i];\\n      if (_tokenId == 0) break;\\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\\n      if (amount != 0) {\\n        IERC20(rewardToken).safeTransfer(IERC721(address(_votingEscrow)).ownerOf(_tokenId), amount);\\n//        _votingEscrow.increaseAmount(rewardToken, _tokenId, amount);\\n        total += amount;\\n      }\\n    }\\n    if (total != 0) {\\n      tokenLastBalance -= total;\\n    }\\n\\n    return true;\\n  }\\n\\n  function _claim(uint _tokenId, IVe _ve, uint _lastTokenTime) internal returns (uint) {\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, _ve, _lastTokenTime);\\n    if (result.success) {\\n      userEpochOf[_tokenId] = result.userEpoch;\\n      timeCursorOf[_tokenId] = result.weekCursor;\\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\\n    }\\n    return result.toDistribute;\\n  }\\n\\n  function _calculateClaim(\\n    uint _tokenId,\\n    IVe _ve,\\n    uint _lastTokenTime\\n  ) internal view returns (ClaimCalculationResult memory) {\\n    uint userEpoch;\\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\\n    uint _startTime = startTime;\\n\\n    if (maxUserEpoch == 0) {\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\n    }\\n\\n    uint weekCursor = timeCursorOf[_tokenId];\\n\\n    if (weekCursor == 0) {\\n      userEpoch = findTimestampUserEpoch(_ve, _tokenId, _startTime, maxUserEpoch);\\n    } else {\\n      userEpoch = userEpochOf[_tokenId];\\n    }\\n\\n    if (userEpoch == 0) userEpoch = 1;\\n\\n    IVe.Point memory userPoint = _ve.userPointHistory(_tokenId, userEpoch);\\n    if (weekCursor == 0) {\\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\\n    }\\n    if (weekCursor >= lastTokenTime) {\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\n    }\\n    if (weekCursor < _startTime) {\\n      weekCursor = _startTime;\\n    }\\n\\n    return calculateToDistribute(\\n      _tokenId,\\n      weekCursor,\\n      _lastTokenTime,\\n      userPoint,\\n      userEpoch,\\n      maxUserEpoch,\\n      _ve\\n    );\\n  }\\n\\n  function calculateToDistribute(\\n    uint _tokenId,\\n    uint weekCursor,\\n    uint _lastTokenTime,\\n    IVe.Point memory userPoint,\\n    uint userEpoch,\\n    uint maxUserEpoch,\\n    IVe _ve\\n  ) public view returns (ClaimCalculationResult memory) {\\n    IVe.Point memory oldUserPoint;\\n    uint toDistribute;\\n    for (uint i = 0; i < 50; i++) {\\n      if (weekCursor >= _lastTokenTime) {\\n        break;\\n      }\\n      if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\\n        userEpoch += 1;\\n        oldUserPoint = userPoint;\\n        if (userEpoch > maxUserEpoch) {\\n          userPoint = IVe.Point(0, 0, 0, 0);\\n        } else {\\n          userPoint = _ve.userPointHistory(_tokenId, userEpoch);\\n        }\\n      } else {\\n        int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\\n        uint balanceOf = uint(int256(_positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\\n        if (balanceOf == 0 && userEpoch > maxUserEpoch) {\\n          break;\\n        }\\n        toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\\n        weekCursor += WEEK;\\n      }\\n    }\\n    return ClaimCalculationResult(\\n      toDistribute,\\n      Math.min(maxUserEpoch, userEpoch - 1),\\n      weekCursor,\\n      maxUserEpoch,\\n      true\\n    );\\n  }\\n\\n  function _positiveInt128(int128 value) internal pure returns (int128) {\\n    return value < 0 ? int128(0) : value;\\n  }\\n\\n  /// @dev Block timestamp rounded to weeks\\n  function timestamp() external view returns (uint) {\\n    return block.timestamp / WEEK * WEEK;\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_VE_DISTRIBUTOR || super.supportsInterface(interfaceId);\\n  }\\n\\n}\\n\",\"keccak256\":\"0xfafd568409544a71f4deb0f3b8c0b64cb3bd155b1bd27108d3f08c78ba3185bd\",\"license\":\"MIT\"},\"contracts/dependencies/Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./BaseMath.sol\\\";\\nimport \\\"./LiquityMath.sol\\\";\\nimport \\\"../interfaces/IActivePool.sol\\\";\\nimport \\\"../interfaces/IDefaultPool.sol\\\";\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"../interfaces/IBase.sol\\\";\\n\\n/* \\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\\n* common functions. \\n*/\\ncontract Base is BaseMath, IBase {\\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\\n\\n    // Minimum collateral ratio for individual troves\\n    uint constant public MCR = 1100000000000000000; // 110%\\n\\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\n    uint constant public CCR = 1500000000000000000; // 150%\\n\\n    // Amount of SIM to be locked in gas pool on opening troves\\n//    uint constant public SIM_GAS_COMPENSATION = 200e18;\\n\\n    // Minimum amount of net SIM debt a trove must have\\n    uint constant public MIN_NET_DEBT = 1e18; //1800e18;\\n    // uint constant public MIN_NET_DEBT = 0;\\n\\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\n\\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\\n\\n    IActivePool public activePool;\\n\\n    IDefaultPool public defaultPool;\\n\\n    IPriceFeed public override priceFeed;\\n\\n    // --- Gas compensation functions ---\\n\\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\\n        return _debt/* + SIM_GAS_COMPENSATION*/;\\n    }\\n\\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\\n        return _debt/* + SIM_GAS_COMPENSATION*/;\\n    }\\n\\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\\n        return _entireColl / PERCENT_DIVISOR;\\n    }\\n\\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\\n        uint activeColl = activePool.getWSTETH();\\n        uint liquidatedColl = defaultPool.getWSTETH();\\n\\n        return activeColl + liquidatedColl;\\n    }\\n\\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\\n        uint activeDebt = activePool.getSIMDebt();\\n        uint closedDebt = defaultPool.getSIMDebt();\\n\\n        return activeDebt + closedDebt;\\n    }\\n\\n    function _getTCR(uint _price) internal view returns (uint TCR) {\\n        uint entireSystemColl = getEntireSystemColl();\\n        uint entireSystemDebt = getEntireSystemDebt();\\n\\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\\n\\n        return TCR;\\n    }\\n\\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\\n        uint TCR = _getTCR(_price);\\n\\n        return TCR < CCR;\\n    }\\n\\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\\n        uint feePercentage = _fee * DECIMAL_PRECISION / _amount;\\n        require(feePercentage <= _maxFeePercentage, \\\"Fee exceeded provided maximum\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xd7cf2fa10d9ddc2236b243d16b8ae22c9c8ec15aee73e4c9b4d3d4054c9ed604\",\"license\":\"MIT\"},\"contracts/dependencies/BaseMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n\\ncontract BaseMath {\\n    uint constant public DECIMAL_PRECISION = 1e18;\\n}\\n\",\"keccak256\":\"0xfbd2340d208377996fc6305a28a939c849d7337e8fa1789e3130b73106de1d9f\",\"license\":\"MIT\"},\"contracts/dependencies/CheckContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ncontract CheckContract {\\n    /**\\n     * Check that the account is an already deployed non-destroyed contract.\\n     */\\n    function _checkContract(address account_) internal view {\\n        require(account_ != address(0), \\\"Account cannot be zero address\\\");\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account_) }\\n        require(size > 0, \\\"Account code size cannot be zero\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x6282e853a7b31ee8bbbb4008869300bf900f7f43610f5b4be9499d40549b207a\",\"license\":\"MIT\"},\"contracts/dependencies/ControllableV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./TetuERC165.sol\\\";\\nimport \\\"./InterfaceIds.sol\\\";\\nimport \\\"./SlotsLib.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"3.0.1\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  /// @dev Prevent implementation init\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\\n    require(IController(controller_).governance() != address(0), \\\"Zero governance\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address _value) public override view returns (bool) {\\n    return _value == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address _value) public override view returns (bool) {\\n    return IController(controller()).governance() == _value;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view returns (uint){\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view returns (address){\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n  /// @dev Gets a slot as bytes32\\n  function getSlot(uint slot) external view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe4cb568bfe305f68f3db6a20a5bb84e72266aecc349a97913503133c7f5b435a\",\"license\":\"MIT\"},\"contracts/dependencies/InterfaceIds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Library for interface IDs\\n/// @author bogdoslav\\nlibrary InterfaceIds {\\n\\n    /// @notice Version of the contract\\n    /// @dev Should be incremented when contract changed\\n    string public constant INTERFACE_IDS_LIB_VERSION = \\\"1.0.0\\\";\\n\\n    /// default notation:\\n    /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\\n\\n    /// As type({Interface}).interfaceId can be changed,\\n    /// when some functions changed at the interface,\\n    /// so used hardcoded interface identifiers\\n\\n    bytes4 public constant I_VE = bytes4(keccak256(\\\"IVe\\\"));\\n    bytes4 public constant I_CONTROLLER = bytes4(keccak256(\\\"IController\\\"));\\n    bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\\\"ITetuERC165\\\"));\\n    bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\\\"IControllable\\\"));\\n    bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\\\"IVeDistributor\\\"));\\n}\\n\",\"keccak256\":\"0xd7f6aa4d6e73708fee00f96f0d4b3276ca1b164d3c12ede567c0736443115df2\",\"license\":\"MIT\"},\"contracts/dependencies/LiquityMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary LiquityMath {\\n    uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \\u201ctoo high\\u201d could lead to overflows.\\n     * - Making it \\u201ctoo low\\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division. \\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /* \\n    * Multiply two decimal numbers and use normal rounding rules:\\n    * -round product up if 19'th mantissa digit >= 5\\n    * -round product down if 19'th mantissa digit < 5\\n    *\\n    * Used only inside the exponentiation, _decPow().\\n    */\\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n        uint prod_xy = x * y;\\n\\n        decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\\n    }\\n\\n    /* \\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n    * \\n    * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity. \\n    * \\n    * Called by two functions that represent time in units of minutes:\\n    * 1) TroveManager._calcDecayedBaseRate\\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \\n    * \\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n    * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n    * \\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n    * negligibly different from just passing the cap, since: \\n    *\\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n    */\\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n        // cap to avoid overflow\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        }\\n    \\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\\n\\n        uint y = DECIMAL_PRECISION;\\n        uint x = _base;\\n        uint n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n / 2;\\n            } else { // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n - 1) / 2;\\n            }\\n        }\\n\\n        return decMul(x, y);\\n  }\\n\\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a - _b : _b - _a;\\n    }\\n\\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            return _coll * NICR_PRECISION / _debt;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else { // if (_debt == 0)\\n            return 2**256 - 1;\\n        }\\n    }\\n\\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            uint newCollRatio = _coll * _price / _debt;\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else { // if (_debt == 0)\\n            return 2**256 - 1; \\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb9ed155e8331948da867a6e089052dff0a667e25119ff602c6b88099f53b0ba\",\"license\":\"MIT\"},\"contracts/dependencies/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  // ************* ARRAY SETTERS *******************\\n\\n  /// @dev Sets a slot array at index with address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, address value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot array at index with uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, uint value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets an array length\\n  function setLength(bytes32 slot, uint length) internal {\\n    assembly {\\n      sstore(slot, length)\\n    }\\n  }\\n\\n  /// @dev Pushes an address to the array\\n  function push(bytes32 slot, address value) internal {\\n    uint length = arrayLength(slot);\\n    setAt(slot, length, value);\\n    setLength(slot, length + 1);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x87400ece5c41c4e0106a48d66a063e8fe335dfb59ad108d7ccd71e0deb6889e6\",\"license\":\"MIT\"},\"contracts/dependencies/TetuERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./InterfaceIds.sol\\\";\\n\\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\\n/// @author bogdoslav\\nabstract contract TetuERC165 is ERC165 {\\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\\\"ITetuERC165\\\"));\\n\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\\n  }\\n\\n  // *************************************************************\\n  //                        HELPER FUNCTIONS\\n  // *************************************************************\\n  /// @author bogdoslav\\n\\n  /// @dev Checks what interface with id is supported by contract.\\n  /// @return bool. Do not throws\\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\\n      return isSupported;\\n    } catch {\\n    }\\n    return false;\\n  }\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\\n    require(_isInterfaceSupported(contractAddress, interfaceId), \\\"Interface is not supported\\\");\\n  }\\n\\n  /// @dev Checks what address is ERC20.\\n  /// @return bool. Do not throws\\n  function _isERC20(address contractAddress) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    bool totalSupplySupported;\\n    try IERC20(contractAddress).totalSupply() returns (uint) {\\n      totalSupplySupported = true;\\n    } catch {\\n    }\\n\\n    bool balanceSupported;\\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\\n      balanceSupported = true;\\n    } catch {\\n    }\\n\\n    return totalSupplySupported && balanceSupported;\\n  }\\n\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireERC20(address contractAddress) internal view {\\n    require(_isERC20(contractAddress), \\\"Not ERC20\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xf972813f3a255c8ab5afd2184a3cc5c68688de7836af374c74218b454233d325\",\"license\":\"MIT\"},\"contracts/interfaces/IActivePool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IPool.sol\\\";\\n\\n\\ninterface IActivePool is IPool {\\n    // --- Events ---\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolSIMDebtUpdated(uint _SIMDebt);\\n    event ActivePoolWSTETHBalanceUpdated(uint _WSTETH);\\n\\n    // --- Functions ---\\n    function sendWSTETH(address _account, uint _amount) external;\\n    function receiveWSTETH(uint amount) external;\\n}\\n\",\"keccak256\":\"0x43e7e6c53312584b369d356a350f2027530ad8c123cee37657b6f3d21cfcdfca\",\"license\":\"MIT\"},\"contracts/interfaces/IBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IPriceFeed.sol\\\";\\n\\n\\ninterface IBase {\\n    function priceFeed() external view returns (IPriceFeed);\\n}\\n\",\"keccak256\":\"0x861429b40d61dfeedf3166fd9fabe1f2864a6e335784228ad83041f9c889d7fd\",\"license\":\"MIT\"},\"contracts/interfaces/IBorrowerOperations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n// Common interface for the Trove Manager.\\ninterface IBorrowerOperations {\\n\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event SIMTokenAddressChanged(address _simTokenAddress);\\n    event SimVeDistributorAddressChanged(address _VeAddress);\\n\\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\\n    event SIMBorrowingFeePaid(address indexed _borrower, uint _SIMFee);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _sortedTrovesAddress,\\n        address _simTokenAddress,\\n        address _shadyStakingAddress,\\n        address _feeReceiver\\n    ) external;\\n\\n    function openTrove(uint amount, uint _maxFee, uint _SIMAmount, address _upperHint, address _lowerHint) external payable;\\n\\n    function addColl(uint amount, address _upperHint, address _lowerHint) external;\\n\\n    function moveWSTETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\\n\\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\\n\\n    function withdrawSIM(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\\n\\n    function repaySIM(uint _amount, address _upperHint, address _lowerHint) external;\\n\\n    function closeTrove() external;\\n\\n    function adjustTrove(uint addColAmount, uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\\n\\n    function claimCollateral() external;\\n\\n//    function getCompositeDebt(uint _debt) external pure returns (uint);\\n}\\n\",\"keccak256\":\"0x1220371f708d0426c2deeab7ffcee6fff03f951a38b6a1f0f183921e9d76932c\",\"license\":\"MIT\"},\"contracts/interfaces/ICollSurplusPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n\\ninterface ICollSurplusPool {\\n\\n    // --- Events ---\\n\\n    event WSTETHAddressChanged(address _newWSTETHAddress);\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n\\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    function setAddresses(\\n        address _WSTETHAddress,\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress\\n    ) external;\\n\\n    function getWSTETH() external view returns (uint);\\n\\n    function getCollateral(address _account) external view returns (uint);\\n\\n    function accountSurplus(address _account, uint _amount) external;\\n\\n    function claimColl(address _account) external;\\n\\n    function receiveWSTETH(uint amount) external;\\n}\\n\",\"keccak256\":\"0x8ec9e63e51efe61f20e4f3088f69dc2d16aece7bb651cd03be199cbcc50a49bf\",\"license\":\"MIT\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IControllable {\\n\\n  function isController(address _contract) external view returns (bool);\\n\\n  function isGovernance(address _contract) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x849ffde751c702df794cb2533a6401ae8b29c559fe23f9de76a64a60b66ab878\",\"license\":\"MIT\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IController {\\n\\n    // --- DEPENDENCY ADDRESSES\\n    function governance() external view returns (address);\\n\\n}\\n\",\"keccak256\":\"0x15d57764f807b9fa17edbd6f0a4c8d5a1f27c5eef80ed8a2b04e031f4abb1428\",\"license\":\"MIT\"},\"contracts/interfaces/IDefaultPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IPool.sol\\\";\\n\\n\\ninterface IDefaultPool is IPool {\\n    // --- Events ---\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event DefaultPoolSIMDebtUpdated(uint _SIMDebt);\\n    event DefaultPoolWSTETHBalanceUpdated(uint _WSTETH);\\n\\n    // --- Functions ---\\n    function sendWSTETHToActivePool(uint _amount) external;\\n    function receiveWSTETH(uint amount) external;\\n}\\n\",\"keccak256\":\"0x6f5fa0dbd6ea671d127969b2b0c8369f5a32e917dac9fa2eb67aa23313036e9f\",\"license\":\"MIT\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    \\n    // --- Events ---\\n    \\n    event WSTETHBalanceUpdated(uint _newBalance);\\n    event SIMBalanceUpdated(uint _newBalance);\\n    event WSTETHAddressChanged(address _newWSTETHAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n    \\n    function getWSTETH() external view returns (uint);\\n\\n    function getSIMDebt() external view returns (uint);\\n\\n    function increaseSIMDebt(uint _amount) external;\\n\\n    function decreaseSIMDebt(uint _amount) external;\\n}\\n\",\"keccak256\":\"0x75d5870d6307794574684881915ae899ba46f514e523f8672912ef908a1d1d85\",\"license\":\"MIT\"},\"contracts/interfaces/IPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPriceFeed {\\n\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n   \\n    // --- Function ---\\n    function fetchPrice() external returns (uint);\\n}\\n\",\"keccak256\":\"0xd48e100d585578b5eec065f625881aa4539745a125c8a7052481b75fbc934901\",\"license\":\"MIT\"},\"contracts/interfaces/ISHADYToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\n\\ninterface ISHADYToken is IERC20, IERC20Permit {\\n    // --- Events ---\\n\\n    event CommunityIssuanceAddressSet(address communityIssuanceAddress);\\n    event VeAddressSet(address veAddress);\\n    event LockupContractFactoryAddressSet(address lockupContractFactoryAddress);\\n\\n    // --- Functions ---\\n\\n    function getDeploymentStartTime() external view returns (uint);\\n}\\n\",\"keccak256\":\"0x0bbd59d283d2bb3fe7e414bf7b72803221212720bd012f56d585470781e3b662\",\"license\":\"MIT\"},\"contracts/interfaces/ISIMToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\n\\ninterface ISIMToken is IERC20, IERC20Permit {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address troveManagerAddress);\\n    event StabilityPoolAddressChanged(address newStabilityPoolAddress);\\n    event BorrowerOperationsAddressChanged(address newBorrowerOperationsAddress);\\n    event LUSDTokenBalanceUpdated(address user, uint amount);\\n\\n    // --- Functions ---\\n\\n    function mint(address account_, uint256 amount_) external;\\n\\n    function burn(address account_, uint256 amount_) external;\\n\\n    function sendToPool(address sender_, address poolAddress, uint256 amount_) external;\\n\\n    function returnFromPool(address poolAddress, address user, uint256 amount_) external;\\n}\\n\",\"keccak256\":\"0x295a4dba127380ef6b9ca9a3b9cbb762d10d6288a82e569bbdb562315f45656b\",\"license\":\"MIT\"},\"contracts/interfaces/ISortedTroves.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n\\n// Common interface for the SortedTroves Doubly Linked List.\\ninterface ISortedTroves {\\n\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event NodeAdded(address _id, uint _NICR);\\n    event NodeRemoved(address _id);\\n\\n    // --- Functions ---\\n    \\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\\n\\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\\n\\n    function remove(address _id) external;\\n\\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\\n\\n    function contains(address _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (address);\\n\\n    function getLast() external view returns (address);\\n\\n    function getNext(address _id) external view returns (address);\\n\\n    function getPrev(address _id) external view returns (address);\\n\\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\\n\\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\\n}\\n\",\"keccak256\":\"0x79acb39627952e016fbf3ecd352a88bc662817f62f76357b6c737ee316949302\",\"license\":\"MIT\"},\"contracts/interfaces/IStabilityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/*\\n * The Stability Pool holds SIM tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its SIM debt gets offset with\\n * SIM in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of SIM tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a SIM loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an WSTETH gain, as the WSTETH collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total SIM in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WSTETH gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n * --- SHADY ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An SHADY issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued SHADY in proportion to the deposit as a share of total deposits. The SHADY earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\\n */\\ninterface IStabilityPool {\\n\\n    // --- Events ---\\n    \\n    event StabilityPoolWSTETHBalanceUpdated(uint _newBalance);\\n    event StabilityPoolSIMBalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\\n\\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\\n\\n    event WSTETHGainWithdrawn(address indexed _depositor, uint _WSTETH, uint _SIMLoss);\\n    event SHADYPaidToDepositor(address indexed _depositor, uint _SHADY);\\n    event SHADYPaidToFrontEnd(address indexed _frontEnd, uint _SHADY);\\n    event WSTETHSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n\\n    /*\\n     * Called only once on init, to set addresses of other SIM contracts\\n     * Callable only by owner, renounces ownership at the end\\n     */\\n    function setAddresses(\\n        address _WSTETHAddress,\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _SIMTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend is registered or zero address\\n     * - Sender is not a registered frontend\\n     * - _amount is not zero\\n     * ---\\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (SHADY, WSTETH) to depositor\\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount, address _frontEndTag) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is zero or there are no under collateralized troves left in the system\\n     * - User has a non zero deposit\\n     * ---\\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (SHADY, WSTETH) to depositor\\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - User has a non zero deposit\\n     * - User has an open trove\\n     * - User has some WSTETH gain\\n     * ---\\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's SHADY gain to  depositor\\n     * - Sends all tagged front end's SHADY gain to the tagged front end\\n     * - Transfers the depositor's entire WSTETH gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake\\n     */\\n    function withdrawWSTETHGainToTrove(address _upperHint, address _lowerHint) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend (sender) not already registered\\n     * - User (sender) has no deposit\\n     * - _kickbackRate is in the range [0, 100%]\\n     * ---\\n     * Front end makes a one-time selection of kickback rate upon registering\\n     */\\n//    function registerFrontEnd(uint _kickbackRate) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Caller is TroveManager\\n     * ---\\n     * Cancels out the specified debt against the SIM contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's WSTETH collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debt, uint _coll) external;\\n\\n    /*\\n     * Returns the total amount of WSTETH held by the pool, accounted in an internal variable instead of `balance`,\\n     * to exclude edge cases like WSTETH received from a self-destruct.\\n     */\\n    function getWSTETH() external view returns (uint);\\n\\n    /*\\n     * Returns SIM held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n     */\\n    function getTotalSIMDeposits() external view returns (uint);\\n\\n    /*\\n     * Calculates the WSTETH gain earned by the deposit since its last snapshots were taken.\\n     */\\n    function getDepositorWSTETHGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Calculate the SHADY gain earned by a deposit since its last snapshots were taken.\\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\\n     * which they made their deposit.\\n     */\\n    function getDepositorSHADYGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the SHADY gain earned by the front end.\\n     */\\n//    function getFrontEndSHADYGain(address _frontEnd) external view returns (uint);\\n\\n    /*\\n     * Return the user's compounded deposit.\\n     */\\n    function getCompoundedSIMDeposit(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the front end's compounded stake.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n//    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\\n\\n    /*\\n     * Fallback function\\n     * Only callable by Active Pool, it just accounts for WSTETH received\\n     * receive() external payable;\\n     */\\n    function receiveWSTETH(uint amount) external;\\n}\\n\",\"keccak256\":\"0x0e50659b56f98d22a2f9b9e373f1c4bee798060f6ca989ecea823628d39d99fb\",\"license\":\"MIT\"},\"contracts/interfaces/ITroveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IBase.sol\\\";\\nimport \\\"./IStabilityPool.sol\\\";\\nimport \\\"./ISIMToken.sol\\\";\\nimport \\\"./ISHADYToken.sol\\\";\\nimport \\\"./IVe.sol\\\";\\n\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveManager is IBase {\\n    \\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n//    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event SHADYTokenAddressChanged(address _shadyTokenAddress);\\n    event WSTETHVeDistibutorAddressChanged(address _shadyStakingAddress);\\n\\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation/*, uint _SIMGasCompensation*/);\\n    event Redemption(uint _attemptedSIMAmount, uint _actualSIMAmount, uint _WSTETHSent, uint _WSTETHFee);\\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\\n    event BaseRateUpdated(uint _baseRate);\\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\\n    event TotalStakesUpdated(uint _newTotalStakes);\\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\\n    event LTermsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\\n    event TroveSnapshotsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n//        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _simTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _shadyTokenAddress,\\n        address _veAddress\\n    ) external;\\n\\n    function stabilityPool() external view returns (IStabilityPool);\\n    function simToken() external view returns (ISIMToken);\\n    function shadyToken() external view returns (ISHADYToken);\\n    function wstETHVeDistributor() external view returns (address);\\n\\n    function getTroveOwnersCount() external view returns (uint);\\n\\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\\n\\n    function getNominalICR(address _borrower) external view returns (uint);\\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\\n\\n    function liquidate(address _borrower) external;\\n\\n    function liquidateTroves(uint _n) external;\\n\\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\\n\\n    function redeemCollateral(\\n        uint _SIMAmount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFee\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\\n\\n    function updateTroveRewardSnapshots(address _borrower) external;\\n\\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\\n\\n    function applyPendingRewards(address _borrower) external;\\n\\n    function getPendingWSTETHReward(address _borrower) external view returns (uint);\\n\\n    function getPendingSIMDebtReward(address _borrower) external view returns (uint);\\n\\n     function hasPendingRewards(address _borrower) external view returns (bool);\\n\\n    function getEntireDebtAndColl(address _borrower) external view returns (\\n        uint debt,\\n        uint coll,\\n        uint pendingSIMDebtReward,\\n        uint pendingWSTETHReward\\n    );\\n\\n    function closeTrove(address _borrower) external;\\n\\n    function removeStake(address _borrower) external;\\n\\n    function getRedemptionRate() external view returns (uint);\\n    function getRedemptionRateWithDecay() external view returns (uint);\\n\\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view returns (uint);\\n\\n    function getBorrowingRate() external view returns (uint);\\n    function getBorrowingRateWithDecay() external view returns (uint);\\n\\n    function getBorrowingFee(uint SIMDebt) external view returns (uint);\\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view returns (uint);\\n\\n    function decayBaseRateFromBorrowing() external;\\n\\n    function getTroveStatus(address _borrower) external view returns (uint);\\n    \\n    function getTroveStake(address _borrower) external view returns (uint);\\n\\n    function getTroveDebt(address _borrower) external view returns (uint);\\n\\n    function getTroveColl(address _borrower) external view returns (uint);\\n\\n    function setTroveStatus(address _borrower, uint num) external;\\n\\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\\n\\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \\n\\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \\n\\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \\n\\n    function getTCR(uint _price) external view returns (uint);\\n\\n    function checkRecoveryMode(uint _price) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5437efa603b786cef94bc696b61ae9710570ea8feee29603f2e5efe83f9eab91\",\"license\":\"MIT\"},\"contracts/interfaces/IVe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IVe {\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME,\\n        MERGE_TYPE\\n    }\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint ts;\\n        uint blk; // block\\n    }\\n\\n//    function increaseF_WSTETH(uint _WSTETHFee) external;\\n\\n//    function increaseF_SIM(uint _SIMFee) external;\\n\\n    function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\\n\\n    function lockedDerivedAmount(uint veId) external view returns (uint);\\n\\n    function lockedEnd(uint veId) external view returns (uint);\\n\\n    function tokens(uint idx) external view returns (address);\\n\\n    function balanceOfNFT(uint) external view returns (uint);\\n\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n\\n    function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\\n\\n    function userPointEpoch(uint tokenId) external view returns (uint);\\n\\n    function epoch() external view returns (uint);\\n\\n    function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\\n\\n    function pointHistory(uint loc) external view returns (Point memory);\\n\\n    function checkpoint() external;\\n\\n    function increaseAmount(address _token, uint _tokenId, uint _value) external;\\n\\n    function totalSupplyAt(uint _block) external view returns (uint);\\n}\",\"keccak256\":\"0x925d70778879890862a50bff1f150b79ad160ab7fd5549addf748b978b5628d8\",\"license\":\"MIT\"},\"contracts/interfaces/IVeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IVeDistributor {\\n\\n  function rewardToken() external view returns (address);\\n\\n  function checkpoint() external;\\n\\n  function checkpointTotalSupply() external;\\n\\n  function claim(uint _tokenId) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0xc2b9b9f77d6419a78de1621eb1eb0bad42400ce04ce2de2e5fa842c976748472\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610c79380380610c7983398101604081905261002f91610078565b600080546001600160a01b039384166001600160a01b031991821617909155600180549290931691161790556100b2565b6001600160a01b038116811461007557600080fd5b50565b6000806040838503121561008b57600080fd5b825161009681610060565b60208401519092506100a781610060565b809150509250929050565b610bb8806100c16000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80633d83908a14610046578063ae9187541461006f578063b90bce4514610082575b600080fd5b600054610059906001600160a01b031681565b6040516100669190610947565b60405180910390f35b600154610059906001600160a01b031681565b61009561009036600461095b565b6100a2565b604051610066919061097d565b6060600080600085126100ba575083905060016100d5565b6100c5856001610a14565b6100ce90610a34565b9150600090505b6001546040805163de8fa43160e01b815290516000926001600160a01b03169163de8fa4319160048083019260209291908290030181865afa15801561011f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101439190610a50565b905080831061018557604080516000808252602082019092529061017d565b61016a610908565b8152602001906001900390816101625790505b5093506101c5565b60006101918483610a7f565b90508086111561019f578095505b82156101b6576101af84876101ce565b94506101c3565b6101c0848761056f565b94505b505b50505092915050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b0316631e2231436040518163ffffffff1660e01b8152600401602060405180830381865afa158015610225573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102499190610a98565b905060005b848110156102d95760015460405163765e015960e01b81526001600160a01b039091169063765e015990610286908590600401610947565b602060405180830381865afa1580156102a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c79190610a98565b91506102d281610ac8565b905061024e565b508267ffffffffffffffff8111156102f3576102f3610a69565b60405190808252806020026020018201604052801561032c57816020015b610319610908565b8152602001906001900390816103115790505b50915060005b83811015610567578183828151811061034d5761034d610ae1565b60209081029190910101516001600160a01b039182169052600054604051630ddec86760e31b8152911690636ef643389061038c908590600401610947565b60a060405180830381865afa1580156103a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cd9190610af7565b9050508584815181106103e2576103e2610ae1565b60200260200101516020018685815181106103ff576103ff610ae1565b602002602001015160400187868151811061041c5761041c610ae1565b60209081029190910101516060019290925291905252600054604051630b39e3cd60e11b81526001600160a01b0390911690631673c79a90610462908590600401610947565b6040805180830381865afa15801561047e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104a29190610b5e565b8483815181106104b4576104b4610ae1565b60200260200101516080018584815181106104d1576104d1610ae1565b602090810291909101015160a001919091525260015460405163765e015960e01b81526001600160a01b039091169063765e015990610514908590600401610947565b602060405180830381865afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190610a98565b915061056081610ac8565b9050610332565b505092915050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b0316634d6228316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190610a98565b905060005b8481101561067a57600154604051632dc9c0eb60e21b81526001600160a01b039091169063b72703ac90610627908590600401610947565b602060405180830381865afa158015610644573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106689190610a98565b915061067381610ac8565b90506105ef565b508267ffffffffffffffff81111561069457610694610a69565b6040519080825280602002602001820160405280156106cd57816020015b6106ba610908565b8152602001906001900390816106b25790505b50915060005b8381101561056757818382815181106106ee576106ee610ae1565b60209081029190910101516001600160a01b039182169052600054604051630ddec86760e31b8152911690636ef643389061072d908590600401610947565b60a060405180830381865afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190610af7565b90505085848151811061078357610783610ae1565b60200260200101516020018685815181106107a0576107a0610ae1565b60200260200101516040018786815181106107bd576107bd610ae1565b60209081029190910101516060019290925291905252600054604051630b39e3cd60e11b81526001600160a01b0390911690631673c79a90610803908590600401610947565b6040805180830381865afa15801561081f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108439190610b5e565b84838151811061085557610855610ae1565b602002602001015160800185848151811061087257610872610ae1565b602090810291909101015160a0019190915252600154604051632dc9c0eb60e21b81526001600160a01b039091169063b72703ac906108b5908590600401610947565b602060405180830381865afa1580156108d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f69190610a98565b915061090181610ac8565b90506106d3565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0391909116815260200190565b6000806040838503121561096e57600080fd5b50508035926020909101359150565b602080825282518282018190526000919060409081850190868401855b828110156109f157815180516001600160a01b0316855286810151878601528581015186860152606080820151908601526080808201519086015260a0908101519085015260c0909301929085019060010161099a565b5091979650505050505050565b634e487b7160e01b600052601160045260246000fd5b8082018281126000831280158216821582161715610567576105676109fe565b6000600160ff1b8201610a4957610a496109fe565b5060000390565b600060208284031215610a6257600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b81810381811115610a9257610a926109fe565b92915050565b600060208284031215610aaa57600080fd5b81516001600160a01b0381168114610ac157600080fd5b9392505050565b600060018201610ada57610ada6109fe565b5060010190565b634e487b7160e01b600052603260045260246000fd5b600080600080600060a08688031215610b0f57600080fd5b855194506020860151935060408601519250606086015160058110610b3357600080fd5b60808701519092506001600160801b0381168114610b5057600080fd5b809150509295509295909350565b60008060408385031215610b7157600080fd5b50508051602090910151909290915056fea264697066735822122033218b2134e7c4505f2f4a9a7dad57efc93a088cf30115c9a19745f28ec501cc64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80633d83908a14610046578063ae9187541461006f578063b90bce4514610082575b600080fd5b600054610059906001600160a01b031681565b6040516100669190610947565b60405180910390f35b600154610059906001600160a01b031681565b61009561009036600461095b565b6100a2565b604051610066919061097d565b6060600080600085126100ba575083905060016100d5565b6100c5856001610a14565b6100ce90610a34565b9150600090505b6001546040805163de8fa43160e01b815290516000926001600160a01b03169163de8fa4319160048083019260209291908290030181865afa15801561011f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101439190610a50565b905080831061018557604080516000808252602082019092529061017d565b61016a610908565b8152602001906001900390816101625790505b5093506101c5565b60006101918483610a7f565b90508086111561019f578095505b82156101b6576101af84876101ce565b94506101c3565b6101c0848761056f565b94505b505b50505092915050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b0316631e2231436040518163ffffffff1660e01b8152600401602060405180830381865afa158015610225573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102499190610a98565b905060005b848110156102d95760015460405163765e015960e01b81526001600160a01b039091169063765e015990610286908590600401610947565b602060405180830381865afa1580156102a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c79190610a98565b91506102d281610ac8565b905061024e565b508267ffffffffffffffff8111156102f3576102f3610a69565b60405190808252806020026020018201604052801561032c57816020015b610319610908565b8152602001906001900390816103115790505b50915060005b83811015610567578183828151811061034d5761034d610ae1565b60209081029190910101516001600160a01b039182169052600054604051630ddec86760e31b8152911690636ef643389061038c908590600401610947565b60a060405180830381865afa1580156103a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cd9190610af7565b9050508584815181106103e2576103e2610ae1565b60200260200101516020018685815181106103ff576103ff610ae1565b602002602001015160400187868151811061041c5761041c610ae1565b60209081029190910101516060019290925291905252600054604051630b39e3cd60e11b81526001600160a01b0390911690631673c79a90610462908590600401610947565b6040805180830381865afa15801561047e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104a29190610b5e565b8483815181106104b4576104b4610ae1565b60200260200101516080018584815181106104d1576104d1610ae1565b602090810291909101015160a001919091525260015460405163765e015960e01b81526001600160a01b039091169063765e015990610514908590600401610947565b602060405180830381865afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190610a98565b915061056081610ac8565b9050610332565b505092915050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b0316634d6228316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190610a98565b905060005b8481101561067a57600154604051632dc9c0eb60e21b81526001600160a01b039091169063b72703ac90610627908590600401610947565b602060405180830381865afa158015610644573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106689190610a98565b915061067381610ac8565b90506105ef565b508267ffffffffffffffff81111561069457610694610a69565b6040519080825280602002602001820160405280156106cd57816020015b6106ba610908565b8152602001906001900390816106b25790505b50915060005b8381101561056757818382815181106106ee576106ee610ae1565b60209081029190910101516001600160a01b039182169052600054604051630ddec86760e31b8152911690636ef643389061072d908590600401610947565b60a060405180830381865afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190610af7565b90505085848151811061078357610783610ae1565b60200260200101516020018685815181106107a0576107a0610ae1565b60200260200101516040018786815181106107bd576107bd610ae1565b60209081029190910101516060019290925291905252600054604051630b39e3cd60e11b81526001600160a01b0390911690631673c79a90610803908590600401610947565b6040805180830381865afa15801561081f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108439190610b5e565b84838151811061085557610855610ae1565b602002602001015160800185848151811061087257610872610ae1565b602090810291909101015160a0019190915252600154604051632dc9c0eb60e21b81526001600160a01b039091169063b72703ac906108b5908590600401610947565b602060405180830381865afa1580156108d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f69190610a98565b915061090181610ac8565b90506106d3565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0391909116815260200190565b6000806040838503121561096e57600080fd5b50508035926020909101359150565b602080825282518282018190526000919060409081850190868401855b828110156109f157815180516001600160a01b0316855286810151878601528581015186860152606080820151908601526080808201519086015260a0908101519085015260c0909301929085019060010161099a565b5091979650505050505050565b634e487b7160e01b600052601160045260246000fd5b8082018281126000831280158216821582161715610567576105676109fe565b6000600160ff1b8201610a4957610a496109fe565b5060000390565b600060208284031215610a6257600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b81810381811115610a9257610a926109fe565b92915050565b600060208284031215610aaa57600080fd5b81516001600160a01b0381168114610ac157600080fd5b9392505050565b600060018201610ada57610ada6109fe565b5060010190565b634e487b7160e01b600052603260045260246000fd5b600080600080600060a08688031215610b0f57600080fd5b855194506020860151935060408601519250606086015160058110610b3357600080fd5b60808701519092506001600160801b0381168114610b5057600080fd5b809150509295509295909350565b60008060408385031215610b7157600080fd5b50508051602090910151909290915056fea264697066735822122033218b2134e7c4505f2f4a9a7dad57efc93a088cf30115c9a19745f28ec501cc64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2645,
        "contract": "contracts/MultiTroveGetter.sol:MultiTroveGetter",
        "label": "troveManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(TroveManager)8674"
      },
      {
        "astId": 2648,
        "contract": "contracts/MultiTroveGetter.sol:MultiTroveGetter",
        "label": "sortedTroves",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ISortedTroves)16502"
      }
    ],
    "types": {
      "t_contract(ISortedTroves)16502": {
        "encoding": "inplace",
        "label": "contract ISortedTroves",
        "numberOfBytes": "20"
      },
      "t_contract(TroveManager)8674": {
        "encoding": "inplace",
        "label": "contract TroveManager",
        "numberOfBytes": "20"
      }
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/ISIMToken.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/IVeDistributor.sol\";\nimport \"./dependencies/Base.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/BorrowerOperations.sol\ncontract BorrowerOperations is Base, Ownable, CheckContract, IBorrowerOperations {\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    address public WSTETHAddress;\n\n    ITroveManager public troveManager;\n\n    address public stabilityPoolAddress;\n\n    ICollSurplusPool public collSurplusPool;\n\n    address public simVeDistributor;\n\n    ISIMToken public simToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    address public feeReceiver;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint SIMFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint SIMFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISIMToken simToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _WSTETHAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _simTokenAddress,\n        address _simVeDistributorAddress,\n        address _feeReceiver\n    )\n    external\n    override\n    onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn SIM\n        assert(MIN_NET_DEBT > 0);\n\n        _checkContract(_WSTETHAddress);\n        _checkContract(_troveManagerAddress);\n        _checkContract(_activePoolAddress);\n        _checkContract(_defaultPoolAddress);\n        _checkContract(_stabilityPoolAddress);\n        _checkContract(_collSurplusPoolAddress);\n        _checkContract(_priceFeedAddress);\n        _checkContract(_sortedTrovesAddress);\n        _checkContract(_simTokenAddress);\n        _checkContract(_simVeDistributorAddress);\n\n        WSTETHAddress = _WSTETHAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        simToken = ISIMToken(_simTokenAddress);\n        simVeDistributor = _simVeDistributorAddress;\n        feeReceiver = _feeReceiver;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit SIMTokenAddressChanged(_simTokenAddress);\n        emit SimVeDistributorAddressChanged(_simVeDistributorAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint amount, uint _maxFeePercentage, uint _SIMAmount, address _upperHint, address _lowerHint) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, simToken);\n        LocalVariables_openTrove memory vars;\n\n        require(IERC20(WSTETHAddress).transferFrom(msg.sender, address(this), amount));\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.SIMFee;\n        vars.netDebt = _SIMAmount;\n\n        if (!isRecoveryMode) {\n            vars.SIMFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.simToken, _SIMAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt + vars.SIMFee;\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested SIM amount + SIM borrowing fee + SIM gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n\n        vars.ICR = LiquityMath._computeCR(amount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(amount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(amount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, amount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the SIMAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, amount);\n        _withdrawSIM(contractsCache.activePool, contractsCache.simToken, msg.sender, _SIMAmount, vars.netDebt);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, amount, vars.stake, uint8(BorrowerOperation.openTrove));\n        emit SIMBorrowingFeePaid(msg.sender, vars.SIMFee);\n    }\n\n    // Send WSTETH as collateral to a trove\n    function addColl(uint amount, address _upperHint, address _lowerHint) external override {\n        require(IERC20(WSTETHAddress).transferFrom(msg.sender, address(this), amount));\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send WSTETH as collateral to a trove. Called by only the Stability Pool.\n    function moveWSTETHGainToTrove(address _borrower, address _upperHint, address _lowerHint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw WSTETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw SIM tokens from a trove: mint new SIM tokens to the owner, and increase the trove's debt accordingly\n    function withdrawSIM(uint _maxFeePercentage, uint _SIMAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _SIMAmount, true, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    // Repay SIM tokens to a Trove: Burn the repaid SIM tokens, and reduce the trove's debt accordingly\n    function repaySIM(uint _SIMAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _SIMAmount, false, _upperHint, _lowerHint, 0);\n    }\n\n    function adjustTrove(uint addColAmount, uint _maxFeePercentage, uint _collWithdrawal, uint _SIMChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external payable override {\n        if (addColAmount > 0) {\n            require(IERC20(WSTETHAddress).transferFrom(msg.sender, address(this), addColAmount));\n        }\n        _adjustTrove(msg.sender, _collWithdrawal, _SIMChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _SIMChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, simToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_SIMChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _SIMChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure WSTETH transfer from the Stability Pool to a trove\n        uint b = IERC20(WSTETHAddress).balanceOf(address(this));\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && b > 0 && _SIMChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not WSTETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(b, _collWithdrawal);\n\n        vars.netDebtChange = _SIMChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) {\n            vars.SIMFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.simToken, _SIMChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange + vars.SIMFee; // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough SIM\n        if (!_isDebtIncrease && _SIMChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);\n            _requireValidSIMRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientSIMBalance(contractsCache.simToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, uint8(BorrowerOperation.adjustTrove));\n        emit SIMBorrowingFeePaid(msg.sender,  vars.SIMFee);\n\n        // Use the unmodified _SIMChange here, as we don't send the fee to the user\n        _moveTokensAndWSTETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.simToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _SIMChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ISIMToken simTokenCached = simToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientSIMBalance(simTokenCached, msg.sender, debt/*.sub(SIM_GAS_COMPENSATION)*/);\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, uint8(BorrowerOperation.closeTrove));\n\n        // Burn the repaid SIM from the user's balance and the gas compensation from the Gas Pool\n        _repaySIM(activePoolCached, simTokenCached, msg.sender, debt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendWSTETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send WSTETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ISIMToken _simToken, uint _SIMAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint SIMFee = _troveManager.getBorrowingFee(_SIMAmount);\n\n        _requireUserAcceptsFee(SIMFee, _SIMAmount, _maxFeePercentage);\n\n        // Send half of fee to Ve contract\n        uint half = SIMFee / 2;\n        _simToken.mint(simVeDistributor, half);\n        IVeDistributor(simVeDistributor).checkpoint();\n\n        // Send half of fee to feeReceiver\n        _simToken.mint(feeReceiver, SIMFee - half);\n\n        return SIMFee;\n    }\n\n    /*function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price * _coll / DECIMAL_PRECISION;\n\n        return usdValue;\n    }*/\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n    internal\n    pure\n    returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n    internal\n    returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n            : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n            : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndWSTETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ISIMToken _simToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _SIMChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n    internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawSIM(_activePool, _simToken, _borrower, _SIMChange, _netDebtChange);\n        } else {\n            _repaySIM(_activePool, _simToken, _borrower, _SIMChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendWSTETH(_borrower, _collChange);\n        }\n    }\n\n    // Send WSTETH to Active Pool and increase its recorded WSTETH balance\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        require(IERC20(WSTETHAddress).transfer(address(_activePool), _amount));\n        _activePool.receiveWSTETH(_amount);\n    }\n\n    // Issue the specified amount of SIM to _account and increases the total active debt (_netDebtIncrease potentially includes a SIMFee)\n    function _withdrawSIM(IActivePool _activePool, ISIMToken _simToken, address _account, uint _SIMAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseSIMDebt(_netDebtIncrease);\n        _simToken.mint(_account, _SIMAmount);\n    }\n\n    // Burn the specified amount of SIM from _account and decreases the total active debt\n    function _repaySIM(IActivePool _activePool, ISIMToken _simToken, address _account, uint _SIM) internal {\n        _activePool.decreaseSIMDebt(_SIM);\n        _simToken.burn(_account, _SIM);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint _collWithdrawal) internal view {\n        require(IERC20(WSTETHAddress).balanceOf(address(this)) == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    /*function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }*/\n\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _SIMChange) internal view {\n        require(IERC20(WSTETHAddress).balanceOf(address(this)) != 0 || _collWithdrawal != 0 || _SIMChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _SIMChange) internal pure {\n        require(_SIMChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n\n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode\n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    )\n    internal\n    view\n    {\n        /*\n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidSIMRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt/*.sub(SIM_GAS_COMPENSATION)*/, \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n    function _requireSufficientSIMBalance(ISIMToken _simToken, address _borrower, uint _debtRepayment) internal view {\n        require(_simToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough SIM to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n    pure\n    internal\n    returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n    pure\n    internal\n    returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n    internal\n    pure\n    returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll + _collChange :  _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n    internal\n    view\n    returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n        totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    /*function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }*/\n}\n"
    },
    "contracts/CommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./dependencies/Issuance.sol\";\n\ncontract CommunityIssuance is Issuance {\n    string constant public NAME = \"CommunityIssuance\";\n}\n"
    },
    "contracts/dependencies/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./BaseMath.sol\";\nimport \"./LiquityMath.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IBase.sol\";\n\n/* \n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n* common functions. \n*/\ncontract Base is BaseMath, IBase {\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint constant public MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public CCR = 1500000000000000000; // 150%\n\n    // Amount of SIM to be locked in gas pool on opening troves\n//    uint constant public SIM_GAS_COMPENSATION = 200e18;\n\n    // Minimum amount of net SIM debt a trove must have\n    uint constant public MIN_NET_DEBT = 1e18; //1800e18;\n    // uint constant public MIN_NET_DEBT = 0;\n\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n\n    IActivePool public activePool;\n\n    IDefaultPool public defaultPool;\n\n    IPriceFeed public override priceFeed;\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\n        return _debt/* + SIM_GAS_COMPENSATION*/;\n    }\n\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\n        return _debt/* + SIM_GAS_COMPENSATION*/;\n    }\n\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\n        uint activeColl = activePool.getWSTETH();\n        uint liquidatedColl = defaultPool.getWSTETH();\n\n        return activeColl + liquidatedColl;\n    }\n\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getSIMDebt();\n        uint closedDebt = defaultPool.getSIMDebt();\n\n        return activeDebt + closedDebt;\n    }\n\n    function _getTCR(uint _price) internal view returns (uint TCR) {\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\n        uint TCR = _getTCR(_price);\n\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\n        uint feePercentage = _fee * DECIMAL_PRECISION / _amount;\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n    }\n}\n"
    },
    "contracts/dependencies/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n  bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /// @notice Encodes some bytes to the base64 representation\n  function encode(bytes memory data) internal pure returns (string memory) {\n    uint len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}\n"
    },
    "contracts/dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\ncontract BaseMath {\n    uint constant public DECIMAL_PRECISION = 1e18;\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     */\n    function _checkContract(address account_) internal view {\n        require(account_ != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account_) }\n        require(size > 0, \"Account code size cannot be zero\");\n    }\n}\n"
    },
    "contracts/dependencies/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./TetuERC165.sol\";\nimport \"./InterfaceIds.sol\";\nimport \"./SlotsLib.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.1\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n  /// @dev Gets a slot as bytes32\n  function getSlot(uint slot) external view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n}\n"
    },
    "contracts/dependencies/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n  /*//////////////////////////////////////////////////////////////\n  //SIMPLIFIED FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  uint internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n  function mulWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded down.\n  }\n\n  function mulWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded up.\n  }\n\n  function divWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded down.\n  }\n\n  function divWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded up.\n  }\n\n  function positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //LOW LEVEL FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  function mulDivDown(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // Divide z by the denominator.\n      z := div(z, denominator)\n    }\n  }\n\n  function mulDivUp(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // First, divide z - 1 by the denominator and add 1.\n    // We allow z - 1 to underflow if z is 0, because we multiply the\n    // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n    }\n  }\n\n  function rpow(\n    uint x,\n    uint n,\n    uint scalar\n  ) internal pure returns (uint z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n        // 0 ** 0 = 1\n          z := scalar\n        }\n        default {\n        // 0 ** n = 0\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n        // If n is even, store scalar in z for now.\n          z := scalar\n        }\n        default {\n        // If n is odd, store x in z for now.\n          z := x\n        }\n\n      // Shifting right by 1 is like dividing by 2.\n        let half := shr(1, scalar)\n\n        for {\n        // Shift n right by 1 before looping to halve it.\n          n := shr(1, n)\n        } n {\n        // Shift n right by 1 each iteration to halve it.\n          n := shr(1, n)\n        } {\n        // Revert immediately if x ** 2 would overflow.\n        // Equivalent to iszero(eq(div(xx, x), x)) here.\n          if shr(128, x) {\n            revert(0, 0)\n          }\n\n        // Store x squared.\n          let xx := mul(x, x)\n\n        // Round to the nearest number.\n          let xxRound := add(xx, half)\n\n        // Revert if xx + half overflowed.\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n\n        // Set x to scaled xxRound.\n          x := div(xxRound, scalar)\n\n        // If n is even:\n          if mod(n, 2) {\n          // Compute z * x.\n            let zx := mul(z, x)\n\n          // If z * x overflowed:\n            if iszero(eq(div(zx, x), z)) {\n            // Revert if x is non-zero.\n              if iszero(iszero(x)) {\n                revert(0, 0)\n              }\n            }\n\n          // Round to the nearest number.\n            let zxRound := add(zx, half)\n\n          // Revert if zx + half overflowed.\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n\n          // Return properly scaled zxRound.\n            z := div(zxRound, scalar)\n          }\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  // GENERAL NUMBER UTILITIES\n  //////////////////////////////////////////////////////////////*/\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n}\n"
    },
    "contracts/dependencies/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n    /// @notice Version of the contract\n    /// @dev Should be incremented when contract changed\n    string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n    /// default notation:\n    /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n    /// As type({Interface}).interfaceId can be changed,\n    /// when some functions changed at the interface,\n    /// so used hardcoded interface identifiers\n\n    bytes4 public constant I_VE = bytes4(keccak256(\"IVe\"));\n    bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n    bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n    bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n    bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n}\n"
    },
    "contracts/dependencies/Issuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ISHADYToken.sol\";\nimport \"../interfaces/IIssuance.sol\";\nimport \"./BaseMath.sol\";\nimport \"./LiquityMath.sol\";\nimport \"./CheckContract.sol\";\n\n\nabstract contract Issuance is IIssuance, Ownable, CheckContract, BaseMath {\n    // --- Data ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n\n   /* The issuance factor F determines the curvature of the issuance curve.\n    *\n    * Minutes in one year: 60*24*365 = 525600\n    *\n    * For 50% of remaining tokens issued each year, with minutes as time units, we have:\n    * \n    * F ** 525600 = 0.5\n    * \n    * Re-arranging:\n    * \n    * 525600 * ln(F) = ln(0.5)\n    * F = 0.5 ** (1/525600)\n    * F = 0.999998681227695000 \n    */\n    uint constant public ISSUANCE_FACTOR = 999998681227695000;\n\n    /* \n    * The community SHADY supply cap is the starting balance of the Community Issuance contract.\n    * It should be minted to this contract by SHADYToken, when the token is deployed.\n    * \n    * Set to 32M (slightly less than 1/3) of total SHADY supply.\n    */\n    uint constant public SHADYSupplyCap = 30e24; // 30 million\n\n    ISHADYToken public shadyToken;\n\n    address public issuerAddress;\n\n    uint public totalSHADYIssued;\n    uint public immutable deploymentTime;\n\n    // --- Functions ---\n\n    constructor() {\n        deploymentTime = block.timestamp;\n    }\n\n    function setAddresses(\n        address _shadyTokenAddress, \n        address _issuerAddress\n    ) external virtual onlyOwner override {\n        _checkContract(_shadyTokenAddress);\n//        _checkContract(_issuerAddress);\n\n        shadyToken = ISHADYToken(_shadyTokenAddress);\n        issuerAddress = _issuerAddress;\n\n        // When SHADYToken deployed, it should have transferred CommunityIssuance's SHADY entitlement\n        uint SHADYBalance = shadyToken.balanceOf(address(this));\n        assert(SHADYBalance >= SHADYSupplyCap);\n\n        emit SHADYTokenAddressSet(_shadyTokenAddress);\n        emit StabilityPoolAddressSet(_issuerAddress);\n\n        renounceOwnership();\n    }\n\n    function issueSHADY() external override returns (uint) {\n        _requireCallerIsIssuer();\n\n        uint latestTotalSHADYIssued = SHADYSupplyCap * _getCumulativeIssuanceFraction() / DECIMAL_PRECISION;\n        uint issuance = latestTotalSHADYIssued - totalSHADYIssued;\n\n        totalSHADYIssued = latestTotalSHADYIssued;\n        emit TotalSHADYIssuedUpdated(latestTotalSHADYIssued);\n        \n        return issuance;\n    }\n\n    /* Gets 1-f^t    where: f < 1\n\n    f: issuance factor that determines the shape of the curve\n    t:  time passed since last SHADY issuance event  */\n    function _getCumulativeIssuanceFraction() internal view returns (uint) {\n        // Get the time passed since deployment\n        uint timePassedInMinutes = (block.timestamp - deploymentTime) / SECONDS_IN_ONE_MINUTE;\n\n        // f^t\n        uint power = LiquityMath._decPow(ISSUANCE_FACTOR, timePassedInMinutes);\n\n        //  (1 - f^t)\n        uint cumulativeIssuanceFraction = (uint(DECIMAL_PRECISION) - power);\n        assert(cumulativeIssuanceFraction <= DECIMAL_PRECISION); // must be in range [0,1]\n\n        return cumulativeIssuanceFraction;\n    }\n\n    function sendSHADY(address _account, uint _SHADYamount) external override {\n        _requireCallerIsIssuer();\n        require(SHADYSupplyCap - totalSHADYIssued + _SHADYamount <= shadyToken.balanceOf(address(this)), \"Issuance: not enough issued SHADY\");\n        shadyToken.transfer(_account, _SHADYamount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsIssuer() internal view {\n        require(msg.sender == issuerAddress, \"CommunityIssuance: caller is not issuer\");\n    }\n}\n"
    },
    "contracts/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary LiquityMath {\n    uint internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it too high could lead to overflows.\n     * - Making it too low could lead to an ICR equal to zero, due to truncation from Solidity floor division. \n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /* \n    * Multiply two decimal numbers and use normal rounding rules:\n    * -round product up if 19'th mantissa digit >= 5\n    * -round product down if 19'th mantissa digit < 5\n    *\n    * Used only inside the exponentiation, _decPow().\n    */\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\n        uint prod_xy = x * y;\n\n        decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\n    }\n\n    /* \n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n    * \n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \n    * \n    * Called by two functions that represent time in units of minutes:\n    * 1) TroveManager._calcDecayedBaseRate\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \n    * \n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n    * \n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n    * negligibly different from just passing the cap, since: \n    *\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n    */\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n        // cap to avoid overflow\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        }\n    \n        if (_minutes == 0) {return DECIMAL_PRECISION;}\n\n        uint y = DECIMAL_PRECISION;\n        uint x = _base;\n        uint n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else { // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n  }\n\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\n        if (_debt > 0) {\n            return _coll * NICR_PRECISION / _debt;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else { // if (_debt == 0)\n            return 2**256 - 1;\n        }\n    }\n\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll * _price / _debt;\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else { // if (_debt == 0)\n            return 2**256 - 1; \n        }\n    }\n}\n"
    },
    "contracts/dependencies/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "contracts/dependencies/StringLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n}\n"
    },
    "contracts/dependencies/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "contracts/dependencies/VeLogo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \".//Base64.sol\";\nimport \"./StringLib.sol\";\n\n/// @title Library for storing SVG image of veNFT.\n/// @author belbix\nlibrary VeLogo {\n\n  /// @dev Return SVG logo of xSHADY\n  function tokenURI(uint _tokenId, uint _balanceOf, uint untilEnd, uint _value) public pure returns (string memory output) {\n    output = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 900\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style>.base{font-size:40px;}</style><rect fill=\"#44a465\" width=\"600\" height=\"900\"/><path fill=\"#1B4229\" d=\"M0,900h600V522.2C454.4,517.2,107.4,456.8,60.2,0H0V900z\"/><circle fill=\"#69db7c\" cx=\"385\" cy=\"212\" r=\"120\"/><symbol id=\"image-241a2825d965ea677b3dc22aaea9375b2aeb6193\"><image width=\"100%\" height=\"100%\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAMPmlDQ1BJQ0MgUHJvZmlsZQAASImVVwdYU8kWnluSkEBooUsJvQkiNYCUEFoA6V1UQhIglBgDQcVeFhVcu1jAhq6KKFhpFhRRLCyKvS8WVJR1sWBX3qSArvvK9ybf3Pnzz5n/nDkztwwAaic4IlEeqg5AvrBQHBsSQE9OSaWTngIi0IE/XeDM4RaImNHREQCWofbv5d11gEjbKw5SrX/2/9eiweMXcAFAoiHO4BVw8yE+BABeyRWJCwEgSnnzKYUiKYYVaIlhgBAvkuIsOa6U4gw53ieziY9lQdwGgJIKhyPOAkD1EuTpRdwsqKHaD7GTkCcQAqBGh9g3P38SD+J0iG2gjQhiqT4j4wedrL9pZgxrcjhZw1g+F1lRChQUiPI40/7PdPzvkp8nGfJhBatKtjg0VjpnmLebuZPCpVgF4j5hRmQUxJoQfxDwZPYQo5RsSWiC3B415BawYM7gOgPUiccJDIfYEOJgYV5khILPyBQEsyGGOwSdKihkx0OsB/EifkFQnMJmi3hSrMIXWp8pZjEV/FmOWOZX6uu+JDeBqdB/nc1nK/Qx1eLs+CSIKRBbFAkSIyFWhdixIDcuXGEzpjibFTlkI5bESuO3gDiWLwwJkOtjRZni4FiFfWl+wdB8sS3ZAnakAh8ozI4PlecHa+NyZPHDuWCX+EJmwpAOvyA5YmguPH5gkHzu2DO+MCFOofNBVBgQKx+LU0R50Qp73IyfFyLlzSB2LSiKU4zFEwvhhpTr45miwuh4eZx4cQ4nLFoeD74cRAAWCAR0IIE1A0wCOUDQ2dfQB//Je4IBB4hBFuADBwUzNCJJ1iOE1zhQDP6EiA8KhscFyHr5oAjyX4dZ+dUBZMp6i2QjcsETiPNBOMiD/yWyUcJhb4ngMWQE//DOgZUL482DVdr/7/kh9jvDhEyEgpEMeaSrDVkSg4iBxFBiMNEWN8B9cW88Al79YXXGGbjn0Dy+2xOeELoIDwnXCN2EWxMF88Q/RTkWdEP9YEUuMn7MBW4FNd3wANwHqkNlXAc3AA64K/TDxP2gZzfIshRxS7NC/0n7bzP4YTUUdmQnMkrWJfuTbX4eqWqn6jasIs31j/mRx5oxnG/WcM/P/lk/ZJ8H2/CfLbFF2EGsHTuJncOOYg2AjrVgjVgHdkyKh3fXY9nuGvIWK4snF+oI/uFvaGWlmSxwqnHqdfoi7yvkT5U+owFrkmiaWJCVXUhnwjcCn84Wch1H0p2dnF0AkL5f5I+vNzGy9wai0/Gdm/8HAD4tg4ODR75zYS0A7PeAt3/Td86GAV8dygCcbeJKxEVyDpdeCPApoQbvNH1gDMyBDZyPM3AH3sAfBIEwEAXiQQqYAKPPhvtcDKaAGWAuKAFlYDlYAzaAzWAb2AX2ggOgARwFJ8EZcAFcAtfAHbh7esAL0A/egc8IgpAQKkJD9BETxBKxR5wRBuKLBCERSCySgqQjWYgQkSAzkPlIGbIS2YBsRaqR/UgTchI5h3Qht5AHSC/yGvmEYqgKqoUaoVboKJSBMtFwNB4dj2ahk9FidAG6FF2HVqF70Hr0JHoBvYZ2oy/QAQxgypgOZoo5YAyMhUVhqVgmJsZmYaVYOVaF1WLNcJ2vYN1YH/YRJ+I0nI47wB0ciifgXHwyPgtfgm/Ad+H1eBt+BX+A9+PfCFSCIcGe4EVgE5IJWYQphBJCOWEH4TDhNLyXegjviESiDtGa6AHvxRRiDnE6cQlxI7GOeILYRXxEHCCRSPoke5IPKYrEIRWSSkjrSXtILaTLpB7SByVlJRMlZ6VgpVQlodI8pXKl3UrHlS4rPVX6TFYnW5K9yFFkHnkaeRl5O7mZfJHcQ/5M0aBYU3wo8ZQcylzKOkot5TTlLuWNsrKymbKncoyyQHmO8jrlfcpnlR8of1TRVLFTYamkqUhUlqrsVDmhckvlDZVKtaL6U1OphdSl1GrqKep96gdVmqqjKluVpzpbtUK1XvWy6ks1spqlGlNtglqxWrnaQbWLan3qZHUrdZY6R32WeoV6k/oN9QENmsZojSiNfI0lGrs1zmk80yRpWmkGafI0F2hu0zyl+YiG0cxpLBqXNp+2nXaa1qNF1LLWYmvlaJVp7dXq1OrX1tR21U7UnqpdoX1Mu1sH07HSYevk6SzTOaBzXeeTrpEuU5evu1i3Vvey7nu9EXr+eny9Ur06vWt6n/Tp+kH6ufor9Bv07xngBnYGMQZTDDYZnDboG6E1wnsEd0TpiAMjbhuihnaGsYbTDbcZdhgOGBkbhRiJjNYbnTLqM9Yx9jfOMV5tfNy414Rm4msiMFlt0mLynK5NZ9Lz6OvobfR+U0PTUFOJ6VbTTtPPZtZmCWbzzOrM7plTzBnmmearzVvN+y1MLMZazLCosbhtSbZkWGZbrrVst3xvZW2VZLXQqsHqmbWeNdu62LrG+q4N1cbPZrJNlc1VW6ItwzbXdqPtJTvUzs0u267C7qI9au9uL7DfaN81kjDSc6RwZNXIGw4qDkyHIocahweOOo4RjvMcGxxfjrIYlTpqxaj2Ud+c3JzynLY73RmtOTps9LzRzaNfO9s5c50rnK+6UF2CXWa7NLq8crV35btucr3pRnMb67bQrdXtq7uHu9i91r3Xw8Ij3aPS4wZDixHNWMI460nwDPCc7XnU86OXu1eh1wGvv7wdvHO9d3s/G2M9hj9m+5hHPmY+HJ+tPt2+dN903y2+3X6mfhy/Kr+H/ub+PP8d/k+Ztswc5h7mywCnAHHA4YD3LC/WTNaJQCwwJLA0sDNIMyghaEPQ/WCz4KzgmuD+ELeQ6SEnQgmh4aErQm+wjdhcdjW7P8wjbGZYW7hKeFz4hvCHEXYR4ojmsejYsLGrxt6NtIwURjZEgSh21Kqoe9HW0ZOjj8QQY6JjKmKexI6OnRHbHkeLmxi3O+5dfED8svg7CTYJkoTWRLXEtMTqxPdJgUkrk7qTRyXPTL6QYpAiSGlMJaUmpu5IHRgXNG7NuJ40t7SStOvjrcdPHX9ugsGEvAnHJqpN5Ew8mE5IT0rfnf6FE8Wp4gxksDMqM/q5LO5a7gueP281r5fvw1/Jf5rpk7ky81mWT9aqrN5sv+zy7D4BS7BB8ConNGdzzvvcqNyduYN5SXl1+Ur56flNQk1hrrBtkvGkqZO6RPaiElH3ZK/Jayb3i8PFOwqQgvEFjYVa8EO+Q2Ij+UXyoMi3qKLow5TEKQenakwVTu2YZjdt8bSnxcHFv03Hp3Ont84wnTF3xoOZzJlbZyGzMma1zjafvWB2z5yQObvmUubmzv19ntO8lfPezk+a37zAaMGcBY9+CfmlpkS1RFxyY6H3ws2L8EWCRZ2LXRavX/ytlFd6vsyprLzsyxLukvO/jv513a+DSzOXdi5zX7ZpOXG5cPn1FX4rdq3UWFm88tGqsavqV9NXl65+u2bimnPlruWb11LWStZ2r4tY17jeYv3y9V82ZG+4VhFQUVdpWLm48v1G3sbLm/w31W422ly2+dMWwZabW0O21ldZVZVvI24r2vZke+L29t8Yv1XvMNhRtuPrTuHO7l2xu9qqPaqrdxvuXlaD1khqevek7bm0N3BvY61D7dY6nbqyfWCfZN/z/en7rx8IP9B6kHGw9pDlocrDtMOl9Uj9tPr+huyG7saUxq6msKbWZu/mw0ccj+w8anq04pj2sWXHKccXHB9sKW4ZOCE60Xcy6+Sj1omtd04ln7raFtPWeTr89NkzwWdOtTPbW876nD16zutc03nG+YYL7hfqO9w6Dv/u9vvhTvfO+oseFxsveV5q7hrTdfyy3+WTVwKvnLnKvnrhWuS1rusJ12/eSLvRfZN389mtvFuvbhfd/nxnzl3C3dJ76vfK7xver/rD9o+6bvfuYw8CH3Q8jHt45xH30YvHBY+/9Cx4Qn1S/tTkafUz52dHe4N7Lz0f97znhejF576SPzX+rHxp8/LQX/5/dfQn9/e8Er8afL3kjf6bnW9d37YORA/cf5f/7vP70g/6H3Z9ZHxs/5T06ennKV9IX9Z9tf3a/C38293B/MFBEUfMkX0KYLCimZkAvN4JADUFABo8n1HGyc9/soLIz6wyBP4Tlp8RZcUdgFr4/R7TB79ubgCwbzs8fkF9tTQAoqkAxHsC1MVluA6d1WTnSmkhwnPAlrivGfkZ4N8U+Znzh7h/boFU1RX83P4L9rN8iIgyVPIAAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAKCgAwAEAAAAAQAAAKAAAAAAhCQ7swAABRtJREFUeAHt3T2LGFUUBuDVGIiJihoTxCKolYKFWEQbEexM55+ztrextAq2NmlNpywoRlgUYXWJiKawTIZ3yD3M/XhS7pycufc5L1PkZmZPTvwhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAYTeCZ0Rb8tOv98N2X/33aHj38/e++/32K2T3bA6Y1rCsggOvOvoudC2AXY1h3EQK47uy72LkAdjGGdRchgOvOvoudC2AXY1h3EQK47uy72LkAdjGGdRfx3CxbT084Pv/4ZrTlsz/+jurOL/6J6tKia1cupaXRic6rL16O+r31xvNR3RdfnzY9gfEEjNgVVQkIYJWsvpGAAEZMiqoEBLBKVt9IQAAjJkVVAgJYJatvJCCAEZOiKgEBrJLVNxIQwIhJUZVA03/Vrlpky77picmD3x62vG3c685Hr8W1SeGtm1eSspMvv/kpqrt/et40M56AEbuiKgEBrJLVNxIQwIhJUZWAAFbJ6hsJCGDEpKhKQACrZPWNBAQwYlJUJSCAVbL6RgICGDEpqhKY5p2QFKj3r0r98PNf0bse7739QrTl018vorqLh9Fto157ijwB92ipbS4ggM1JNdwjIIB7tNQ2FxDA5qQa7hEQwD1aapsLCGBzUg33CAjgHi21zQUEsDmphnsEBHCPltrmAk3/f3/z1U3U8LPbN6KjhvQrVXfvnUU6n35wPapLv8r11bcPon4//vJnlC1PwIhTUZWAAFbJ6hsJCGDEpKhKQACrZPWNBAQwYlJUJSCAVbL6RgICGDEpqhIQwCpZfSMBAYyYFFUJLPdOSGvI9ITjk/dfiW7d+itVj971iE5gWn+VK9rsoyJPwFRKXYmAAJawapoKCGAqpa5EQABLWDVNBQQwlVJXIiCAJayapgICmEqpKxEQwBJWTVMBAUyl1JUIOAl5Amt6wpG+w9H6hOMJyx7ux56Aw41srgUL4FzzHG43AjjcyOZasADONc/hdiOAw41srgUL4FzzHG43AjjcyOZasADONc/hdiOAw41srgUvdxKSnnAc9Q7HUfFKv47Ven2egK1F9dslIIC7uBS3FhDA1qL67RIQwF1cilsLCGBrUf12CQjgLi7FrQUEsLWofrsEBHAXl+LWAgLYWlS/XQLTnISkJxze4Xh8Pq6/dPnxF4p/6glYDKz9toAAbvu4WiwggMXA2m8LCOC2j6vFAgJYDKz9toAAbvu4WiwggMXA2m8LCOC2j6vFAgJYDKz9tkD0W623W9ReTU84VnuHo7X6m69fjX6fSPqb0NP1eQKmUupKBASwhFXTVEAAUyl1JQICWMKqaSoggKmUuhIBASxh1TQVEMBUSl2JgACWsGqaCghgKqWuROCwk5D0hCN9h+PuvbMI6P7p+WF7jha4WJEn4GID7227AtjbRBZbjwAuNvDetiuAvU1ksfUI4GID7227AtjbRBZbjwAuNvDetiuAvU1ksfUI4GID7227zU8F0hMO73D0FoVj1uMJeIy7u/4vIICicKiAAB7K7+YCKAOHCgjgofxuLoAycKiAAB7K7+YCKAOHCgjgofxu3vwk5J1b16KvLKX03uFIpcas8wQcc27TrFoApxnlmBsRwDHnNs2qBXCaUY65EQEcc27TrFoApxnlmBsRwDHnNs2qBXCaUY65EQEcc25WTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0L3Af+uYbixoS1WFAAAAAElFTkSuQmCC\"></image></symbol><g transform=\"translate(37.57910645834454 30.260009582668317) rotate(0 86.40756100104954 86.40756100104909)\"><use xlink:href=\"#image-241a2825d965ea677b3dc22aaea9375b2aeb6193\" width=\"173\" height=\"173\" opacity=\"1\" x=\"260\" y=\"85\"></use></g>';\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 464)\" fill=\"#EAECFE\" class=\"base\">ID:</text><text transform=\"matrix(1 0 0 1 50 506)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_tokenId), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 579)\" fill=\"#EAECFE\" class=\"base\">Balance:</text><text transform=\"matrix(1 0 0 1 50 621)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_balanceOf / 1e18), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 695)\" fill=\"#EAECFE\" class=\"base\">Until unlock:</text><text transform=\"matrix(1 0 0 1 50 737)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(untilEnd / 60 / 60 / 24), ' days</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 811)\" fill=\"#EAECFE\" class=\"base\">Power:</text><text transform=\"matrix(1 0 0 1 50 853)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_value / 1e18), '</text></svg>'));\n\n    string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"xSHADY #', StringLib._toString(_tokenId), '\", \"description\": \"Locked SHADY tokens\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n    output = string(abi.encodePacked('data:application/json;base64,', json));\n  }\n}\n"
    },
    "contracts/HintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./dependencies/Base.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/HintHelpers.sol\ncontract HintHelpers is Base, Ownable, CheckContract {\n    string constant public NAME = \"HintHelpers\";\n\n    ISortedTroves public sortedTroves;\n    ITroveManager public troveManager;\n\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _sortedTrovesAddress,\n        address _troveManagerAddress\n    )\n        external\n        onlyOwner\n    {\n        _checkContract(_sortedTrovesAddress);\n        _checkContract(_troveManagerAddress);\n\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().\n     *\n     * It simulates a redemption of `_SIMamount` to figure out where the redemption sequence will start and what state the final Trove\n     * of the sequence will end up in.\n     *\n     * Returns three hints:\n     *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).\n     *  - `partialRedemptionHintNICR` is the final nominal ICR of the last Trove of the sequence after being hit by partial redemption,\n     *     or zero in case of no partial redemption.\n     *  - `truncatedSIMamount` is the maximum amount that can be redeemed out of the the provided `_SIMamount`. This can be lower than\n     *    `_SIMamount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the\n     *    minimum allowed value (i.e. MIN_NET_DEBT).\n     *\n     * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero\n     * will leave it uncapped.\n     */\n\n    function getRedemptionHints(\n        uint _SIMamount, \n        uint _price,\n        uint _maxIterations\n    )\n        external\n        view\n        returns (\n            address firstRedemptionHint,\n            uint partialRedemptionHintNICR,\n            uint truncatedSIMamount\n        )\n    {\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        uint remainingSIM = _SIMamount;\n        address currentTroveuser = sortedTrovesCached.getLast();\n\n        while (currentTroveuser != address(0) && troveManager.getCurrentICR(currentTroveuser, _price) < MCR) {\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n        }\n\n        firstRedemptionHint = currentTroveuser;\n\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint).max;\n        }\n\n        while (currentTroveuser != address(0) && remainingSIM > 0 && --_maxIterations > 0) {\n            uint netSIMDebt = _getNetDebt(troveManager.getTroveDebt(currentTroveuser)) + troveManager.getPendingSIMDebtReward(currentTroveuser);\n\n            if (netSIMDebt > remainingSIM) {\n                if (netSIMDebt > MIN_NET_DEBT) {\n                    uint maxRedeemableSIM = LiquityMath._min(remainingSIM, netSIMDebt - MIN_NET_DEBT);\n\n                    uint WSTETH = troveManager.getTroveColl(currentTroveuser) + troveManager.getPendingWSTETHReward(currentTroveuser);\n\n                    uint newColl = WSTETH - maxRedeemableSIM * DECIMAL_PRECISION / _price;\n                    uint newDebt = netSIMDebt - maxRedeemableSIM;\n\n                    uint compositeDebt = _getCompositeDebt(newDebt);\n                    partialRedemptionHintNICR = LiquityMath._computeNominalCR(newColl, compositeDebt);\n\n                    remainingSIM = remainingSIM - maxRedeemableSIM;\n                }\n                break;\n            } else {\n                remainingSIM = remainingSIM - netSIMDebt;\n            }\n\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n        }\n\n        truncatedSIMamount = _SIMamount - remainingSIM;\n    }\n\n    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the \n    sortedTroves list from the correct insert position of the Trove to be inserted. \n    \n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \n    be <= sqrt(length) positions away from the correct insert position.\n    */\n    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)\n        external\n        view\n        returns (address hintAddress, uint diff, uint latestRandomSeed)\n    {\n        uint arrayLength = troveManager.getTroveOwnersCount();\n\n        if (arrayLength == 0) {\n            return (address(0), 0, _inputRandomSeed);\n        }\n\n        hintAddress = sortedTroves.getLast();\n        diff = LiquityMath._getAbsoluteDifference(_CR, troveManager.getNominalICR(hintAddress));\n        latestRandomSeed = _inputRandomSeed;\n\n        uint i = 1;\n\n        while (i < _numTrials) {\n            latestRandomSeed = uint(keccak256(abi.encodePacked(latestRandomSeed)));\n\n            uint arrayIndex = latestRandomSeed % arrayLength;\n            address currentAddress = troveManager.getTroveFromTroveOwnersArray(arrayIndex);\n            uint currentNICR = troveManager.getNominalICR(currentAddress);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n            uint currentDiff = LiquityMath._getAbsoluteDifference(currentNICR, _CR);\n\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n    }\n\n    function computeNominalCR(uint _coll, uint _debt) external pure returns (uint) {\n        return LiquityMath._computeNominalCR(_coll, _debt);\n    }\n\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPool.sol\";\n\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolSIMDebtUpdated(uint _SIMDebt);\n    event ActivePoolWSTETHBalanceUpdated(uint _WSTETH);\n\n    // --- Functions ---\n    function sendWSTETH(address _account, uint _amount) external;\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPriceFeed.sol\";\n\n\ninterface IBase {\n    function priceFeed() external view returns (IPriceFeed);\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event SIMTokenAddressChanged(address _simTokenAddress);\n    event SimVeDistributorAddressChanged(address _VeAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event SIMBorrowingFeePaid(address indexed _borrower, uint _SIMFee);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _simTokenAddress,\n        address _shadyStakingAddress,\n        address _feeReceiver\n    ) external;\n\n    function openTrove(uint amount, uint _maxFee, uint _SIMAmount, address _upperHint, address _lowerHint) external payable;\n\n    function addColl(uint amount, address _upperHint, address _lowerHint) external;\n\n    function moveWSTETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\n\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function withdrawSIM(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\n\n    function repaySIM(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint addColAmount, uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\n\n    function claimCollateral() external;\n\n//    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\ninterface ICollSurplusPool {\n\n    // --- Events ---\n\n    event WSTETHAddressChanged(address _newWSTETHAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _WSTETHAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getWSTETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IController {\n\n    // --- DEPENDENCY ADDRESSES\n    function governance() external view returns (address);\n\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPool.sol\";\n\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolSIMDebtUpdated(uint _SIMDebt);\n    event DefaultPoolWSTETHBalanceUpdated(uint _WSTETH);\n\n    // --- Functions ---\n    function sendWSTETHToActivePool(uint _amount) external;\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IIssuance {\n    \n    // --- Events ---\n\n    event SHADYTokenAddressSet(address _shadyTokenAddress);\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\n    event TotalSHADYIssuedUpdated(uint _totalSHADYIssued);\n\n    // --- Functions ---\n\n    function setAddresses(address shadyTokenAddress_, address stabilityPoolAddress_) external;\n\n    function issueSHADY() external returns (uint);\n\n    function sendSHADY(address account_, uint shadyAmount_) external;\n}\n"
    },
    "contracts/interfaces/ILockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n    \ninterface ILockupContractFactory {\n    \n    // --- Events ---\n\n    event SHADYTokenAddressSet(address shadyTokenAddress_);\n    event LockupContractDeployedThroughFactory(address lockupContractAddress_, address beneficiary_, uint unlockTime_, address deployer_);\n\n    // --- Functions ---\n\n    function setSHADYTokenAddress(address shadyTokenAddress_) external;\n\n    function deployLockupContract(address beneficiary_, uint unlockTime_) external;\n\n    function isRegisteredLockup(address addr_) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Common interface for the Pools.\ninterface IPool {\n    \n    // --- Events ---\n    \n    event WSTETHBalanceUpdated(uint _newBalance);\n    event SIMBalanceUpdated(uint _newBalance);\n    event WSTETHAddressChanged(address _newWSTETHAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    \n    function getWSTETH() external view returns (uint);\n\n    function getSIMDebt() external view returns (uint);\n\n    function increaseSIMDebt(uint _amount) external;\n\n    function decreaseSIMDebt(uint _amount) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IPriceFeed {\n\n    // --- Events ---\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n   \n    // --- Function ---\n    function fetchPrice() external returns (uint);\n}\n"
    },
    "contracts/interfaces/ISHADYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ISHADYToken is IERC20, IERC20Permit {\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address communityIssuanceAddress);\n    event VeAddressSet(address veAddress);\n    event LockupContractFactoryAddressSet(address lockupContractFactoryAddress);\n\n    // --- Functions ---\n\n    function getDeploymentStartTime() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ISIMToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ISIMToken is IERC20, IERC20Permit {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address troveManagerAddress);\n    event StabilityPoolAddressChanged(address newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(address newBorrowerOperationsAddress);\n    event LUSDTokenBalanceUpdated(address user, uint amount);\n\n    // --- Functions ---\n\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(address account_, uint256 amount_) external;\n\n    function sendToPool(address sender_, address poolAddress, uint256 amount_) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event NodeAdded(address _id, uint _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n    \n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\n\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n * The Stability Pool holds SIM tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its SIM debt gets offset with\n * SIM in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of SIM tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a SIM loss, in proportion to their deposit as a share of total deposits.\n * They also receive an WSTETH gain, as the WSTETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total SIM in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WSTETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * --- SHADY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An SHADY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued SHADY in proportion to the deposit as a share of total deposits. The SHADY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n */\ninterface IStabilityPool {\n\n    // --- Events ---\n    \n    event StabilityPoolWSTETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolSIMBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\n\n    event WSTETHGainWithdrawn(address indexed _depositor, uint _WSTETH, uint _SIMLoss);\n    event SHADYPaidToDepositor(address indexed _depositor, uint _SHADY);\n    event SHADYPaidToFrontEnd(address indexed _frontEnd, uint _SHADY);\n    event WSTETHSent(address _to, uint _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other SIM contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _WSTETHAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _SIMTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Frontend is registered or zero address\n     * - Sender is not a registered frontend\n     * - _amount is not zero\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (SHADY, WSTETH) to depositor\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint _amount, address _frontEndTag) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (SHADY, WSTETH) to depositor\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some WSTETH gain\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's SHADY gain to  depositor\n     * - Sends all tagged front end's SHADY gain to the tagged front end\n     * - Transfers the depositor's entire WSTETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake\n     */\n    function withdrawWSTETHGainToTrove(address _upperHint, address _lowerHint) external;\n\n    /*\n     * Initial checks:\n     * - Frontend (sender) not already registered\n     * - User (sender) has no deposit\n     * - _kickbackRate is in the range [0, 100%]\n     * ---\n     * Front end makes a one-time selection of kickback rate upon registering\n     */\n//    function registerFrontEnd(uint _kickbackRate) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the SIM contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's WSTETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint _debt, uint _coll) external;\n\n    /*\n     * Returns the total amount of WSTETH held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like WSTETH received from a self-destruct.\n     */\n    function getWSTETH() external view returns (uint);\n\n    /*\n     * Returns SIM held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalSIMDeposits() external view returns (uint);\n\n    /*\n     * Calculates the WSTETH gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorWSTETHGain(address _depositor) external view returns (uint);\n\n    /*\n     * Calculate the SHADY gain earned by a deposit since its last snapshots were taken.\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n     * which they made their deposit.\n     */\n    function getDepositorSHADYGain(address _depositor) external view returns (uint);\n\n    /*\n     * Return the SHADY gain earned by the front end.\n     */\n//    function getFrontEndSHADYGain(address _frontEnd) external view returns (uint);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedSIMDeposit(address _depositor) external view returns (uint);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n//    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\n\n    /*\n     * Fallback function\n     * Only callable by Active Pool, it just accounts for WSTETH received\n     * receive() external payable;\n     */\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IBase.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./ISIMToken.sol\";\nimport \"./ISHADYToken.sol\";\nimport \"./IVe.sol\";\n\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IBase {\n    \n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n//    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event SHADYTokenAddressChanged(address _shadyTokenAddress);\n    event WSTETHVeDistibutorAddressChanged(address _shadyStakingAddress);\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation/*, uint _SIMGasCompensation*/);\n    event Redemption(uint _attemptedSIMAmount, uint _actualSIMAmount, uint _WSTETHSent, uint _WSTETHFee);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\n    event LTermsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\n    event TroveSnapshotsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n//        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _simTokenAddress,\n        address _sortedTrovesAddress,\n        address _shadyTokenAddress,\n        address _veAddress\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n    function simToken() external view returns (ISIMToken);\n    function shadyToken() external view returns (ISHADYToken);\n    function wstETHVeDistributor() external view returns (address);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint _SIMAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external;\n\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingWSTETHReward(address _borrower) external view returns (uint);\n\n    function getPendingSIMDebtReward(address _borrower) external view returns (uint);\n\n     function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(address _borrower) external view returns (\n        uint debt,\n        uint coll,\n        uint pendingSIMDebtReward,\n        uint pendingWSTETHReward\n    );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint);\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint SIMDebt) external view returns (uint);\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n    \n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \n\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \n\n    function getTCR(uint _price) external view returns (uint);\n\n    function checkRecoveryMode(uint _price) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IVe {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n\n//    function increaseF_WSTETH(uint _WSTETHFee) external;\n\n//    function increaseF_SIM(uint _SIMFee) external;\n\n    function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\n\n    function lockedDerivedAmount(uint veId) external view returns (uint);\n\n    function lockedEnd(uint veId) external view returns (uint);\n\n    function tokens(uint idx) external view returns (address);\n\n    function balanceOfNFT(uint) external view returns (uint);\n\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n\n    function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\n\n    function userPointEpoch(uint tokenId) external view returns (uint);\n\n    function epoch() external view returns (uint);\n\n    function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\n\n    function pointHistory(uint loc) external view returns (Point memory);\n\n    function checkpoint() external;\n\n    function increaseAmount(address _token, uint _tokenId, uint _value) external;\n\n    function totalSupplyAt(uint _block) external view returns (uint);\n}"
    },
    "contracts/interfaces/IVeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IVeDistributor {\n\n  function rewardToken() external view returns (address);\n\n  function checkpoint() external;\n\n  function checkpointTotalSupply() external;\n\n  function claim(uint _tokenId) external returns (uint);\n\n}\n"
    },
    "contracts/LiquidityRewardsIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./dependencies/Issuance.sol\";\n\ncontract LiquidityRewardsIssuance is Issuance {\n    string constant public NAME = \"LiquidityRewardsIssuance\";\n}"
    },
    "contracts/LockupContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/ISHADYToken.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/LQTY/LockupContract.sol\ncontract LockupContract {\n    // --- Data ---\n    string constant public NAME = \"LockupContract\";\n\n    uint constant internal SECONDS_IN_ONE_YEAR = 31536000;\n\n    address public immutable beneficiary;\n\n    ISHADYToken public shadyToken;\n\n    // Unlock time is the Unix point in time at which the beneficiary can withdraw.\n    uint public unlockTime;\n\n    // --- Events ---\n\n    event LockupContractCreated(address _beneficiary, uint _unlockTime);\n    event LockupContractEmptied(uint _SHADYwithdrawal);\n\n    // --- Functions ---\n\n    constructor(\n        address _shadyTokenAddress,\n        address _beneficiary, \n        uint _unlockTime\n    ) {\n        shadyToken = ISHADYToken(_shadyTokenAddress);\n\n        /*\n        * Set the unlock time to a chosen instant in the future, as long as it is at least 1 year after\n        * the system was deployed \n        */\n        _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(_unlockTime);\n        unlockTime = _unlockTime;\n        \n        beneficiary = _beneficiary;\n        emit LockupContractCreated(_beneficiary, _unlockTime);\n    }\n\n    function withdrawSHADY() external {\n        _requireCallerIsBeneficiary();\n        _requireLockupDurationHasPassed();\n\n        ISHADYToken shadyTokenCached = shadyToken;\n        uint SHADYBalance = shadyTokenCached.balanceOf(address(this));\n        require(shadyTokenCached.transfer(beneficiary, SHADYBalance));\n        emit LockupContractEmptied(SHADYBalance);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBeneficiary() internal view {\n        require(msg.sender == beneficiary, \"LockupContract: caller is not the beneficiary\");\n    }\n\n    function _requireLockupDurationHasPassed() internal view {\n        require(block.timestamp >= unlockTime, \"LockupContract: The lockup duration must have passed\");\n    }\n\n    function _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(uint _unlockTime) internal view {\n        uint systemDeploymentTime = shadyToken.getDeploymentStartTime();\n        require(_unlockTime >= systemDeploymentTime + SECONDS_IN_ONE_YEAR, \"LockupContract: unlock time must be at least one year after system deployment\");\n    }\n}\n"
    },
    "contracts/LockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./interfaces/ILockupContractFactory.sol\";\nimport \"./LockupContract.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/LQTY/LockupContractFactory.sol\ncontract LockupContractFactory is ILockupContractFactory, Ownable, CheckContract {\n    // --- Data ---\n    string constant public NAME = \"LockupContractFactory\";\n    uint constant internal SECONDS_IN_ONE_YEAR = 31536000;\n\n    address public shadyTokenAddress;\n    mapping (address => address) public lockupContractToDeployer;\n\n    // --- Functions ---\n\n    function setSHADYTokenAddress(address _shadyTokenAddress) external override onlyOwner {\n        _checkContract(_shadyTokenAddress);\n\n        shadyTokenAddress = _shadyTokenAddress;\n        emit SHADYTokenAddressSet(_shadyTokenAddress);\n\n        renounceOwnership();\n    }\n\n    function deployLockupContract(address _beneficiary, uint _unlockTime) external override {\n        address shadyTokenAddressCached = shadyTokenAddress;\n        _requireSHADYAddressIsSet(shadyTokenAddressCached);\n        LockupContract lockupContract = new LockupContract(shadyTokenAddressCached, _beneficiary, _unlockTime);\n\n        lockupContractToDeployer[address(lockupContract)] = msg.sender;\n        emit LockupContractDeployedThroughFactory(address(lockupContract), _beneficiary, _unlockTime, msg.sender);\n    }\n\n    function isRegisteredLockup(address _contractAddress) public view override returns (bool) {\n        return lockupContractToDeployer[_contractAddress] != address(0);\n    }\n\n    // --- 'require'  functions ---\n    function _requireSHADYAddressIsSet(address _shadyTokenAddress) internal pure {\n        require(_shadyTokenAddress != address(0), \"LCF: SHADY address is not set\");\n    }\n}\n"
    },
    "contracts/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/MultiTroveGetter.sol\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n\n        uint debt;\n        uint coll;\n        uint stake;\n\n        uint snapshotETH;\n        uint snapshotLUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(int _startIdx, uint _count)\n        external view returns (CombinedTroveData[] memory _troves)\n    {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/SHADYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./interfaces/ISHADYToken.sol\";\nimport \"./interfaces/ILockupContractFactory.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/LQTY/LQTYToken.sol\ncontract SHADYToken is ERC20, ERC20Permit, CheckContract, ISHADYToken {\n    uint internal constant ONE_YEAR_IN_SECONDS = 31536000;  // 60 * 60 * 24 * 365\n    uint internal constant _1_MILLION = 1e24;    // 1e6 * 1e18 = 1e24\n\n    uint internal immutable deploymentStartTime;\n    address public immutable multisigAddress;\n    address public immutable communityIssuanceAddress;\n    address public immutable liquidityRewardsIssuanceAddress;\n    ILockupContractFactory public immutable lockupContractFactory;\n\n    // --- Functions ---\n\n    constructor(\n        address communityIssuanceAddress_,\n        address liquidityRewardsIssuanceAddress_,\n        address lockupFactoryAddress_,\n        address spenderAddress_,\n        address multisigAddress_\n    ) ERC20(\"Shady\", \"SHADY\") ERC20Permit(\"Shady\") {\n        _checkContract(communityIssuanceAddress_);\n        _checkContract(liquidityRewardsIssuanceAddress_);\n        _checkContract(lockupFactoryAddress_);\n\n        multisigAddress = multisigAddress_;\n        deploymentStartTime  = block.timestamp;\n        communityIssuanceAddress = communityIssuanceAddress_;\n        liquidityRewardsIssuanceAddress = liquidityRewardsIssuanceAddress_;\n        lockupContractFactory = ILockupContractFactory(lockupFactoryAddress_);\n\n        // --- Initial SHADY allocations ---\n\n        uint depositorsEntitlement = _1_MILLION * 30; // Allocate 30 million to the algorithmic issuance schedule\n        _mint(communityIssuanceAddress_, depositorsEntitlement);\n\n        uint lpRewardsEntitlement = _1_MILLION * 30; // Allocate 30 million to the algorithmic issuance schedule\n        _mint(liquidityRewardsIssuanceAddress_, lpRewardsEntitlement);\n\n        uint _spenderEntitlement = _1_MILLION * 14;  // Allocate 14 million for Public Sale, Community Reserve and initial liquidity\n        _mint(spenderAddress_, _spenderEntitlement);\n\n        // Allocate the remainder to the Multisig: (100 - 30 - 30 - 14) million = 26 million\n        uint multisigEntitlement = _1_MILLION * 100 - depositorsEntitlement - lpRewardsEntitlement - _spenderEntitlement;\n        _mint(multisigAddress_, multisigEntitlement);\n    }\n\n    // --- External functions ---\n\n    function getDeploymentStartTime() external view override returns (uint256) {\n        return deploymentStartTime;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override (ERC20, IERC20) returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    // --- hooks ---\n\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Restrict the multisig's transfers in first year\n        if (from == multisigAddress && _isFirstYear()) {\n            _requireRecipientIsRegisteredLC(to);\n        }\n\n        if (from != address(0)) {\n            _requireValidRecipient(to);\n        }\n    }\n\n    // --- Helper functions ---\n\n    function _callerIsMultisig() internal view returns (bool) {\n        return (msg.sender == multisigAddress);\n    }\n\n    function _isFirstYear() internal view returns (bool) {\n        return (block.timestamp - deploymentStartTime < ONE_YEAR_IN_SECONDS);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(this),\n            \"SHADY: Cannot transfer tokens directly to the SHADY token contract\"\n        );\n        require(\n            _recipient != communityIssuanceAddress &&\n            _recipient != liquidityRewardsIssuanceAddress,\n            \"SHADY: Cannot transfer tokens directly to an issuance or ve contract\"\n        );\n    }\n\n    function _requireRecipientIsRegisteredLC(address _recipient) internal view {\n        require(lockupContractFactory.isRegisteredLockup(_recipient),\n            \"SHADY: recipient must be a LockupContract registered in the Factory\");\n    }\n\n    function _requireSenderIsNotMultisig(address _sender) internal view {\n        require(_sender != multisigAddress, \"SHADY: sender must not be the multisig\");\n    }\n\n    function _requireCallerIsNotMultisig() internal view {\n        require(!_callerIsMultisig(), \"SHADY: caller must not be the multisig\");\n    }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n/*\n* https://github.com/liquity/dev/blob/main/packages/contracts/contracts/SortedTroves.sol\n* A sorted doubly linked list with nodes sorted in descending order.\n*\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n* which is like the ICR but without the price, i.e., just collateral / debt.\n*\n* The list optionally accepts insert position hints.\n*\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n* change dynamically as liquidation events occur.\n*\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n* Thus, Nodes remain sorted by current NICR.\n*\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n* to their position.\n*\n* The list is a modification of the following audited SortedDoublyLinkedList:\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n*\n*\n* Changes made in the Liquity implementation:\n*\n* - Keys have been removed from nodes\n*\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\n*\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n*/\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\n    string constant public NAME = \"SortedTroves\";\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId;                  // Id of next node (smaller NICR) in the list\n        address prevId;                  // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize;                     // Maximum size of the list\n        uint256 size;                        // Current size of the list\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters ---\n\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cant be zero\");\n        _checkContract(_troveManagerAddress);\n        _checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\n        }\n\n         data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size = data.size + 1;\n        emit NodeAdded(_id, _NICR);\n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size = data.size - 1;\n        emit NodeRemoved(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return data.nodes[_prevId].nextId == _nextId &&\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\n                   _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOADs\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOADs\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"SortedTroves: Caller is not the TroveManager\");\n    }\n\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\n                \"SortedTroves: Caller is neither BO nor TroveM\");\n    }\n}\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport './interfaces/IBorrowerOperations.sol';\nimport './interfaces/IStabilityPool.sol';\nimport './interfaces/IBorrowerOperations.sol';\nimport './interfaces/ITroveManager.sol';\nimport './interfaces/ISIMToken.sol';\nimport './interfaces/ISortedTroves.sol';\nimport \"./interfaces/IIssuance.sol\";\nimport \"./dependencies/Base.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n/*\n * https://github.com/liquity/dev/blob/main/packages/contracts/contracts/StabilityPool.sol\n * The Stability Pool holds SIM tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its SIM debt gets offset with\n * SIM in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of SIM tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a SIM loss, in proportion to their deposit as a share of total deposits.\n * They also receive an WSTETH gain, as the WSTETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total SIM in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and WSTETH gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and WSTETH gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated WSTETH gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated WSTETH gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated WSTETH gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding WSTETH gain\n * can be calculated using the initial deposit, the depositors snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated WSTETH gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the \n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the \n * order of 1e-9. \n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion SIM has depleted to < 1 SIM).\n *\n *\n *  --- TRACKING DEPOSITOR'S WSTETH GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated WSTETH gain, during the epoch in which the deposit was non-zero and earned WSTETH.\n *\n * We calculate the depositor's accumulated WSTETH gain for the scale at which they made the deposit, using the WSTETH gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated WSTETH gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WSTETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- SHADY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An SHADY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued SHADY in proportion to the deposit as a share of total deposits. The SHADY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track SHADY gains for depositors, where 'G' is the sum corresponding to SHADY gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is Base, Ownable, CheckContract, IStabilityPool {\n    string constant public NAME = \"StabilityPool\";\n\n    address public WSTETHAddress;\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    ISIMToken public simToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    IIssuance public communityIssuance;\n\n    uint256 internal WSTETH;  // deposited ether tracker\n\n    // Tracker for SIM held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalSIMDeposits;\n\n   // --- Data structures ---\n\n    /*struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }*/\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n//    mapping (address => FrontEnd) public frontEnds;  // front end address -> FrontEnd struct\n//    mapping (address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n//    mapping (address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some SIM debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint public P = DECIMAL_PRECISION;\n\n    uint public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* WSTETH Gain sum 'S': During its lifetime, each deposit d_t earns an WSTETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping (uint128 => mapping(uint128 => uint)) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate SHADY gains. During it's lifetime, each deposit d_t earns a SHADY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  SHADY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the SHADY reward is issued (i.e. G is updated), before other state changes are made.\n    */\n    mapping (uint128 => mapping(uint128 => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the SHADY issuance calculation\n    uint public lastSHADYError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastWSTETHError_Offset;\n    uint public lastSIMLossError_Offset;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _WSTETHAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _simTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        _checkContract(_WSTETHAddress);\n        _checkContract(_borrowerOperationsAddress);\n        _checkContract(_troveManagerAddress);\n        _checkContract(_activePoolAddress);\n        _checkContract(_simTokenAddress);\n        _checkContract(_sortedTrovesAddress);\n        _checkContract(_priceFeedAddress);\n        _checkContract(_communityIssuanceAddress);\n\n        WSTETHAddress = _WSTETHAddress;\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        simToken = ISIMToken(_simTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = IIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit SIMTokenAddressChanged(_simTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getWSTETH() external view override returns (uint) {\n        return WSTETH;\n    }\n\n    function getTotalSIMDeposits() external view override returns (uint) {\n        return totalSIMDeposits;\n    }\n\n    function receiveWSTETH(uint amount) external {\n        _requireCallerIsActivePool();\n        WSTETH += amount;\n        emit StabilityPoolWSTETHBalanceUpdated(WSTETH);\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n    * - Tags the deposit with the provided front end tag param, if it's a new deposit\n    * - Sends depositor's accumulated gains (SHADY, WSTETH) to depositor\n    * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n    */\n    function provideToSP(uint _amount, address /*_frontEndTag*/) external override {\n//        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n//        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        IIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerSHADYIssuance(communityIssuanceCached);\n\n//        if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}\n        uint depositorWSTETHGain = getDepositorWSTETHGain(msg.sender);\n        uint compoundedSIMDeposit = getCompoundedSIMDeposit(msg.sender);\n        uint SIMLoss = initialDeposit - compoundedSIMDeposit; // Needed only for event log\n\n        // First pay out any SHADY gains\n//        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutSHADYGains(communityIssuanceCached, msg.sender/*, frontEnd*/);\n\n        // Update front end stake\n        /*uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake + _amount;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);*/\n\n        _sendSIMtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedSIMDeposit + _amount;\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit WSTETHGainWithdrawn(msg.sender, depositorWSTETHGain, SIMLoss); // SIM Loss required for event log\n\n        _sendWSTETHGainToDepositor(depositorWSTETHGain);\n     }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n    * - Removes the deposit's front end tag if it is a full withdrawal\n    * - Sends all depositor's accumulated gains (SHADY, WSTETH) to depositor\n    * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n    */\n    function withdrawFromSP(uint _amount) external override {\n        if (_amount !=0) {_requireNoUnderCollateralizedTroves();}\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        IIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerSHADYIssuance(communityIssuanceCached);\n\n        uint depositorWSTETHGain = getDepositorWSTETHGain(msg.sender);\n\n        uint compoundedSIMDeposit = getCompoundedSIMDeposit(msg.sender);\n        uint SIMtoWithdraw = LiquityMath._min(_amount, compoundedSIMDeposit);\n        uint SIMLoss = initialDeposit - compoundedSIMDeposit; // Needed only for event log\n\n        // First pay out any SHADY gains\n//        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutSHADYGains(communityIssuanceCached, msg.sender/*, frontEnd*/);\n\n        // Update front end stake\n        /*uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake - SIMtoWithdraw;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);*/\n\n        _sendSIMToDepositor(msg.sender, SIMtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedSIMDeposit - SIMtoWithdraw;\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit WSTETHGainWithdrawn(msg.sender, depositorWSTETHGain, SIMLoss);  // SIM Loss required for event log\n\n        _sendWSTETHGainToDepositor(depositorWSTETHGain);\n    }\n\n    /* withdrawWSTETHGainToTrove:\n    * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n    * - Sends all depositor's SHADY gain to  depositor\n    * - Sends all tagged front end's SHADY gain to the tagged front end\n    * - Transfers the depositor's entire WSTETH gain from the Stability Pool to the caller's trove\n    * - Leaves their compounded deposit in the Stability Pool\n    * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawWSTETHGainToTrove(address _upperHint, address _lowerHint) external override {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasWSTETHGain(msg.sender);\n\n        IIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerSHADYIssuance(communityIssuanceCached);\n\n        uint depositorWSTETHGain = getDepositorWSTETHGain(msg.sender);\n\n        uint compoundedSIMDeposit = getCompoundedSIMDeposit(msg.sender);\n        uint SIMLoss = initialDeposit - compoundedSIMDeposit; // Needed only for event log\n\n        // First pay out any SHADY gains\n//        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutSHADYGains(communityIssuanceCached, msg.sender/*, frontEnd*/);\n\n        // Update front end stake\n        /*uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);*/\n\n        _updateDepositAndSnapshots(msg.sender, compoundedSIMDeposit);\n\n        /* Emit events before transferring WSTETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the WSTETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit WSTETHGainWithdrawn(msg.sender, depositorWSTETHGain, SIMLoss);\n        emit UserDepositChanged(msg.sender, compoundedSIMDeposit);\n\n        WSTETH -= depositorWSTETHGain;\n        emit StabilityPoolWSTETHBalanceUpdated(WSTETH);\n        emit WSTETHSent(msg.sender, depositorWSTETHGain);\n\n        require(IERC20(WSTETHAddress).transfer(address(borrowerOperations), depositorWSTETHGain));\n        borrowerOperations.moveWSTETHGainToTrove/*{ value: depositorWSTETHGain }*/(msg.sender, _upperHint, _lowerHint);\n    }\n\n    // --- SHADY issuance functions ---\n\n    function _triggerSHADYIssuance(IIssuance _communityIssuance) internal {\n        uint SHADYIssuance = _communityIssuance.issueSHADY();\n       _updateG(SHADYIssuance);\n    }\n\n    function _updateG(uint _SHADYIssuance) internal {\n        uint totalSIM = totalSIMDeposits; // cached to save an SLOAD\n        /*\n        * When total deposits is 0, G is not updated. In this case, the SHADY issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n        *\n        */\n        if (totalSIM == 0 || _SHADYIssuance == 0) {return;}\n\n        uint SHADYPerUnitStaked;\n        SHADYPerUnitStaked =_computeSHADYPerUnitStaked(_SHADYIssuance, totalSIM);\n\n        uint marginalSHADYGain = SHADYPerUnitStaked * P;\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale] + marginalSHADYGain;\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeSHADYPerUnitStaked(uint _SHADYIssuance, uint _totalSIMDeposits) internal returns (uint) {\n        /*\n        * Calculate the SHADY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n        * cumulative error low in the running total G:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint SHADYNumerator = _SHADYIssuance * DECIMAL_PRECISION + lastSHADYError;\n\n        uint SHADYPerUnitStaked = SHADYNumerator / _totalSIMDeposits;\n        lastSHADYError = SHADYNumerator - SHADYPerUnitStaked * _totalSIMDeposits;\n\n        return SHADYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the SIM contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's WSTETH collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalSIM = totalSIMDeposits; // cached to save an SLOAD\n        if (totalSIM == 0 || _debtToOffset == 0) { return; }\n\n        _triggerSHADYIssuance(communityIssuance);\n\n        (uint WSTETHGainPerUnitStaked,\n            uint SIMLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalSIM);\n\n        _updateRewardSumAndProduct(WSTETHGainPerUnitStaked, SIMLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalSIMDeposits\n    )\n        internal\n        returns (uint WSTETHGainPerUnitStaked, uint SIMLossPerUnitStaked)\n    {\n        /*\n        * Compute the SIM and WSTETH rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint WSTETHNumerator = _collToAdd * DECIMAL_PRECISION + lastWSTETHError_Offset;\n\n        assert(_debtToOffset <= _totalSIMDeposits);\n        if (_debtToOffset == _totalSIMDeposits) {\n            SIMLossPerUnitStaked = DECIMAL_PRECISION;  // When the Pool depletes to 0, so does each deposit \n            lastSIMLossError_Offset = 0;\n        } else {\n            uint SIMLossNumerator = _debtToOffset * DECIMAL_PRECISION - lastSIMLossError_Offset;\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" SIM loss,\n            * which ensures the error in any given compoundedSIMDeposit favors the Stability Pool.\n            */\n            SIMLossPerUnitStaked = SIMLossNumerator / _totalSIMDeposits + 1;\n            lastSIMLossError_Offset = SIMLossPerUnitStaked * _totalSIMDeposits - SIMLossNumerator;\n        }\n\n        WSTETHGainPerUnitStaked = WSTETHNumerator / _totalSIMDeposits;\n        lastWSTETHError_Offset = WSTETHNumerator - WSTETHGainPerUnitStaked * _totalSIMDeposits;\n\n        return (WSTETHGainPerUnitStaked, SIMLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _WSTETHGainPerUnitStaked, uint _SIMLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_SIMLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool SIM in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - SIMLossPerUnitStaked)\n        */\n        uint newProductFactor = uint(DECIMAL_PRECISION) - _SIMLossPerUnitStaked;\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The WSTETH gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to WSTETH gain, and P to deposit loss, we update S first.\n        */\n        uint marginalWSTETHGain = _WSTETHGainPerUnitStaked * currentP;\n        uint newS = currentS + marginalWSTETHGain;\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached + 1;\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n        // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP * newProductFactor / DECIMAL_PRECISION < SCALE_FACTOR) {\n            newP = currentP * newProductFactor * SCALE_FACTOR / DECIMAL_PRECISION;\n            currentScale = currentScaleCached + 1;\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP * newProductFactor / DECIMAL_PRECISION;\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        IActivePool activePoolCached = activePool;\n\n        // Cancel the liquidated SIM debt with the SIM in the stability pool\n        activePoolCached.decreaseSIMDebt(_debtToOffset);\n        _decreaseSIM(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        simToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendWSTETH(address(this), _collToAdd);\n    }\n\n    function _decreaseSIM(uint _amount) internal {\n        uint newTotalSIMDeposits = totalSIMDeposits - _amount;\n        totalSIMDeposits = newTotalSIMDeposits;\n        emit StabilityPoolSIMBalanceUpdated(newTotalSIMDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the WSTETH gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorWSTETHGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint WSTETHGain = _getWSTETHGainFromSnapshots(initialDeposit, snapshots);\n        return WSTETHGain;\n    }\n\n    function _getWSTETHGainFromSnapshots(uint initialDeposit, Snapshots memory snapshots) internal view returns (uint) {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The WSTETH gain may span up to one scale change.\n        * If it does, the second portion of the WSTETH gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot] - S_Snapshot;\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint WSTETHGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return WSTETHGain;\n    }\n\n    /*\n    * Calculate the SHADY gain earned by a deposit since its last snapshots were taken.\n    * Given by the formula:  SHADY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorSHADYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n//        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n        * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n        * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n        * which they made their deposit.\n        */\n        uint kickbackRate = /*frontEndTag == address(0) ? */DECIMAL_PRECISION/* : frontEnds[frontEndTag].kickbackRate*/;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint SHADYGain = kickbackRate * _getSHADYGainFromSnapshots(initialDeposit, snapshots) / DECIMAL_PRECISION;\n\n        return SHADYGain;\n    }\n\n    /*\n    * Return the SHADY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    *\n    * D0 is the last recorded value of the front end's total tagged deposits.\n    */\n    /*function getFrontEndSHADYGain(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(DECIMAL_PRECISION) - kickbackRate;\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint SHADYGain = frontEndShare * _getSHADYGainFromSnapshots(frontEndStake, snapshots) / DECIMAL_PRECISION;\n        return SHADYGain;\n    }*/\n\n    function _getSHADYGainFromSnapshots(uint initialStake, Snapshots memory snapshots) internal view returns (uint) {\n       /*\n        * Grab the sum 'G' from the epoch at which the stake was made. The SHADY gain may span up to one scale change.\n        * If it does, the second portion of the SHADY gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot] - G_Snapshot;\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint SHADYGain = initialStake * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return SHADYGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedSIMDeposit(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /*\n    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken at the last time\n    * when one of the front end's tagged deposits updated their deposit.\n    *\n    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n    */\n    /*function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }*/\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale - scaleSnapshot;\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-9 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake * P / snapshot_P;\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake * P / snapshot_P / SCALE_FACTOR;\n        } else { // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake / 1e9) {return 0;}\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for SIM deposit, WSTETH gains and SHADY gains ---\n\n    // Transfer the SIM tokens from the user to the Stability Pool's address, and update its recorded SIM\n    function _sendSIMtoStabilityPool(address _address, uint _amount) internal {\n        simToken.sendToPool(_address, address(this), _amount);\n        uint newTotalSIMDeposits = totalSIMDeposits + _amount;\n        totalSIMDeposits = newTotalSIMDeposits;\n        emit StabilityPoolSIMBalanceUpdated(newTotalSIMDeposits);\n    }\n\n    function _sendWSTETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {return;}\n        uint newWSTETH = WSTETH - _amount;\n        WSTETH = newWSTETH;\n        emit StabilityPoolWSTETHBalanceUpdated(newWSTETH);\n        emit WSTETHSent(msg.sender, _amount);\n\n        require(IERC20(WSTETHAddress).transfer(msg.sender, _amount));\n    }\n\n    // Send SIM to user and decrease SIM in Pool\n    function _sendSIMToDepositor(address _depositor, uint SIMWithdrawal) internal {\n        if (SIMWithdrawal == 0) {return;}\n\n        simToken.returnFromPool(address(this), _depositor, SIMWithdrawal);\n        _decreaseSIM(SIMWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    /*function registerFrontEnd(uint _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }*/\n\n    // --- Stability Pool Deposit Functionality ---\n\n    /*function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }*/\n\n\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n//            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    /*function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }*/\n\n    function _payOutSHADYGains(IIssuance _communityIssuance, address _depositor/*, address _frontEnd*/) internal {\n        // Pay out front end's SHADY gain\n        /*if (_frontEnd != address(0)) {\n            uint frontEndSHADYGain = getFrontEndSHADYGain(_frontEnd);\n            _communityIssuance.sendSHADY(_frontEnd, frontEndSHADYGain);\n            emit SHADYPaidToFrontEnd(_frontEnd, frontEndSHADYGain);\n        }*/\n\n        // Pay out depositor's SHADY gain\n        uint depositorSHADYGain = getDepositorSHADYGain(_depositor);\n        _communityIssuance.sendSHADY(_depositor, depositorSHADYGain);\n        emit SHADYPaidToDepositor(_depositor, depositorSHADYGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require( msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(ICR >= MCR, \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\");\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(_initialDeposit > 0, 'StabilityPool: User must have a non-zero deposit');\n    }\n\n     /*function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, 'StabilityPool: User must have no deposit');\n    }*/\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'StabilityPool: Amount must be non-zero');\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(troveManager.getTroveStatus(_depositor) == 1, \"StabilityPool: caller must have an active trove to withdraw WSTETHGain to\");\n    }\n\n    function _requireUserHasWSTETHGain(address _depositor) internal view {\n        uint WSTETHGain = getDepositorWSTETHGain(_depositor);\n        require(WSTETHGain > 0, \"StabilityPool: caller must have non-zero WSTETH Gain\");\n    }\n\n    /*function _requireFrontEndNotRegistered(address _address) internal view {\n        require(!frontEnds[_address].registered, \"StabilityPool: must not already be a registered front end\");\n    }*/\n\n     /*function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\");\n    }*/\n\n    /*function  _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require (_kickbackRate <= DECIMAL_PRECISION, \"StabilityPool: Kickback rate must be in range [0,1]\");\n    }*/\n}\n"
    },
    "contracts/test/BorrowerOperationsTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../BorrowerOperations.sol\";\n\n/* Tester contract inherits from BorrowerOperations, and provides external functions \nfor testing the parent's internal functions. */\ncontract BorrowerOperationsTester is BorrowerOperations {\n\n    function getNewICRFromTroveChange\n    (\n        uint _coll, \n        uint _debt, \n        uint _collChange, \n        bool isCollIncrease, \n        uint _debtChange, \n        bool isDebtIncrease, \n        uint _price\n    ) \n    external\n    pure\n    returns (uint)\n    {\n        return _getNewICRFromTroveChange(_coll, _debt, _collChange, isCollIncrease, _debtChange, isDebtIncrease, _price);\n    }\n\n    function getNewTCRFromTroveChange\n    (\n        uint _collChange, \n        bool isCollIncrease,  \n        uint _debtChange, \n        bool isDebtIncrease, \n        uint _price\n    ) \n    external \n    view\n    returns (uint) \n    {\n        return _getNewTCRFromTroveChange(_collChange, isCollIncrease, _debtChange, isDebtIncrease, _price);\n    }\n\n    /*function getUSDValue(uint _coll, uint _price) external pure returns (uint) {\n        return _getUSDValue(_coll, _price);\n    }*/\n\n    function callInternalAdjustLoan\n    (\n        address _borrower, \n        uint _collWithdrawal, \n        uint _debtChange, \n        bool _isDebtIncrease, \n        address _upperHint,\n        address _lowerHint)\n        external \n    {\n        _adjustTrove(_borrower, _collWithdrawal, _debtChange, _isDebtIncrease, _upperHint, _lowerHint, DECIMAL_PRECISION / 1000 * 5);\n    }\n\n    function increaseSIMDebtOnActivePool(uint amount_) external {\n        activePool.increaseSIMDebt(amount_);\n    }\n\n    function decreaseSIMDebtOnActivePool(uint amount_) external {\n        activePool.decreaseSIMDebt(amount_);\n    }\n}\n"
    },
    "contracts/test/CommunityIssuanceTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../dependencies/Issuance.sol\";\n\ncontract CommunityIssuanceTester is Issuance {\n    function obtainSHADY(uint _amount) external {\n        shadyToken.transfer(msg.sender, _amount);\n    }\n\n    function getCumulativeIssuanceFraction() external view returns (uint) {\n       return _getCumulativeIssuanceFraction();\n    }\n\n    function unprotectedIssueSHADY() external returns (uint) {\n        // No checks on caller address\n       \n        uint latestTotalSHADYIssued = SHADYSupplyCap * _getCumulativeIssuanceFraction() / DECIMAL_PRECISION;\n        uint issuance = latestTotalSHADYIssued - totalSHADYIssued;\n      \n        totalSHADYIssued = latestTotalSHADYIssued;\n        return issuance;\n    }\n}\n"
    },
    "contracts/test/SHADYTokenTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../SHADYToken.sol\";\n\ncontract SHADYTokenTester is SHADYToken {\n    constructor\n    (\n        address communityIssuanceAddress_,\n        address liquidityRewardsIssuanceAddress_,\n        address lockupFactoryAddress_,\n        address spenderAddress_,\n        address multisigAddress_\n    ) SHADYToken(\n    communityIssuanceAddress_,\n    liquidityRewardsIssuanceAddress_,\n    lockupFactoryAddress_,\n    spenderAddress_,\n    multisigAddress_\n    )\n    {}\n\n    function unprotectedMint(address account, uint256 amount) external {\n        // No check for the caller here\n\n        _mint(account, amount);\n    }\n\n    function callInternalApprove(address owner, address spender, uint256 amount) external returns (bool) {\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function callInternalTransfer(address sender, address recipient, uint256 amount) external returns (bool) {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function getChainId() external view returns (uint256 chainID) {\n        //return _chainID(); // its private\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}"
    },
    "contracts/test/TroveManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n\n    function computeICR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(uint _coll) external pure returns (uint) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getSIMGasCompensation() external pure returns (uint) {\n        return 0/*SIM_GAS_COMPENSATION*/;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing() external returns (uint) {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= DECIMAL_PRECISION);\n        \n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(uint _ETHDrawn) external view returns (uint) {\n        return _getRedemptionFee(_ETHDrawn);\n    }  \n\n    function getActualDebtFromComposite(uint _debtVal) external pure returns (uint) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/test/VeTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../Ve.sol\";\nimport \"../interfaces/ISHADYToken.sol\";\n\ncontract VeTester is Ve {\n    /*function unprotectedCallSHADYSendToVe(address shady_, address sender_, uint256 amount_) external {\n        ISHADYToken(shady_).sendToVe(sender_, amount_);\n    }*/\n}"
    },
    "contracts/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IStabilityPool.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/ISIMToken.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ISHADYToken.sol\";\nimport \"./interfaces/IVeDistributor.sol\";\nimport \"./dependencies/Base.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./VeDistributor.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\ncontract TroveManager is Base, Ownable, CheckContract, ITroveManager {\n    string constant public NAME = \"TroveManager\";\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public override stabilityPool;\n\n    ICollSurplusPool public collSurplusPool;\n\n    ISIMToken public override simToken;\n\n    ISHADYToken public override shadyToken;\n\n    address public override wstETHVeDistributor;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 30 days;\n\n    /*\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n    * Corresponds to (1 / ALPHA) in the white paper.\n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new SIM issuance)\n    uint public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_WSTETH and L_SIMDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An WSTETH gain of ( stake * [L_WSTETH - L_WSTETH(0)] )\n    * A SIMDebt increase  of ( stake * [L_SIMDebt - L_SIMDebt(0)] )\n    *\n    * Where L_WSTETH(0) and L_SIMDebt(0) are snapshots of L_WSTETH and L_SIMDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_WSTETH;\n    uint public L_SIMDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the WSTETH and SIM snapshots for a given active trove\n    struct RewardSnapshot { uint WSTETH; uint SIMDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastWSTETHError_Redistribution;\n    uint public lastSIMDebtError_Redistribution;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint SIMInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingSIMInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        uint collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        uint totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        ISIMToken simToken;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint remainingSIM;\n        uint totalSIMToRedeem;\n        uint totalWSTETHDrawn;\n        uint WSTETHFee;\n        uint WSTETHToSendToRedeemer;\n        uint decayedBaseRate;\n        uint price;\n        uint totalSIMSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint SIMLot;\n        uint WSTETHLot;\n        bool cancelledPartial;\n    }\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _simTokenAddress,\n        address _sortedTrovesAddress,\n        address _shadyTokenAddress,\n        address _wstEthVeDistributor\n    )\n        external\n        override\n        onlyOwner\n    {\n        _checkContract(_borrowerOperationsAddress);\n        _checkContract(_activePoolAddress);\n        _checkContract(_defaultPoolAddress);\n        _checkContract(_stabilityPoolAddress);\n        _checkContract(_collSurplusPoolAddress);\n        _checkContract(_priceFeedAddress);\n        _checkContract(_simTokenAddress);\n        _checkContract(_sortedTrovesAddress);\n        _checkContract(_shadyTokenAddress);\n        _checkContract(_wstEthVeDistributor);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        simToken = ISIMToken(_simTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        shadyToken = ISHADYToken(_shadyTokenAddress);\n        wstETHVeDistributor = _wstEthVeDistributor;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SIMTokenAddressChanged(_simTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit SHADYTokenAddressChanged(_shadyTokenAddress);\n        emit WSTETHVeDistibutorAddressChanged(_wstEthVeDistributor);\n\n        renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _SIMInStabPool\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        uint collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        (singleLiquidation.debtToOffset,\n        singleLiquidation.collToSendToSP,\n        singleLiquidation.debtToRedistribute,\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _SIMInStabPool);\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInNormalMode));\n        emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInNormalMode));\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _ICR,\n        uint _SIMInStabPool,\n        uint _TCR,\n        uint _price\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        vars.collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            (singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _SIMInStabPool);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n        /*\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is SIM in the Stability Pool, only offset, with no redistribution,\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n        * The remainder due to the capped rate will be claimable as collateral surplus.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _SIMInStabPool)) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            assert(_SIMInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\n            }\n\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _SIMInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _SIMInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_SIMInStabPool > 0) {\n        /*\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited SIM in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the SIM in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _SIMInStabPool);\n            collToSendToSP = _coll * debtToOffset / _debt;\n            debtToRedistribute = _debt - debtToOffset;\n            collToRedistribute = _coll - collToSendToSP;\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  Get its offset coll/debt and WSTETH gas comp, and close the trove.\n    */\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _price\n    )\n        internal\n        pure\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint cappedCollPortion = _entireTroveDebt * MCR / _price;\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\n        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            ISIMToken(address(0)),\n//            IVe(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0))/*,\n            address(0)*/\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.SIMInStabPool, _n);\n        } else { // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.SIMInStabPool, _n);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated WSTETH and SIM to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(contractsCache.activePool, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        ContractsCache memory _contractsCache,\n        uint _price,\n        uint _SIMInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingSIMInStabPool);\n\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\n        } else {  //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated WSTETH and SIM to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) { continue; }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\n    internal pure returns(LiquidationTotals memory newTotals) {\n\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\n//        newTotals.totalSIMGasCompensation = oldTotals.totalSIMGasCompensation + singleLiquidation.SIMGasCompensation;\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence + singleLiquidation.entireTroveColl;\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, /*uint _SIM,*/ uint _WSTETH) internal {\n        /*if (_SIM > 0) {\n            simToken.returnFromPool(gasPoolAddress, _liquidator, _SIM);\n        }*/\n\n        if (_WSTETH > 0) {\n            _activePool.sendWSTETH(_liquidator, _WSTETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _SIM, uint _WSTETH) internal {\n        _defaultPool.decreaseSIMDebt(_SIM);\n        _activePool.increaseSIMDebt(_SIM);\n        _defaultPool.sendWSTETHToActivePool(_WSTETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for SIM up to _maxSIMamount\n    function _redeemCollateralFromTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint _maxSIMamount,\n        uint _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR\n    )\n        internal returns (SingleRedemptionValues memory singleRedemption)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.SIMLot = LiquityMath._min(_maxSIMamount, Troves[_borrower].debt);\n\n        // Get the WSTETHLot of equivalent value in USD\n        singleRedemption.WSTETHLot = singleRedemption.SIMLot * DECIMAL_PRECISION / _price;\n\n        // Decrease the debt and collateral of the current Trove according to the SIM lot and corresponding WSTETH to send\n        uint newDebt = (Troves[_borrower].debt) - singleRedemption.SIMLot;\n        uint newColl = (Troves[_borrower].coll) - singleRedemption.WSTETHLot;\n\n        if (newDebt == 0) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(_contractsCache, _borrower, newColl);\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.redeemCollateral));\n        } else {\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n\n            /*\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n            * certainly result in running out of gas.\n            *\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n            */\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                newDebt, newColl,\n                Troves[_borrower].stake,\n                uint8(TroveManagerOperation.redeemCollateral)\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n    * Called when a full redemption occurs, and closes the trove.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus WSTETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint _WSTETH) internal {\n        // send WSTETH from Active Pool to CollSurplus Pool\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _WSTETH);\n        _contractsCache.activePool.sendWSTETH(address(_contractsCache.collSurplusPool), _WSTETH);\n    }\n\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _SIMamount SIM to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining SIM amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _SIMamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    )\n        external\n        override\n    {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            simToken,\n            sortedTroves,\n            collSurplusPool\n        );\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice();\n        _requireTCRoverMCR(totals.price);\n        _requireAmountGreaterThanZero(_SIMamount);\n        _requireSIMBalanceCoversRedemption(contractsCache.simToken, msg.sender, _SIMamount);\n\n        totals.totalSIMSupplyAtStart = getEntireSystemDebt();\n        // Confirm redeemer's balance is less than total SIM supply\n        assert(contractsCache.simToken.balanceOf(msg.sender) <= totals.totalSIMSupplyAtStart);\n\n        totals.remainingSIM = _SIMamount;\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = contractsCache.sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of SIM is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = type(uint).max; }\n        while (currentBorrower != address(0) && totals.remainingSIM > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\n\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\n                contractsCache,\n                currentBorrower,\n                totals.remainingSIM,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalSIMToRedeem  = totals.totalSIMToRedeem + singleRedemption.SIMLot;\n            totals.totalWSTETHDrawn = totals.totalWSTETHDrawn + singleRedemption.WSTETHLot;\n\n            totals.remainingSIM = totals.remainingSIM - singleRedemption.SIMLot;\n            currentBorrower = nextUserToCheck;\n        }\n        require(totals.totalWSTETHDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total SIM supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(totals.totalWSTETHDrawn, totals.price, totals.totalSIMSupplyAtStart);\n\n        // Calculate the WSTETH fee\n        totals.WSTETHFee = _getRedemptionFee(totals.totalWSTETHDrawn);\n\n        _requireUserAcceptsFee(totals.WSTETHFee, totals.totalWSTETHDrawn, _maxFeePercentage);\n\n        // Send the WSTETH fee to the VeDistributor contract\n        contractsCache.activePool.sendWSTETH(wstETHVeDistributor, totals.WSTETHFee);\n        IVeDistributor(wstETHVeDistributor).checkpoint();\n\n        totals.WSTETHToSendToRedeemer = totals.totalWSTETHDrawn - totals.WSTETHFee;\n\n        emit Redemption(_SIMamount, totals.totalSIMToRedeem, totals.totalWSTETHDrawn, totals.WSTETHFee);\n\n        // Burn the total SIM that is cancelled with debt, and send the redeemed WSTETH to msg.sender\n        contractsCache.simToken.burn(msg.sender, totals.totalSIMToRedeem);\n        // Update Active Pool SIM, and send WSTETH to account\n        contractsCache.activePool.decreaseSIMDebt(totals.totalSIMToRedeem);\n        contractsCache.activePool.sendWSTETH(msg.sender, totals.WSTETHToSendToRedeemer);\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(address _borrower) public view override returns (uint) {\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\n\n        uint NICR = LiquityMath._computeNominalCR(currentWSTETH, currentSIMDebt);\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\n\n        uint ICR = LiquityMath._computeCR(currentWSTETH, currentSIMDebt, _price);\n        return ICR;\n    }\n\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\n        uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n        uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n\n        uint currentWSTETH = Troves[_borrower].coll + pendingWSTETHReward;\n        uint currentSIMDebt = Troves[_borrower].debt + pendingSIMDebtReward;\n\n        return (currentWSTETH, currentSIMDebt);\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n            uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll + pendingWSTETHReward;\n            Troves[_borrower].debt = Troves[_borrower].debt + pendingSIMDebtReward;\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingSIMDebtReward, pendingWSTETHReward);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].coll,\n                Troves[_borrower].stake,\n                uint8(TroveManagerOperation.applyPendingRewards)\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_WSTETH and L_SIMDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].WSTETH = L_WSTETH;\n        rewardSnapshots[_borrower].SIMDebt = L_SIMDebt;\n        emit TroveSnapshotsUpdated(L_WSTETH, L_SIMDebt);\n    }\n\n    // Get the borrower's pending accumulated WSTETH reward, earned by their stake\n    function getPendingWSTETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotWSTETH = rewardSnapshots[_borrower].WSTETH;\n        uint rewardPerUnitStaked = L_WSTETH - snapshotWSTETH;\n\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingWSTETHReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\n\n        return pendingWSTETHReward;\n    }\n\n    // Get the borrower's pending accumulated SIM reward, earned by their stake\n    function getPendingSIMDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotSIMDebt = rewardSnapshots[_borrower].SIMDebt;\n        uint rewardPerUnitStaked = L_SIMDebt - snapshotSIMDebt;\n\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingSIMDebtReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\n\n        return pendingSIMDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /*\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        */\n        if (Troves[_borrower].status != Status.active) {return false;}\n\n        return (rewardSnapshots[_borrower].WSTETH < L_WSTETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingSIMDebtReward, uint pendingWSTETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n        pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n\n        debt = debt + pendingSIMDebtReward;\n        coll = coll + pendingWSTETHReward;\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes - stake;\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n        emit TotalStakesUpdated(totalStakes);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_WSTETH and L_SIMDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint WSTETHNumerator = _coll * DECIMAL_PRECISION + lastWSTETHError_Redistribution;\n        uint SIMDebtNumerator = _debt * DECIMAL_PRECISION + lastSIMDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint WSTETHRewardPerUnitStaked = WSTETHNumerator / totalStakes;\n        uint SIMDebtRewardPerUnitStaked = SIMDebtNumerator / totalStakes;\n\n        lastWSTETHError_Redistribution = WSTETHNumerator - WSTETHRewardPerUnitStaked * totalStakes;\n        lastSIMDebtError_Redistribution = SIMDebtNumerator - SIMDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_WSTETH = L_WSTETH + WSTETHRewardPerUnitStaked;\n        L_SIMDebt = L_SIMDebt + SIMDebtRewardPerUnitStaked;\n\n        emit LTermsUpdated(L_WSTETH, L_SIMDebt);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseSIMDebt(_debt);\n        _defaultPool.increaseSIMDebt(_debt);\n        _activePool.sendWSTETH(address(_defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].WSTETH = 0;\n        rewardSnapshots[_borrower].SIMDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    *\n    * the total WSTETH gas compensation from the liquidation sequence\n    *\n    * The WSTETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = _activePool.getWSTETH();\n        uint liquidatedColl = defaultPool.getWSTETH();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum SIM\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 SIM dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length - 1);\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // Its set in caller function `_closeTrove`\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length - 1;\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR(uint _price) external view override returns (uint) {\n        return _getTCR(_price);\n    }\n\n    function checkRecoveryMode(uint _price) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an WSTETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or SIM borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _WSTETHDrawn,  uint _price, uint _totalSIMSupply) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn WSTETH back to SIM at face value rate (1 SIM:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedSIMFraction = _WSTETHDrawn * _price / _totalSIMSupply;\n\n        uint newBaseRate = decayedBaseRate + redeemedSIMFraction / BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _WSTETHDrawn) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _WSTETHDrawn);\n    }\n\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _WSTETHDrawn);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _WSTETHDrawn) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate * _WSTETHDrawn / DECIMAL_PRECISION;\n        require(redemptionFee < _WSTETHDrawn, \"TroveManager: Fee would eat up all returned collateral\");\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR + _baseRate,\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _SIMDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _SIMDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _SIMDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _SIMDebt) internal pure returns (uint) {\n        return _borrowingRate * _SIMDebt / DECIMAL_PRECISION;\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or SIM borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp - lastFeeOperationTime;\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp - lastFeeOperationTime) / SECONDS_IN_ONE_MINUTE;\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireSIMBalanceCoversRedemption(ISIMToken _simToken, address _redeemer, uint _amount) internal view {\n        require(_simToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's SIM token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    function _requireTCRoverMCR(uint _price) internal view {\n        require(_getTCR(_price) >= MCR, \"TroveManager: Cannot redeem when TCR < MCR\");\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = shadyToken.getDeploymentStartTime();\n        require(block.timestamp >= systemDeploymentTime + BOOTSTRAP_PERIOD, \"TroveManager: Redemptions are not allowed during bootstrap phase\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal pure {\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll + _collIncrease;\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll - _collDecrease;\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt + _debtIncrease;\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt - _debtDecrease;\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "contracts/Ve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IVe.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/FixedPointMathLib.sol\";\nimport \"./dependencies/ControllableV3.sol\";\nimport \"./dependencies/VeLogo.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Ve is ControllableV3, ReentrancyGuardUpgradeable, CheckContract, IERC721, IERC721Metadata, IVe {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint;\n    using FixedPointMathLib for int128;\n\n    // Only for internal usage\n    struct DepositInfo {\n        address stakingToken;\n        uint tokenId;\n        uint value;\n        uint unlockTime;\n        uint lockedAmount;\n        uint lockedDerivedAmount;\n        uint lockedEnd;\n        DepositType depositType;\n    }\n\n    // Only for internal usage\n    struct CheckpointInfo {\n        uint tokenId;\n        uint oldDerivedAmount;\n        uint newDerivedAmount;\n        uint oldEnd;\n        uint newEnd;\n    }\n\n    enum TimeLockType {\n        UNKNOWN,\n        ADD_TOKEN,\n        WHITELIST_TRANSFER\n    }\n\n    /// @dev Version of this contract. Adjust manually on each code modification.\n    string public constant VE_VERSION = \"1.0.0\";\n    uint internal constant WEEK = 1 weeks;\n    uint internal constant MAX_TIME = 16 weeks;\n    int128 internal constant I_MAX_TIME = 16 weeks;\n    uint internal constant MULTIPLIER = 1 ether;\n    uint internal constant WEIGHT_DENOMINATOR = 100e18;\n    uint public constant MAX_ATTACHMENTS = 1;\n    uint public constant GOV_ACTION_TIME_LOCK = 18 hours;\n    string constant public override name = \"xSHADY\";\n    string constant public override symbol = \"xSHADY\";\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant _ERC721_INTERFACE_ID = 0x80ac58cd;\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    // *************************************************************\n    //                        VARIABLES\n    //                Keep names and ordering!\n    //                 Add only in the bottom.\n    // *************************************************************\n    address public troveManagerAddress;\n    address public borrowerOperationsAddress;\n    address public shadyAddress;\n\n    /// @dev Underlying tokens info\n    address[] public override tokens;\n    /// @dev token => weight\n    mapping(address => uint) public tokenWeights;\n    /// @dev token => is allowed for deposits\n    mapping(address => bool) public isValidToken;\n    /// @dev Current count of token\n    uint public tokenId;\n    /// @dev veId => stakingToken => Locked amount\n    mapping(uint => mapping(address => uint)) public override lockedAmounts;\n    /// @dev veId => Amount based on weights aka power\n    mapping(uint => uint) public override lockedDerivedAmount;\n    /// @dev veId => Lock end timestamp\n    mapping(uint => uint) public override lockedEnd;\n\n    // --- CHECKPOINTS LOGIC\n\n    /// @dev Epoch counter. Update each week.\n    uint public override epoch;\n    /// @dev epoch -> unsigned point\n    mapping(uint => Point) internal _pointHistory;\n    /// @dev user -> Point[userEpoch]\n    mapping(uint => Point[1000000000]) internal _userPointHistory;\n    /// @dev veId -> Personal epoch counter\n    mapping(uint => uint) public override userPointEpoch;\n    /// @dev time -> signed slope change\n    mapping(uint => int128) public slopeChanges;\n\n    // --- LOCK\n\n    /// @dev veId -> votes counter. With votes NFT unable to transfer\n    /// deprecated\n    mapping(uint => uint) public _deprecated_voted;\n\n    // --- STATISTICS\n\n    /// @dev veId -> Block number when last time NFT owner changed\n    mapping(uint => uint) public ownershipChange;\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal _idToOwner;\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal _idToApprovals;\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal _ownerToNFTokenCount;\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal _ownerToNFTokenIdList;\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) public tokenToOwnerIndex;\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) public ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal _supportedInterfaces;\n\n    // --- PERMISSIONS\n\n    /// @dev Whitelisted contracts will be able to transfer NFTs\n    mapping(address => bool) public isWhitelistedTransfer;\n    /// @dev Time-locks for governance actions. Zero means not announced and should not processed.\n    mapping(TimeLockType => uint) public govActionTimeLock;\n    /// @dev underlying token => true if we can stake token to some place, false if paused\n    mapping(address => bool) internal tokenFarmingStatus;\n\n    // *************************************************************\n    //                        EVENTS\n    // *************************************************************\n\n    event Deposit(\n        address indexed stakingToken,\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType depositType,\n        uint ts\n    );\n    event Withdraw(address indexed stakingToken, address indexed provider, uint tokenId, uint value, uint ts);\n    event Merged(address indexed stakingToken, address indexed provider, uint from, uint to);\n    event Split(uint parentTokenId, uint newTokenId, uint percent);\n    event TransferWhitelisted(address value);\n    event StakingTokenAdded(address value, uint weight);\n    event GovActionAnnounced(uint _type, uint timeToExecute);\n\n    // *************************************************************\n    //                        INIT\n    // *************************************************************\n\n\n    function setAddresses(\n        address troveManagerAddress_,\n        address borrowerOperationsAddress_,\n        address shadyAddress_,\n        address controller_\n    ) external initializer {\n        // the first token should have 18 decimals\n        require(IERC20Metadata(shadyAddress_).decimals() == uint8(18));\n\n        _checkContract(troveManagerAddress_);\n        _checkContract(borrowerOperationsAddress_);\n        _checkContract(shadyAddress_);\n\n        __Controllable_init(controller_);\n        __ReentrancyGuard_init();\n\n        troveManagerAddress = troveManagerAddress_;\n        borrowerOperationsAddress = borrowerOperationsAddress_;\n        shadyAddress = shadyAddress_;\n\n        _pointHistory[0].blk = block.number;\n        _pointHistory[0].ts = block.timestamp;\n        _addToken(shadyAddress_, 100e18);\n\n        _supportedInterfaces[_ERC165_INTERFACE_ID] = true;\n        _supportedInterfaces[_ERC721_INTERFACE_ID] = true;\n        _supportedInterfaces[_ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), 0);\n        // burn-ish\n        emit Transfer(address(this), address(0), 0);\n    }\n\n    // *************************************************************\n    //                        GOVERNANCE ACTIONS\n    // *************************************************************\n\n    function announceAction(TimeLockType _type) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        require(govActionTimeLock[_type] == 0 && _type != TimeLockType.UNKNOWN, \"WRONG_INPUT\");\n\n        govActionTimeLock[_type] = block.timestamp + GOV_ACTION_TIME_LOCK;\n        emit GovActionAnnounced(uint(_type), block.timestamp + GOV_ACTION_TIME_LOCK);\n    }\n\n    /// @dev Whitelist address for transfers. Removing from whitelist should be forbidden.\n    function whitelistTransferFor(address value) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        require(value != address(0), \"WRONG_INPUT\");\n        uint timeLock = govActionTimeLock[TimeLockType.WHITELIST_TRANSFER];\n        require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n        isWhitelistedTransfer[value] = true;\n        govActionTimeLock[TimeLockType.WHITELIST_TRANSFER] = 0;\n\n        emit TransferWhitelisted(value);\n    }\n\n    function addToken(address token, uint weight) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        uint timeLock = govActionTimeLock[TimeLockType.ADD_TOKEN];\n        require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n        _addToken(token, weight);\n        govActionTimeLock[TimeLockType.ADD_TOKEN] = 0;\n    }\n\n    function _addToken(address token, uint weight) internal {\n        require(token != address(0) && weight != 0, \"WRONG_INPUT\");\n        _requireERC20(token);\n\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            require(token != tokens[i], \"WRONG_INPUT\");\n        }\n\n        tokens.push(token);\n        tokenWeights[token] = weight;\n        isValidToken[token] = true;\n\n        emit StakingTokenAdded(token, weight);\n    }\n\n    // *************************************************************\n    //                        VIEWS\n    // *************************************************************\n\n    /// @dev Return length of staking tokens.\n    function tokensLength() external view returns (uint) {\n        return tokens.length;\n    }\n\n    /// @dev Current block timestamp\n    function blockTimestamp() external view returns (uint) {\n        return block.timestamp;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) public view override(ControllableV3, IERC165) returns (bool) {\n        return _supportedInterfaces[_interfaceID]\n        || _interfaceID == InterfaceIds.I_VE\n            || super.supportsInterface(_interfaceID);\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function getLastUserSlope(uint _tokenId) external view returns (int128) {\n        uint uEpoch = userPointEpoch[_tokenId];\n        return _userPointHistory[_tokenId][uEpoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function userPointHistoryTs(uint _tokenId, uint _idx) external view returns (uint) {\n        return _userPointHistory[_tokenId][_idx].ts;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return _ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view override returns (uint) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view override returns (address) {\n        return _idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId) external view override returns (address) {\n        return _idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n        return _ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID,\n    ///              is an operator of the owner, or is the owner of the token\n    function isApprovedOrOwner(address _spender, uint _tokenId) public view override returns (bool) {\n        address owner = _idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == _idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function balanceOfNFT(uint _tokenId) public view override returns (uint) {\n        // flash NFT protection\n        if (ownershipChange[_tokenId] == block.number) {\n            return 0;\n        }\n        return _balanceOfNFT(_tokenId, block.timestamp);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return _balanceOfNFT(_tokenId, _t);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return _balanceOfAtNFT(_tokenId, _block);\n    }\n\n    function userPointHistory(uint _tokenId, uint _loc) external view override returns (Point memory) {\n        return _userPointHistory[_tokenId][_loc];\n    }\n\n    function pointHistory(uint _loc) external view override returns (Point memory) {\n        return _pointHistory[_loc];\n    }\n\n    // *************************************************************\n    //                        NFT LOGIC\n    // *************************************************************\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint currentCount = _balance(_to);\n\n        _ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint currentCount = _balance(_from) - 1;\n        uint currentIndex = tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = _ownerToNFTokenIdList[_from][currentCount];\n\n            // Add\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // assume always call on new tokenId or after _removeTokenFrom() call\n        // Change the owner\n        _idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        _ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        require(_idToOwner[_tokenId] == _from, \"NOT_OWNER\");\n        // Change the owner\n        _idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        _ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Execute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal {\n        require(isApprovedOrOwner(_sender, _tokenId), \"NOT_OWNER\");\n        require(_to != address(0), \"WRONG_INPUT\");\n        // from address will be checked in _removeTokenFrom()\n\n        if (_idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            _idToApprovals[_tokenId] = address(0);\n        }\n        _removeTokenFrom(_from, _tokenId);\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownershipChange[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev Transfers forbidden for veTETU\n    function transferFrom(\n        address,\n        address,\n        uint\n    ) external pure override {\n        revert(\"FORBIDDEN\");\n        //    _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public override {\n        require(isWhitelistedTransfer[_to] || isWhitelistedTransfer[_from], \"FORBIDDEN\");\n\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n        require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /// @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n    /// The call is not executed if the target address is not a contract.\n    ///\n    /// @param _from address representing the previous owner of the given token ID\n    /// @param _to target address that will receive the tokens\n    /// @param _tokenId uint256 ID of the token to be transferred\n    /// @param _data bytes optional data to send along with the call\n    /// @return bool whether the call correctly returned the expected magic value\n    ///\n    function _checkOnERC721Received(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (_isContract(_to)) {\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external override {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) public override {\n        address owner = _idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0), \"WRONG_INPUT\");\n        // Throws if `_approved` is the current owner\n        require(_approved != owner, \"IDENTICAL_ADDRESS\");\n        // Check requirements\n        bool senderIsOwner = (owner == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll, \"NOT_OWNER\");\n        // Set the approval\n        _idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved) external override {\n        // Throws if `_operator` is the `msg.sender`\n        require(_operator != msg.sender, \"IDENTICAL_ADDRESS\");\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        require(_to != address(0), \"WRONG_INPUT\");\n        _addTokenTo(_to, _tokenId);\n        require(_checkOnERC721Received(address(0), _to, _tokenId, ''), \"ERC721: transfer to non ERC721Receiver implementer\");\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    function _checkpoint(CheckpointInfo memory info) internal {\n        Point memory uOld;\n        Point memory uNew;\n        int128 oldDSlope = 0;\n        int128 newDSlope = 0;\n        uint _epoch = epoch;\n\n        if (info.tokenId != 0) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (info.oldEnd > block.timestamp && info.oldDerivedAmount > 0) {\n                uOld.slope = int128(uint128(info.oldDerivedAmount)) / I_MAX_TIME;\n                uOld.bias = uOld.slope * int128(int256(info.oldEnd - block.timestamp));\n            }\n            if (info.newEnd > block.timestamp && info.newDerivedAmount > 0) {\n                uNew.slope = int128(uint128(info.newDerivedAmount)) / I_MAX_TIME;\n                uNew.bias = uNew.slope * int128(int256(info.newEnd - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDSlope = slopeChanges[info.oldEnd];\n            if (info.newEnd != 0) {\n                if (info.newEnd == info.oldEnd) {\n                    newDSlope = oldDSlope;\n                } else {\n                    newDSlope = slopeChanges[info.newEnd];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n        if (_epoch > 0) {\n            lastPoint = _pointHistory[_epoch];\n        }\n        uint lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint = lastPoint;\n        uint blockSlope = 0;\n        // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint ti = (lastCheckpoint / WEEK) * WEEK;\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            for (uint i = 0; i < 255; ++i) {\n                ti += WEEK;\n                int128 dSlope = 0;\n                if (ti > block.timestamp) {\n                    ti = block.timestamp;\n                } else {\n                    dSlope = slopeChanges[ti];\n                }\n                lastPoint.bias = (lastPoint.bias - lastPoint.slope * int128(int256(ti - lastCheckpoint))).positiveInt128();\n                lastPoint.slope = (lastPoint.slope + dSlope).positiveInt128();\n                lastCheckpoint = ti;\n                lastPoint.ts = ti;\n                lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (ti == block.timestamp) {\n                    lastPoint.blk = block.number;\n                    break;\n                } else {\n                    _pointHistory[_epoch] = lastPoint;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now pointHistory is filled until t=now\n\n        if (info.tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope = (lastPoint.slope + (uNew.slope - uOld.slope)).positiveInt128();\n            lastPoint.bias = (lastPoint.bias + (uNew.bias - uOld.bias)).positiveInt128();\n        }\n\n        // Record the changed point into history\n        _pointHistory[_epoch] = lastPoint;\n\n        if (info.tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract newUserSlope from [newLocked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (info.oldEnd > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                oldDSlope += uOld.slope;\n                if (info.newEnd == info.oldEnd) {\n                    oldDSlope -= uNew.slope;\n                    // It was a new deposit, not extension\n                }\n                slopeChanges[info.oldEnd] = oldDSlope;\n            }\n\n            if (info.newEnd > block.timestamp) {\n                if (info.newEnd > info.oldEnd) {\n                    newDSlope -= uNew.slope;\n                    // old slope disappeared at this point\n                    slopeChanges[info.newEnd] = newDSlope;\n                }\n                // else: we recorded it already in oldDSlope\n            }\n            // Now handle user history\n            uint userEpoch = userPointEpoch[info.tokenId] + 1;\n\n            userPointEpoch[info.tokenId] = userEpoch;\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            _userPointHistory[info.tokenId][userEpoch] = uNew;\n        }\n    }\n\n    // *************************************************************\n    //                  DEPOSIT/WITHDRAW LOGIC\n    // *************************************************************\n\n    /// @dev Pull tokens to this contract and try to stake\n    function _pullStakingToken(address _token, address _from, uint amount) internal {\n        IERC20(_token).safeTransferFrom(_from, address(this), amount);\n\n        // try to stake tokens if possible\n//        _stakeAvailableTokens(_token);\n    }\n\n    /// @dev Anyone can stake whitelisted tokens if they exist on this contract.\n    /*function stakeAvailableTokens(address _token) external {\n        _stakeAvailableTokens(_token);\n    }*/\n\n    /// @dev If allowed, stake given token available balance to suitable place for earn some profit\n    /*function _stakeAvailableTokens(address _token) internal {\n        if (tokenFarmingStatus[_token]) {\n            if (_token == _TETU_USDC_BPT) {\n                uint balance = IERC20(_token).balanceOf(address(this));\n                if (balance != 0) {\n                    IERC20(_token).safeApprove(_TETU_USDC_BPT_VAULT, balance);\n                    ISmartVault(_TETU_USDC_BPT_VAULT).depositAndInvest(balance);\n                }\n            }\n        }\n    }*/\n\n    /// @dev Unstake necessary amount, if possible\n    /*function _unstakeTokens(address _token, uint amount) internal {\n        uint tokenBalance = IERC20(_token).balanceOf(address(this));\n        if (amount != 0 && amount > tokenBalance) {\n            // withdraw only required amount\n            amount -= tokenBalance;\n            // no need to check whitelisting for withdraw\n            if (_token == _TETU_USDC_BPT) {\n                // add gap value for avoid rounding issues\n                uint shares = amount * 1e18 / ISmartVault(_TETU_USDC_BPT_VAULT).getPricePerFullShare() + 1e18;\n                uint sharesBalance = IERC20(_TETU_USDC_BPT_VAULT).balanceOf(address(this));\n                shares = shares > sharesBalance ? sharesBalance : shares;\n                ISmartVault(_TETU_USDC_BPT_VAULT).withdraw(shares);\n            }\n        }\n    }*/\n\n    /// @dev Anyone can withdraw all staked tokens if farming status = false\n    /*function emergencyWithdrawStakedTokens(address _token) external {\n        if (!tokenFarmingStatus[_token]) {\n            if (_token == _TETU_USDC_BPT) {\n                ISmartVault(_TETU_USDC_BPT_VAULT).exit();\n            }\n        }\n    }*/\n\n    /// @dev Transfer underlying token to recipient, unstake if need required amount\n    function _transferUnderlyingToken(address _token, address recipient, uint amount) internal {\n//        _unstakeTokens(_token, amount);\n        IERC20(_token).safeTransfer(recipient, amount);\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    function _depositFor(DepositInfo memory info) internal {\n\n        uint newLockedDerivedAmount = info.lockedDerivedAmount;\n        if (info.value != 0) {\n\n            // calculate new amounts\n            uint newAmount = info.lockedAmount + info.value;\n            newLockedDerivedAmount = _calculateDerivedAmount(\n                info.lockedAmount,\n                info.lockedDerivedAmount,\n                newAmount,\n                tokenWeights[info.stakingToken],\n                IERC20Metadata(info.stakingToken).decimals()\n            );\n            // update chain info\n            lockedAmounts[info.tokenId][info.stakingToken] = newAmount;\n            lockedDerivedAmount[info.tokenId] = newLockedDerivedAmount;\n        }\n\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        uint newLockedEnd = info.lockedEnd;\n        if (info.unlockTime != 0) {\n            lockedEnd[info.tokenId] = info.unlockTime;\n            newLockedEnd = info.unlockTime;\n        }\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            info.tokenId,\n            info.lockedDerivedAmount,\n            newLockedDerivedAmount,\n            info.lockedEnd,\n            newLockedEnd\n        ));\n\n        // move tokens to this contract, if necessary\n        address from = msg.sender;\n        if (info.value != 0 && info.depositType != DepositType.MERGE_TYPE) {\n            _pullStakingToken(info.stakingToken, from, info.value);\n        }\n\n        emit Deposit(info.stakingToken, from, info.tokenId, info.value, newLockedEnd, info.depositType, block.timestamp);\n    }\n\n    function _calculateDerivedAmount(\n        uint currentAmount,\n        uint oldDerivedAmount,\n        uint newAmount,\n        uint weight,\n        uint8 decimals\n    ) internal pure returns (uint) {\n        // subtract current derived balance\n        // rounded to UP for subtracting closer to 0 value\n        if (oldDerivedAmount != 0 && currentAmount != 0) {\n            currentAmount = currentAmount.divWadUp(10 ** decimals);\n            uint currentDerivedAmount = currentAmount.mulDivUp(weight, WEIGHT_DENOMINATOR);\n            if (oldDerivedAmount > currentDerivedAmount) {\n                oldDerivedAmount -= currentDerivedAmount;\n            } else {\n                // in case of wrong rounding better to set to zero than revert\n                oldDerivedAmount = 0;\n            }\n        }\n\n        // recalculate derived amount with new amount\n        // rounded to DOWN\n        // normalize decimals to 18\n        newAmount = newAmount.divWadDown(10 ** decimals);\n        // calculate the final amount based on the weight\n        newAmount = newAmount.mulDivDown(weight, WEIGHT_DENOMINATOR);\n        return oldDerivedAmount + newAmount;\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external override {\n        _checkpoint(CheckpointInfo(0, 0, 0, 0, 0));\n    }\n\n    function _lockInfo(address stakingToken, uint veId) internal view returns (\n        uint _lockedAmount,\n        uint _lockedDerivedAmount,\n        uint _lockedEnd\n    ) {\n        _lockedAmount = lockedAmounts[veId][stakingToken];\n        _lockedDerivedAmount = lockedDerivedAmount[veId];\n        _lockedEnd = lockedEnd[veId];\n    }\n\n    function _incrementTokenIdAndGet() internal returns (uint){\n        uint current = tokenId;\n        tokenId = current + 1;\n        return current + 1;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _createLock(address _token, uint _value, uint _lockDuration, address _to) internal returns (uint) {\n        require(_value > 0, \"WRONG_INPUT\");\n        // Lock time is rounded down to weeks\n        uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n        require(unlockTime > block.timestamp, \"LOW_LOCK_PERIOD\");\n        require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n        require(isValidToken[_token], \"INVALID_TOKEN\");\n\n        uint _tokenId = _incrementTokenIdAndGet();\n        _mint(_to, _tokenId);\n\n        _depositFor(DepositInfo({\n            stakingToken: _token,\n            tokenId: _tokenId,\n            value: _value,\n            unlockTime: unlockTime,\n            lockedAmount: 0,\n            lockedDerivedAmount: 0,\n            lockedEnd: 0,\n            depositType: DepositType.CREATE_LOCK_TYPE\n        }));\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function createLockFor(address _token, uint _value, uint _lockDuration, address _to)\n    external nonReentrant override returns (uint) {\n        return _createLock(_token, _value, _lockDuration, _to);\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    function createLock(address _token, uint _value, uint _lockDuration) external nonReentrant returns (uint) {\n        return _createLock(_token, _value, _lockDuration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _tokenId ve token ID\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increaseAmount(address _token, uint _tokenId, uint _value) external nonReentrant override {\n        require(_value > 0, \"WRONG_INPUT\");\n        (uint _lockedAmount, uint _lockedDerivedAmount, uint _lockedEnd) = _lockInfo(_token, _tokenId);\n\n        require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n        require(isValidToken[_token], \"INVALID_TOKEN\");\n\n        _depositFor(DepositInfo({\n            stakingToken: _token,\n            tokenId: _tokenId,\n            value: _value,\n            unlockTime: 0,\n            lockedAmount: _lockedAmount,\n            lockedDerivedAmount: _lockedDerivedAmount,\n            lockedEnd: _lockedEnd,\n            depositType: DepositType.INCREASE_LOCK_AMOUNT\n        }));\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _tokenId ve token ID\n    /// @param _lockDuration New number of seconds until tokens unlock\n    function increaseUnlockTime(uint _tokenId, uint _lockDuration) external nonReentrant returns (\n        uint power,\n        uint unlockDate\n    )  {\n        uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n        uint _lockedEnd = lockedEnd[_tokenId];\n        // Lock time is rounded down to weeks\n        uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n        require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n        require(unlockTime > _lockedEnd, \"LOW_UNLOCK_TIME\");\n        require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n        require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n\n        _depositFor(DepositInfo({\n            stakingToken: address(0),\n            tokenId: _tokenId,\n            value: 0,\n            unlockTime: unlockTime,\n            lockedAmount: 0,\n            lockedDerivedAmount: _lockedDerivedAmount,\n            lockedEnd: _lockedEnd,\n            depositType: DepositType.INCREASE_UNLOCK_TIME\n        }));\n\n        power = balanceOfNFT(_tokenId);\n        unlockDate = lockedEnd[_tokenId];\n    }\n\n    /// @dev Merge two NFTs union their balances and keep the biggest lock time.\n    function merge(uint _from, uint _to) external nonReentrant {\n//        require(attachments[_from] == 0 && !isVoted(_from), \"ATTACHED\");\n        require(_from != _to, \"IDENTICAL_ADDRESS\");\n        require(_idToOwner[_from] == msg.sender && _idToOwner[_to] == msg.sender, \"NOT_OWNER\");\n\n        uint lockedEndFrom = lockedEnd[_from];\n        uint lockedEndTo = lockedEnd[_to];\n        require(lockedEndFrom > block.timestamp && lockedEndTo > block.timestamp, \"EXPIRED\");\n        uint end = lockedEndFrom >= lockedEndTo ? lockedEndFrom : lockedEndTo;\n        uint oldDerivedAmount = lockedDerivedAmount[_from];\n\n        uint length = tokens.length;\n        // we should use the old one for properly calculate checkpoint for the new ve\n        uint newLockedEndTo = lockedEndTo;\n        for (uint i; i < length; i++) {\n            address stakingToken = tokens[i];\n            uint _lockedAmountFrom = lockedAmounts[_from][stakingToken];\n            if (_lockedAmountFrom == 0) {\n                continue;\n            }\n            lockedAmounts[_from][stakingToken] = 0;\n\n            _depositFor(DepositInfo({\n                stakingToken: stakingToken,\n                tokenId: _to,\n                value: _lockedAmountFrom,\n                unlockTime: end,\n                lockedAmount: lockedAmounts[_to][stakingToken],\n                lockedDerivedAmount: lockedDerivedAmount[_to],\n                lockedEnd: newLockedEndTo,\n                depositType: DepositType.MERGE_TYPE\n            }));\n\n            // set new lock time to the current end lock\n            newLockedEndTo = end;\n\n            emit Merged(stakingToken, msg.sender, _from, _to);\n        }\n\n        lockedDerivedAmount[_from] = 0;\n        lockedEnd[_from] = 0;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _from,\n            oldDerivedAmount,\n            0,\n            lockedEndFrom,\n            lockedEndFrom\n        ));\n\n        _burn(_from);\n    }\n\n    /// @dev Split given veNFT. A new NFT will have a given percent of underlying tokens.\n    /// @param _tokenId ve token ID\n    /// @param percent percent of underlying tokens for new NFT with denominator 1e18 (1-(100e18-1)).\n    function split(uint _tokenId, uint percent) external nonReentrant {\n//        require(attachments[_tokenId] == 0 && !isVoted(_tokenId), \"ATTACHED\");\n        require(_idToOwner[_tokenId] == msg.sender, \"NOT_OWNER\");\n        require(percent != 0 && percent < 100e18, \"WRONG_INPUT\");\n\n        uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n        uint oldLockedDerivedAmount = _lockedDerivedAmount;\n        uint _lockedEnd = lockedEnd[_tokenId];\n\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n\n        // crete new NFT\n        uint _newTokenId = _incrementTokenIdAndGet();\n        _mint(msg.sender, _newTokenId);\n\n        // migrate percent of locked tokens to the new NFT\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            address stakingToken = tokens[i];\n            uint _lockedAmount = lockedAmounts[_tokenId][stakingToken];\n            if (_lockedAmount == 0) {\n                continue;\n            }\n            uint amountForNewNFT = _lockedAmount * percent / 100e18;\n            require(amountForNewNFT != 0, \"LOW_PERCENT\");\n\n            uint newLockedDerivedAmount = _calculateDerivedAmount(\n                _lockedAmount,\n                _lockedDerivedAmount,\n                _lockedAmount - amountForNewNFT,\n                tokenWeights[stakingToken],\n                IERC20Metadata(stakingToken).decimals()\n            );\n\n            _lockedDerivedAmount = newLockedDerivedAmount;\n\n            lockedAmounts[_tokenId][stakingToken] = _lockedAmount - amountForNewNFT;\n\n            // increase values for new NFT\n            _depositFor(DepositInfo({\n                stakingToken: stakingToken,\n                tokenId: _newTokenId,\n                value: amountForNewNFT,\n                unlockTime: _lockedEnd,\n                lockedAmount: 0,\n                lockedDerivedAmount: lockedDerivedAmount[_newTokenId],\n                lockedEnd: _lockedEnd,\n                depositType: DepositType.MERGE_TYPE\n            }));\n        }\n\n        // update derived amount\n        lockedDerivedAmount[_tokenId] = _lockedDerivedAmount;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _tokenId,\n            oldLockedDerivedAmount,\n            _lockedDerivedAmount,\n            _lockedEnd,\n            _lockedEnd\n        ));\n\n        emit Split(_tokenId, _newTokenId, percent);\n    }\n\n    /// @notice Withdraw all staking tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdrawAll(uint _tokenId) external {\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            address token = tokens[i];\n            if (lockedAmounts[_tokenId][token] != 0) {\n                withdraw(token, _tokenId);\n            }\n        }\n    }\n\n    /// @notice Withdraw given staking token for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(address stakingToken, uint _tokenId) public nonReentrant {\n        require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n//        require(attachments[_tokenId] == 0 && !isVoted(_tokenId), \"ATTACHED\");\n\n        (uint oldLockedAmount, uint oldLockedDerivedAmount, uint oldLockedEnd) =\n                        _lockInfo(stakingToken, _tokenId);\n        require(block.timestamp >= oldLockedEnd, \"NOT_EXPIRED\");\n        require(oldLockedAmount > 0, \"ZERO_LOCKED\");\n\n\n        uint newLockedDerivedAmount = _calculateDerivedAmount(\n            oldLockedAmount,\n            oldLockedDerivedAmount,\n            0,\n            tokenWeights[stakingToken],\n            IERC20Metadata(stakingToken).decimals()\n        );\n\n        // if no tokens set lock to zero\n        uint newLockEnd = oldLockedEnd;\n        if (newLockedDerivedAmount == 0) {\n            lockedEnd[_tokenId] = 0;\n            newLockEnd = 0;\n        }\n\n        // update derived amount\n        lockedDerivedAmount[_tokenId] = newLockedDerivedAmount;\n\n        // set locked amount to zero, we will withdraw all\n        lockedAmounts[_tokenId][stakingToken] = 0;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _tokenId,\n            oldLockedDerivedAmount,\n            newLockedDerivedAmount,\n            oldLockedEnd,\n            newLockEnd\n        ));\n\n        // Burn the NFT\n        if (newLockedDerivedAmount == 0) {\n            _burn(_tokenId);\n        }\n\n        _transferUnderlyingToken(stakingToken, msg.sender, oldLockedAmount);\n\n        emit Withdraw(stakingToken, msg.sender, _tokenId, oldLockedAmount, block.timestamp);\n    }\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /// @notice Binary search to estimate timestamp for block number\n    /// @param _block Block to find\n    /// @param maxEpoch Don't go beyond this epoch\n    /// @return Approximate timestamp for block\n    function _findBlockEpoch(uint _block, uint maxEpoch) internal view returns (uint) {\n        // Binary search\n        uint _min = 0;\n        uint _max = maxEpoch;\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_pointHistory[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n        uint _epoch = userPointEpoch[_tokenId];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\n            require(_t >= lastPoint.ts, \"WRONG_INPUT\");\n            lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint(int256(lastPoint.bias));\n        }\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId) external view override returns (string memory) {\n        require(_idToOwner[_tokenId] != address(0), \"TOKEN_NOT_EXIST\");\n\n        uint _lockedEnd = lockedEnd[_tokenId];\n        return\n            VeLogo.tokenURI(\n            _tokenId,\n            uint(int256(lockedDerivedAmount[_tokenId])),\n            block.timestamp < _lockedEnd ? _lockedEnd - block.timestamp : 0,\n            _balanceOfNFT(_tokenId, block.timestamp)\n        );\n    }\n\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    /// @param _tokenId User's wallet NFT\n    /// @param _block Block to calculate the voting power at\n    /// @return Voting power\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        require(_block <= block.number, \"WRONG_INPUT\");\n\n        // Binary search\n        uint _min = 0;\n        uint _max = userPointEpoch[_tokenId];\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_userPointHistory[_tokenId][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory uPoint = _userPointHistory[_tokenId][_min];\n\n        uint maxEpoch = epoch;\n        uint _epoch = _findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = _pointHistory[_epoch];\n        uint dBlock = 0;\n        uint dt = 0;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = _pointHistory[_epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dt = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dt = block.timestamp - point0.ts;\n        }\n        uint blockTime = point0.ts;\n        if (dBlock != 0 && _block > point0.blk) {\n            blockTime += (dt * (_block - point0.blk)) / dBlock;\n        }\n\n        uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\n        return uint(uint128(uPoint.bias.positiveInt128()));\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param point The point (bias/slope) to start search from\n    /// @param t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function _supplyAt(Point memory point, uint t) internal view returns (uint) {\n        Point memory lastPoint = point;\n        uint ti = (lastPoint.ts / WEEK) * WEEK;\n        for (uint i = 0; i < 255; ++i) {\n            ti += WEEK;\n            int128 dSlope = 0;\n            if (ti > t) {\n                ti = t;\n            } else {\n                dSlope = slopeChanges[ti];\n            }\n            lastPoint.bias -= lastPoint.slope * int128(int256(ti - lastPoint.ts));\n            if (ti == t) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = ti;\n        }\n        return uint(uint128(lastPoint.bias.positiveInt128()));\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        uint _epoch = epoch;\n        Point memory lastPoint = _pointHistory[_epoch];\n        return _supplyAt(lastPoint, t);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view override returns (uint) {\n        require(_block <= block.number, \"WRONG_INPUT\");\n        uint _epoch = epoch;\n        uint targetEpoch = _findBlockEpoch(_block, _epoch);\n\n        Point memory point = _pointHistory[targetEpoch];\n        // it is possible only for a block before the launch\n        // return 0 as more clear answer than revert\n        if (point.blk > _block) {\n            return 0;\n        }\n        uint dt = 0;\n        if (targetEpoch < _epoch) {\n            Point memory pointNext = _pointHistory[targetEpoch + 1];\n            // next point block can not be the same or lower\n            dt = ((_block - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n        } else {\n            if (point.blk != block.number) {\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dt);\n    }\n\n    function _burn(uint _tokenId) internal {\n        address owner = ownerOf(_tokenId);\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(owner, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n}\n"
    },
    "contracts/VeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVe.sol\";\nimport \"./interfaces/IVeDistributor.sol\";\nimport \"./dependencies/ControllableV3.sol\";\n\n/// @title Contract for distributing rewards to ve holders.\n///        Rewards will be staked to the veNFT without extending lock period.\n///        Based on Solidly contract.\n/// @author belbix\ncontract VeDistributor is ControllableV3, IVeDistributor {\n  using SafeERC20 for IERC20;\n\n  // for contract internal purposes, don't need to store in the interface\n  struct ClaimCalculationResult {\n    uint toDistribute;\n    uint userEpoch;\n    uint weekCursor;\n    uint maxUserEpoch;\n    bool success;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_DIST_VERSION = \"1.0.0\";\n  uint internal constant WEEK = 7 * 86400;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Voting escrow token address\n  IVe public ve;\n  /// @dev Token for ve rewards\n  address public override rewardToken;\n\n  // --- CHECKPOINT\n\n  /// @dev Cursor for the current epoch\n  uint public activePeriod;\n  /// @dev Tokens per week stored on checkpoint call. Predefined array size = max weeks size\n  uint[1000000000000000] public tokensPerWeek;\n  /// @dev Ve supply checkpoints. Predefined array size = max weeks size\n  uint[1000000000000000] public veSupply;\n  /// @dev Ve supply checkpoint time cursor\n  uint public timeCursor;\n  /// @dev Token balance updated on checkpoint/claim\n  uint public tokenLastBalance;\n  /// @dev Last checkpoint time\n  uint public lastTokenTime;\n\n  // --- CLAIM\n\n  /// @dev Timestamp when this contract was inited\n  uint public startTime;\n  /// @dev veID => week cursor stored on the claim action\n  mapping(uint => uint) public timeCursorOf;\n  /// @dev veID => epoch stored on the claim action\n  mapping(uint => uint) public userEpochOf;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CheckpointToken(\n    uint time,\n    uint tokens\n  );\n\n  event Claimed(\n    uint tokenId,\n    uint amount,\n    uint claimEpoch,\n    uint maxEpoch\n  );\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    address _ve,\n    address _rewardToken\n  ) external initializer {\n    __Controllable_init(controller_);\n    _requireERC20(_rewardToken);\n    _requireInterface(_ve, InterfaceIds.I_VE);\n\n    uint _t = block.timestamp / WEEK * WEEK;\n    startTime = _t;\n    lastTokenTime = _t;\n    timeCursor = _t;\n\n    rewardToken = _rewardToken;\n    ve = IVe(_ve);\n\n//    IERC20(_rewardToken).safeApprove(_ve, type(uint).max);\n  }\n\n  // *************************************************************\n  //                      CHECKPOINT\n  // *************************************************************\n\n  function checkpoint() external override {\n    uint _period = activePeriod;\n    // only trigger if new week\n    if (block.timestamp >= _period + 1 weeks) {\n      // set new period rounded to weeks\n      activePeriod = block.timestamp / 1 weeks * 1 weeks;\n      // checkpoint token balance that was just minted in veDist\n      _checkpointToken();\n      // checkpoint supply\n      _checkpointTotalSupply();\n    }\n  }\n\n  /// @dev Update tokensPerWeek value\n  function _checkpointToken() internal {\n    uint tokenBalance = IERC20(rewardToken).balanceOf(address(this));\n    uint toDistribute = tokenBalance - tokenLastBalance;\n    tokenLastBalance = tokenBalance;\n\n    uint t = lastTokenTime;\n    uint sinceLast = block.timestamp - t;\n    lastTokenTime = block.timestamp;\n    uint thisWeek = t / WEEK * WEEK;\n    uint nextWeek = 0;\n\n    // checkpoint should be called at least once per 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      nextWeek = thisWeek + WEEK;\n      if (block.timestamp < nextWeek) {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\n        break;\n      } else {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\n      }\n      t = nextWeek;\n      thisWeek = nextWeek;\n    }\n    emit CheckpointToken(block.timestamp, toDistribute);\n  }\n\n  /// @dev Adjust value based on time since last update\n  function adjustToDistribute(\n    uint toDistribute,\n    uint t0,\n    uint t1,\n    uint sinceLast\n  ) public pure returns (uint) {\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n      return toDistribute;\n    }\n    return toDistribute * (t0 - t1) / sinceLast;\n  }\n\n  /// @dev Search in the loop given timestamp through ve points history.\n  ///      Return minimal possible epoch.\n  function findTimestampEpoch(IVe _ve, uint _timestamp) public view returns (uint) {\n    uint _min = 0;\n    uint _max = _ve.epoch();\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVe.Point memory pt = _ve.pointHistory(_mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Search in the loop given timestamp through ve user points history.\n  ///      Return minimal possible epoch.\n  function findTimestampUserEpoch(\n    IVe _ve,\n    uint tokenId,\n    uint _timestamp,\n    uint maxUserEpoch\n  ) public view returns (uint) {\n    uint _min = 0;\n    uint _max = maxUserEpoch;\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVe.Point memory pt = _ve.userPointHistory(tokenId, _mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Return ve power at given timestamp\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\n    IVe _ve = ve;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint epoch = findTimestampUserEpoch(_ve, _tokenId, _timestamp, maxUserEpoch);\n    IVe.Point memory pt = _ve.userPointHistory(_tokenId, epoch);\n    return uint(int256(_positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\n  }\n\n  /// @dev Call ve checkpoint and write veSupply at the current timeCursor\n  function checkpointTotalSupply() external override {\n    _checkpointTotalSupply();\n  }\n\n  function _checkpointTotalSupply() internal {\n    IVe _ve = ve;\n    uint t = timeCursor;\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\n    _ve.checkpoint();\n\n    // assume will be called more frequently than 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      if (t > roundedTimestamp) {\n        break;\n      } else {\n        uint epoch = findTimestampEpoch(_ve, t);\n        IVe.Point memory pt = _ve.pointHistory(epoch);\n        veSupply[t] = adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n      }\n      t += WEEK;\n    }\n    timeCursor = t;\n  }\n\n  /// @dev Calculate ve supply based on bias and slop for the given timestamp\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) public pure returns (uint) {\n    if (t < ptTs) {\n      return 0;\n    }\n    int128 dt = int128(int256(t - ptTs));\n    if (ptBias < ptSlope * dt) {\n      return 0;\n    }\n    return uint(int256(_positiveInt128(ptBias - ptSlope * dt)));\n  }\n\n  // *************************************************************\n  //                      CLAIM\n  // *************************************************************\n\n  /// @dev Return available to claim earned amount\n  function claimable(uint _tokenId) external view returns (uint) {\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\n    return result.toDistribute;\n  }\n\n  /// @dev Claim rewards for given veID\n  function claim(uint _tokenId) external override returns (uint) {\n    IVe _ve = ve;\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    uint amount = _claim(_tokenId, _ve, _lastTokenTime);\n    if (amount != 0) {\n      IERC20(rewardToken).safeTransfer(IERC721(address(_ve)).ownerOf(_tokenId), amount);\n//      _ve.increaseAmount(rewardToken, _tokenId, amount);\n      tokenLastBalance -= amount;\n    }\n    return amount;\n  }\n\n  /// @dev Claim rewards for given veIDs\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    IVe _votingEscrow = ve;\n    uint total = 0;\n\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      uint _tokenId = _tokenIds[i];\n      if (_tokenId == 0) break;\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n      if (amount != 0) {\n        IERC20(rewardToken).safeTransfer(IERC721(address(_votingEscrow)).ownerOf(_tokenId), amount);\n//        _votingEscrow.increaseAmount(rewardToken, _tokenId, amount);\n        total += amount;\n      }\n    }\n    if (total != 0) {\n      tokenLastBalance -= total;\n    }\n\n    return true;\n  }\n\n  function _claim(uint _tokenId, IVe _ve, uint _lastTokenTime) internal returns (uint) {\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, _ve, _lastTokenTime);\n    if (result.success) {\n      userEpochOf[_tokenId] = result.userEpoch;\n      timeCursorOf[_tokenId] = result.weekCursor;\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\n    }\n    return result.toDistribute;\n  }\n\n  function _calculateClaim(\n    uint _tokenId,\n    IVe _ve,\n    uint _lastTokenTime\n  ) internal view returns (ClaimCalculationResult memory) {\n    uint userEpoch;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint _startTime = startTime;\n\n    if (maxUserEpoch == 0) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n\n    uint weekCursor = timeCursorOf[_tokenId];\n\n    if (weekCursor == 0) {\n      userEpoch = findTimestampUserEpoch(_ve, _tokenId, _startTime, maxUserEpoch);\n    } else {\n      userEpoch = userEpochOf[_tokenId];\n    }\n\n    if (userEpoch == 0) userEpoch = 1;\n\n    IVe.Point memory userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n    if (weekCursor == 0) {\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\n    }\n    if (weekCursor >= lastTokenTime) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n    if (weekCursor < _startTime) {\n      weekCursor = _startTime;\n    }\n\n    return calculateToDistribute(\n      _tokenId,\n      weekCursor,\n      _lastTokenTime,\n      userPoint,\n      userEpoch,\n      maxUserEpoch,\n      _ve\n    );\n  }\n\n  function calculateToDistribute(\n    uint _tokenId,\n    uint weekCursor,\n    uint _lastTokenTime,\n    IVe.Point memory userPoint,\n    uint userEpoch,\n    uint maxUserEpoch,\n    IVe _ve\n  ) public view returns (ClaimCalculationResult memory) {\n    IVe.Point memory oldUserPoint;\n    uint toDistribute;\n    for (uint i = 0; i < 50; i++) {\n      if (weekCursor >= _lastTokenTime) {\n        break;\n      }\n      if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n        userEpoch += 1;\n        oldUserPoint = userPoint;\n        if (userEpoch > maxUserEpoch) {\n          userPoint = IVe.Point(0, 0, 0, 0);\n        } else {\n          userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n        }\n      } else {\n        int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n        uint balanceOf = uint(int256(_positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\n        if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n          break;\n        }\n        toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\n        weekCursor += WEEK;\n      }\n    }\n    return ClaimCalculationResult(\n      toDistribute,\n      Math.min(maxUserEpoch, userEpoch - 1),\n      weekCursor,\n      maxUserEpoch,\n      true\n    );\n  }\n\n  function _positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /// @dev Block timestamp rounded to weeks\n  function timestamp() external view returns (uint) {\n    return block.timestamp / WEEK * WEEK;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VE_DISTRIBUTOR || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\t/// @solidity memory-safe-assembly\n\t\tassembly {\n\t\t\tpop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/dependencies/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./BaseMath.sol\";\nimport \"./LiquityMath.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IBase.sol\";\n\n/* \n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n* common functions. \n*/\ncontract Base is BaseMath, IBase {\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint constant public MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public CCR = 1500000000000000000; // 150%\n\n    // Amount of SIM to be locked in gas pool on opening troves\n//    uint constant public SIM_GAS_COMPENSATION = 200e18;\n\n    // Minimum amount of net SIM debt a trove must have\n    uint constant public MIN_NET_DEBT = 1e18; //1800e18;\n    // uint constant public MIN_NET_DEBT = 0;\n\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n\n    IActivePool public activePool;\n\n    IDefaultPool public defaultPool;\n\n    IPriceFeed public override priceFeed;\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\n        return _debt/* + SIM_GAS_COMPENSATION*/;\n    }\n\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\n        return _debt/* + SIM_GAS_COMPENSATION*/;\n    }\n\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\n        uint activeColl = activePool.getWSTETH();\n        uint liquidatedColl = defaultPool.getWSTETH();\n\n        return activeColl + liquidatedColl;\n    }\n\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getSIMDebt();\n        uint closedDebt = defaultPool.getSIMDebt();\n\n        return activeDebt + closedDebt;\n    }\n\n    function _getTCR(uint _price) internal view returns (uint TCR) {\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\n        uint TCR = _getTCR(_price);\n\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\n        uint feePercentage = _fee * DECIMAL_PRECISION / _amount;\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n    }\n}\n"
    },
    "contracts/dependencies/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n  bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /// @notice Encodes some bytes to the base64 representation\n  function encode(bytes memory data) internal pure returns (string memory) {\n    uint len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}\n"
    },
    "contracts/dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\ncontract BaseMath {\n    uint constant public DECIMAL_PRECISION = 1e18;\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     */\n    function _checkContract(address account_) internal view {\n        require(account_ != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account_) }\n        require(size > 0, \"Account code size cannot be zero\");\n    }\n}\n"
    },
    "contracts/dependencies/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./TetuERC165.sol\";\nimport \"./InterfaceIds.sol\";\nimport \"./SlotsLib.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.1\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n  /// @dev Gets a slot as bytes32\n  function getSlot(uint slot) external view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n}\n"
    },
    "contracts/dependencies/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n  /*//////////////////////////////////////////////////////////////\n  //SIMPLIFIED FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  uint internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n  function mulWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded down.\n  }\n\n  function mulWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded up.\n  }\n\n  function divWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded down.\n  }\n\n  function divWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded up.\n  }\n\n  function positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //LOW LEVEL FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  function mulDivDown(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // Divide z by the denominator.\n      z := div(z, denominator)\n    }\n  }\n\n  function mulDivUp(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // First, divide z - 1 by the denominator and add 1.\n    // We allow z - 1 to underflow if z is 0, because we multiply the\n    // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n    }\n  }\n\n  function rpow(\n    uint x,\n    uint n,\n    uint scalar\n  ) internal pure returns (uint z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n        // 0 ** 0 = 1\n          z := scalar\n        }\n        default {\n        // 0 ** n = 0\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n        // If n is even, store scalar in z for now.\n          z := scalar\n        }\n        default {\n        // If n is odd, store x in z for now.\n          z := x\n        }\n\n      // Shifting right by 1 is like dividing by 2.\n        let half := shr(1, scalar)\n\n        for {\n        // Shift n right by 1 before looping to halve it.\n          n := shr(1, n)\n        } n {\n        // Shift n right by 1 each iteration to halve it.\n          n := shr(1, n)\n        } {\n        // Revert immediately if x ** 2 would overflow.\n        // Equivalent to iszero(eq(div(xx, x), x)) here.\n          if shr(128, x) {\n            revert(0, 0)\n          }\n\n        // Store x squared.\n          let xx := mul(x, x)\n\n        // Round to the nearest number.\n          let xxRound := add(xx, half)\n\n        // Revert if xx + half overflowed.\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n\n        // Set x to scaled xxRound.\n          x := div(xxRound, scalar)\n\n        // If n is even:\n          if mod(n, 2) {\n          // Compute z * x.\n            let zx := mul(z, x)\n\n          // If z * x overflowed:\n            if iszero(eq(div(zx, x), z)) {\n            // Revert if x is non-zero.\n              if iszero(iszero(x)) {\n                revert(0, 0)\n              }\n            }\n\n          // Round to the nearest number.\n            let zxRound := add(zx, half)\n\n          // Revert if zx + half overflowed.\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n\n          // Return properly scaled zxRound.\n            z := div(zxRound, scalar)\n          }\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  // GENERAL NUMBER UTILITIES\n  //////////////////////////////////////////////////////////////*/\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n}\n"
    },
    "contracts/dependencies/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n    /// @notice Version of the contract\n    /// @dev Should be incremented when contract changed\n    string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n    /// default notation:\n    /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n    /// As type({Interface}).interfaceId can be changed,\n    /// when some functions changed at the interface,\n    /// so used hardcoded interface identifiers\n\n    bytes4 public constant I_VE = bytes4(keccak256(\"IVe\"));\n    bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n    bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n    bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n    bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n}\n"
    },
    "contracts/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary LiquityMath {\n    uint internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division. \n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /* \n    * Multiply two decimal numbers and use normal rounding rules:\n    * -round product up if 19'th mantissa digit >= 5\n    * -round product down if 19'th mantissa digit < 5\n    *\n    * Used only inside the exponentiation, _decPow().\n    */\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\n        uint prod_xy = x * y;\n\n        decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\n    }\n\n    /* \n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n    * \n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \n    * \n    * Called by two functions that represent time in units of minutes:\n    * 1) TroveManager._calcDecayedBaseRate\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \n    * \n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n    * \n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n    * negligibly different from just passing the cap, since: \n    *\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n    */\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n        // cap to avoid overflow\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        }\n    \n        if (_minutes == 0) {return DECIMAL_PRECISION;}\n\n        uint y = DECIMAL_PRECISION;\n        uint x = _base;\n        uint n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else { // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n  }\n\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\n        if (_debt > 0) {\n            return _coll * NICR_PRECISION / _debt;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else { // if (_debt == 0)\n            return 2**256 - 1;\n        }\n    }\n\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll * _price / _debt;\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else { // if (_debt == 0)\n            return 2**256 - 1; \n        }\n    }\n}\n"
    },
    "contracts/dependencies/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "contracts/dependencies/StringLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n}\n"
    },
    "contracts/dependencies/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "contracts/dependencies/VeLogo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \".//Base64.sol\";\nimport \"./StringLib.sol\";\n\n// https://github.com/tetu-io/tetu-contracts-v2/blob/master/contracts/ve/VeTetuLogo.sol\n/// @title Library for storing SVG image of veNFT.\n/// @author belbix\nlibrary VeLogo {\n\n  /// @dev Return SVG logo of xSHADY\n  function tokenURI(uint _tokenId, uint _balanceOf, uint untilEnd, uint _value) public pure returns (string memory output) {\n    output = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 900\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style>.base{font-size:40px;}</style><rect fill=\"#44a465\" width=\"600\" height=\"900\"/><path fill=\"#1B4229\" d=\"M0,900h600V522.2C454.4,517.2,107.4,456.8,60.2,0H0V900z\"/><circle fill=\"#69db7c\" cx=\"385\" cy=\"212\" r=\"120\"/><symbol id=\"image-241a2825d965ea677b3dc22aaea9375b2aeb6193\"><image width=\"100%\" height=\"100%\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAMPmlDQ1BJQ0MgUHJvZmlsZQAASImVVwdYU8kWnluSkEBooUsJvQkiNYCUEFoA6V1UQhIglBgDQcVeFhVcu1jAhq6KKFhpFhRRLCyKvS8WVJR1sWBX3qSArvvK9ybf3Pnzz5n/nDkztwwAaic4IlEeqg5AvrBQHBsSQE9OSaWTngIi0IE/XeDM4RaImNHREQCWofbv5d11gEjbKw5SrX/2/9eiweMXcAFAoiHO4BVw8yE+BABeyRWJCwEgSnnzKYUiKYYVaIlhgBAvkuIsOa6U4gw53ieziY9lQdwGgJIKhyPOAkD1EuTpRdwsqKHaD7GTkCcQAqBGh9g3P38SD+J0iG2gjQhiqT4j4wedrL9pZgxrcjhZw1g+F1lRChQUiPI40/7PdPzvkp8nGfJhBatKtjg0VjpnmLebuZPCpVgF4j5hRmQUxJoQfxDwZPYQo5RsSWiC3B415BawYM7gOgPUiccJDIfYEOJgYV5khILPyBQEsyGGOwSdKihkx0OsB/EifkFQnMJmi3hSrMIXWp8pZjEV/FmOWOZX6uu+JDeBqdB/nc1nK/Qx1eLs+CSIKRBbFAkSIyFWhdixIDcuXGEzpjibFTlkI5bESuO3gDiWLwwJkOtjRZni4FiFfWl+wdB8sS3ZAnakAh8ozI4PlecHa+NyZPHDuWCX+EJmwpAOvyA5YmguPH5gkHzu2DO+MCFOofNBVBgQKx+LU0R50Qp73IyfFyLlzSB2LSiKU4zFEwvhhpTr45miwuh4eZx4cQ4nLFoeD74cRAAWCAR0IIE1A0wCOUDQ2dfQB//Je4IBB4hBFuADBwUzNCJJ1iOE1zhQDP6EiA8KhscFyHr5oAjyX4dZ+dUBZMp6i2QjcsETiPNBOMiD/yWyUcJhb4ngMWQE//DOgZUL482DVdr/7/kh9jvDhEyEgpEMeaSrDVkSg4iBxFBiMNEWN8B9cW88Al79YXXGGbjn0Dy+2xOeELoIDwnXCN2EWxMF88Q/RTkWdEP9YEUuMn7MBW4FNd3wANwHqkNlXAc3AA64K/TDxP2gZzfIshRxS7NC/0n7bzP4YTUUdmQnMkrWJfuTbX4eqWqn6jasIs31j/mRx5oxnG/WcM/P/lk/ZJ8H2/CfLbFF2EGsHTuJncOOYg2AjrVgjVgHdkyKh3fXY9nuGvIWK4snF+oI/uFvaGWlmSxwqnHqdfoi7yvkT5U+owFrkmiaWJCVXUhnwjcCn84Wch1H0p2dnF0AkL5f5I+vNzGy9wai0/Gdm/8HAD4tg4ODR75zYS0A7PeAt3/Td86GAV8dygCcbeJKxEVyDpdeCPApoQbvNH1gDMyBDZyPM3AH3sAfBIEwEAXiQQqYAKPPhvtcDKaAGWAuKAFlYDlYAzaAzWAb2AX2ggOgARwFJ8EZcAFcAtfAHbh7esAL0A/egc8IgpAQKkJD9BETxBKxR5wRBuKLBCERSCySgqQjWYgQkSAzkPlIGbIS2YBsRaqR/UgTchI5h3Qht5AHSC/yGvmEYqgKqoUaoVboKJSBMtFwNB4dj2ahk9FidAG6FF2HVqF70Hr0JHoBvYZ2oy/QAQxgypgOZoo5YAyMhUVhqVgmJsZmYaVYOVaF1WLNcJ2vYN1YH/YRJ+I0nI47wB0ciifgXHwyPgtfgm/Ad+H1eBt+BX+A9+PfCFSCIcGe4EVgE5IJWYQphBJCOWEH4TDhNLyXegjviESiDtGa6AHvxRRiDnE6cQlxI7GOeILYRXxEHCCRSPoke5IPKYrEIRWSSkjrSXtILaTLpB7SByVlJRMlZ6VgpVQlodI8pXKl3UrHlS4rPVX6TFYnW5K9yFFkHnkaeRl5O7mZfJHcQ/5M0aBYU3wo8ZQcylzKOkot5TTlLuWNsrKymbKncoyyQHmO8jrlfcpnlR8of1TRVLFTYamkqUhUlqrsVDmhckvlDZVKtaL6U1OphdSl1GrqKep96gdVmqqjKluVpzpbtUK1XvWy6ks1spqlGlNtglqxWrnaQbWLan3qZHUrdZY6R32WeoV6k/oN9QENmsZojSiNfI0lGrs1zmk80yRpWmkGafI0F2hu0zyl+YiG0cxpLBqXNp+2nXaa1qNF1LLWYmvlaJVp7dXq1OrX1tR21U7UnqpdoX1Mu1sH07HSYevk6SzTOaBzXeeTrpEuU5evu1i3Vvey7nu9EXr+eny9Ur06vWt6n/Tp+kH6ufor9Bv07xngBnYGMQZTDDYZnDboG6E1wnsEd0TpiAMjbhuihnaGsYbTDbcZdhgOGBkbhRiJjNYbnTLqM9Yx9jfOMV5tfNy414Rm4msiMFlt0mLynK5NZ9Lz6OvobfR+U0PTUFOJ6VbTTtPPZtZmCWbzzOrM7plTzBnmmearzVvN+y1MLMZazLCosbhtSbZkWGZbrrVst3xvZW2VZLXQqsHqmbWeNdu62LrG+q4N1cbPZrJNlc1VW6ItwzbXdqPtJTvUzs0u267C7qI9au9uL7DfaN81kjDSc6RwZNXIGw4qDkyHIocahweOOo4RjvMcGxxfjrIYlTpqxaj2Ud+c3JzynLY73RmtOTps9LzRzaNfO9s5c50rnK+6UF2CXWa7NLq8crV35btucr3pRnMb67bQrdXtq7uHu9i91r3Xw8Ij3aPS4wZDixHNWMI460nwDPCc7XnU86OXu1eh1wGvv7wdvHO9d3s/G2M9hj9m+5hHPmY+HJ+tPt2+dN903y2+3X6mfhy/Kr+H/ub+PP8d/k+Ztswc5h7mywCnAHHA4YD3LC/WTNaJQCwwJLA0sDNIMyghaEPQ/WCz4KzgmuD+ELeQ6SEnQgmh4aErQm+wjdhcdjW7P8wjbGZYW7hKeFz4hvCHEXYR4ojmsejYsLGrxt6NtIwURjZEgSh21Kqoe9HW0ZOjj8QQY6JjKmKexI6OnRHbHkeLmxi3O+5dfED8svg7CTYJkoTWRLXEtMTqxPdJgUkrk7qTRyXPTL6QYpAiSGlMJaUmpu5IHRgXNG7NuJ40t7SStOvjrcdPHX9ugsGEvAnHJqpN5Ew8mE5IT0rfnf6FE8Wp4gxksDMqM/q5LO5a7gueP281r5fvw1/Jf5rpk7ky81mWT9aqrN5sv+zy7D4BS7BB8ConNGdzzvvcqNyduYN5SXl1+Ur56flNQk1hrrBtkvGkqZO6RPaiElH3ZK/Jayb3i8PFOwqQgvEFjYVa8EO+Q2Ij+UXyoMi3qKLow5TEKQenakwVTu2YZjdt8bSnxcHFv03Hp3Ont84wnTF3xoOZzJlbZyGzMma1zjafvWB2z5yQObvmUubmzv19ntO8lfPezk+a37zAaMGcBY9+CfmlpkS1RFxyY6H3ws2L8EWCRZ2LXRavX/ytlFd6vsyprLzsyxLukvO/jv513a+DSzOXdi5zX7ZpOXG5cPn1FX4rdq3UWFm88tGqsavqV9NXl65+u2bimnPlruWb11LWStZ2r4tY17jeYv3y9V82ZG+4VhFQUVdpWLm48v1G3sbLm/w31W422ly2+dMWwZabW0O21ldZVZVvI24r2vZke+L29t8Yv1XvMNhRtuPrTuHO7l2xu9qqPaqrdxvuXlaD1khqevek7bm0N3BvY61D7dY6nbqyfWCfZN/z/en7rx8IP9B6kHGw9pDlocrDtMOl9Uj9tPr+huyG7saUxq6msKbWZu/mw0ccj+w8anq04pj2sWXHKccXHB9sKW4ZOCE60Xcy6+Sj1omtd04ln7raFtPWeTr89NkzwWdOtTPbW876nD16zutc03nG+YYL7hfqO9w6Dv/u9vvhTvfO+oseFxsveV5q7hrTdfyy3+WTVwKvnLnKvnrhWuS1rusJ12/eSLvRfZN389mtvFuvbhfd/nxnzl3C3dJ76vfK7xver/rD9o+6bvfuYw8CH3Q8jHt45xH30YvHBY+/9Cx4Qn1S/tTkafUz52dHe4N7Lz0f97znhejF576SPzX+rHxp8/LQX/5/dfQn9/e8Er8afL3kjf6bnW9d37YORA/cf5f/7vP70g/6H3Z9ZHxs/5T06ennKV9IX9Z9tf3a/C38293B/MFBEUfMkX0KYLCimZkAvN4JADUFABo8n1HGyc9/soLIz6wyBP4Tlp8RZcUdgFr4/R7TB79ubgCwbzs8fkF9tTQAoqkAxHsC1MVluA6d1WTnSmkhwnPAlrivGfkZ4N8U+Znzh7h/boFU1RX83P4L9rN8iIgyVPIAAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAKCgAwAEAAAAAQAAAKAAAAAAhCQ7swAABRtJREFUeAHt3T2LGFUUBuDVGIiJihoTxCKolYKFWEQbEexM55+ztrextAq2NmlNpywoRlgUYXWJiKawTIZ3yD3M/XhS7pycufc5L1PkZmZPTvwhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAYTeCZ0Rb8tOv98N2X/33aHj38/e++/32K2T3bA6Y1rCsggOvOvoudC2AXY1h3EQK47uy72LkAdjGGdRchgOvOvoudC2AXY1h3EQK47uy72LkAdjGGdRfx3CxbT084Pv/4ZrTlsz/+jurOL/6J6tKia1cupaXRic6rL16O+r31xvNR3RdfnzY9gfEEjNgVVQkIYJWsvpGAAEZMiqoEBLBKVt9IQAAjJkVVAgJYJatvJCCAEZOiKgEBrJLVNxIQwIhJUZVA03/Vrlpky77picmD3x62vG3c685Hr8W1SeGtm1eSspMvv/kpqrt/et40M56AEbuiKgEBrJLVNxIQwIhJUZWAAFbJ6hsJCGDEpKhKQACrZPWNBAQwYlJUJSCAVbL6RgICGDEpqhKY5p2QFKj3r0r98PNf0bse7739QrTl018vorqLh9Fto157ijwB92ipbS4ggM1JNdwjIIB7tNQ2FxDA5qQa7hEQwD1aapsLCGBzUg33CAjgHi21zQUEsDmphnsEBHCPltrmAk3/f3/z1U3U8LPbN6KjhvQrVXfvnUU6n35wPapLv8r11bcPon4//vJnlC1PwIhTUZWAAFbJ6hsJCGDEpKhKQACrZPWNBAQwYlJUJSCAVbL6RgICGDEpqhIQwCpZfSMBAYyYFFUJLPdOSGvI9ITjk/dfiW7d+itVj971iE5gWn+VK9rsoyJPwFRKXYmAAJawapoKCGAqpa5EQABLWDVNBQQwlVJXIiCAJayapgICmEqpKxEQwBJWTVMBAUyl1JUIOAl5Amt6wpG+w9H6hOMJyx7ux56Aw41srgUL4FzzHG43AjjcyOZasADONc/hdiOAw41srgUL4FzzHG43AjjcyOZasADONc/hdiOAw41srgUvdxKSnnAc9Q7HUfFKv47Ven2egK1F9dslIIC7uBS3FhDA1qL67RIQwF1cilsLCGBrUf12CQjgLi7FrQUEsLWofrsEBHAXl+LWAgLYWlS/XQLTnISkJxze4Xh8Pq6/dPnxF4p/6glYDKz9toAAbvu4WiwggMXA2m8LCOC2j6vFAgJYDKz9toAAbvu4WiwggMXA2m8LCOC2j6vFAgJYDKz9tkD0W623W9ReTU84VnuHo7X6m69fjX6fSPqb0NP1eQKmUupKBASwhFXTVEAAUyl1JQICWMKqaSoggKmUuhIBASxh1TQVEMBUSl2JgACWsGqaCghgKqWuROCwk5D0hCN9h+PuvbMI6P7p+WF7jha4WJEn4GID7227AtjbRBZbjwAuNvDetiuAvU1ksfUI4GID7227AtjbRBZbjwAuNvDetiuAvU1ksfUI4GID7227zU8F0hMO73D0FoVj1uMJeIy7u/4vIICicKiAAB7K7+YCKAOHCgjgofxuLoAycKiAAB7K7+YCKAOHCgjgofxu3vwk5J1b16KvLKX03uFIpcas8wQcc27TrFoApxnlmBsRwDHnNs2qBXCaUY65EQEcc27TrFoApxnlmBsRwDHnNs2qBXCaUY65EQEcc25WTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0L3Af+uYbixoS1WFAAAAAElFTkSuQmCC\"></image></symbol><g transform=\"translate(37.57910645834454 30.260009582668317) rotate(0 86.40756100104954 86.40756100104909)\"><use xlink:href=\"#image-241a2825d965ea677b3dc22aaea9375b2aeb6193\" width=\"173\" height=\"173\" opacity=\"1\" x=\"260\" y=\"85\"></use></g>';\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 464)\" fill=\"#EAECFE\" class=\"base\">ID:</text><text transform=\"matrix(1 0 0 1 50 506)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_tokenId), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 579)\" fill=\"#EAECFE\" class=\"base\">Balance:</text><text transform=\"matrix(1 0 0 1 50 621)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_balanceOf / 1e18), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 695)\" fill=\"#EAECFE\" class=\"base\">Until unlock:</text><text transform=\"matrix(1 0 0 1 50 737)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(untilEnd / 60 / 60 / 24), ' days</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 811)\" fill=\"#EAECFE\" class=\"base\">Power:</text><text transform=\"matrix(1 0 0 1 50 853)\" fill=\"#6fe783\" class=\"base\">', StringLib._toString(_value / 1e18), '</text></svg>'));\n\n    string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"xSHADY #', StringLib._toString(_tokenId), '\", \"description\": \"Locked SHADY tokens\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n    output = string(abi.encodePacked('data:application/json;base64,', json));\n  }\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPool.sol\";\n\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolSIMDebtUpdated(uint _SIMDebt);\n    event ActivePoolWSTETHBalanceUpdated(uint _WSTETH);\n\n    // --- Functions ---\n    function sendWSTETH(address _account, uint _amount) external;\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPriceFeed.sol\";\n\n\ninterface IBase {\n    function priceFeed() external view returns (IPriceFeed);\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event SIMTokenAddressChanged(address _simTokenAddress);\n    event SimVeDistributorAddressChanged(address _VeAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event SIMBorrowingFeePaid(address indexed _borrower, uint _SIMFee);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _simTokenAddress,\n        address _shadyStakingAddress,\n        address _feeReceiver\n    ) external;\n\n    function openTrove(uint amount, uint _maxFee, uint _SIMAmount, address _upperHint, address _lowerHint) external payable;\n\n    function addColl(uint amount, address _upperHint, address _lowerHint) external;\n\n    function moveWSTETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\n\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function withdrawSIM(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\n\n    function repaySIM(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint addColAmount, uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\n\n    function claimCollateral() external;\n\n//    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\ninterface ICollSurplusPool {\n\n    // --- Events ---\n\n    event WSTETHAddressChanged(address _newWSTETHAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _WSTETHAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getWSTETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IController {\n\n    // --- DEPENDENCY ADDRESSES\n    function governance() external view returns (address);\n\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IPool.sol\";\n\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolSIMDebtUpdated(uint _SIMDebt);\n    event DefaultPoolWSTETHBalanceUpdated(uint _WSTETH);\n\n    // --- Functions ---\n    function sendWSTETHToActivePool(uint _amount) external;\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Common interface for the Pools.\ninterface IPool {\n    \n    // --- Events ---\n    \n    event WSTETHBalanceUpdated(uint _newBalance);\n    event SIMBalanceUpdated(uint _newBalance);\n    event WSTETHAddressChanged(address _newWSTETHAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    \n    function getWSTETH() external view returns (uint);\n\n    function getSIMDebt() external view returns (uint);\n\n    function increaseSIMDebt(uint _amount) external;\n\n    function decreaseSIMDebt(uint _amount) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IPriceFeed {\n\n    // --- Events ---\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n   \n    // --- Function ---\n    function fetchPrice() external returns (uint);\n}\n"
    },
    "contracts/interfaces/ISHADYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ISHADYToken is IERC20, IERC20Permit {\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address communityIssuanceAddress);\n    event VeAddressSet(address veAddress);\n    event LockupContractFactoryAddressSet(address lockupContractFactoryAddress);\n\n    // --- Functions ---\n\n    function getDeploymentStartTime() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ISIMToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ISIMToken is IERC20, IERC20Permit {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address troveManagerAddress);\n    event StabilityPoolAddressChanged(address newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(address newBorrowerOperationsAddress);\n    event LUSDTokenBalanceUpdated(address user, uint amount);\n\n    // --- Functions ---\n\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(address account_, uint256 amount_) external;\n\n    function sendToPool(address sender_, address poolAddress, uint256 amount_) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event NodeAdded(address _id, uint _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n    \n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\n\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n * The Stability Pool holds SIM tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its SIM debt gets offset with\n * SIM in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of SIM tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a SIM loss, in proportion to their deposit as a share of total deposits.\n * They also receive an WSTETH gain, as the WSTETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total SIM in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WSTETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * --- SHADY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An SHADY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued SHADY in proportion to the deposit as a share of total deposits. The SHADY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n */\ninterface IStabilityPool {\n\n    // --- Events ---\n    \n    event StabilityPoolWSTETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolSIMBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\n\n    event WSTETHGainWithdrawn(address indexed _depositor, uint _WSTETH, uint _SIMLoss);\n    event SHADYPaidToDepositor(address indexed _depositor, uint _SHADY);\n    event SHADYPaidToFrontEnd(address indexed _frontEnd, uint _SHADY);\n    event WSTETHSent(address _to, uint _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other SIM contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _WSTETHAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _SIMTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Frontend is registered or zero address\n     * - Sender is not a registered frontend\n     * - _amount is not zero\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (SHADY, WSTETH) to depositor\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint _amount, address _frontEndTag) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (SHADY, WSTETH) to depositor\n     * - Sends the tagged front end's accumulated SHADY gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some WSTETH gain\n     * ---\n     * - Triggers a SHADY issuance, based on time passed since the last issuance. The SHADY issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's SHADY gain to  depositor\n     * - Sends all tagged front end's SHADY gain to the tagged front end\n     * - Transfers the depositor's entire WSTETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake\n     */\n    function withdrawWSTETHGainToTrove(address _upperHint, address _lowerHint) external;\n\n    /*\n     * Initial checks:\n     * - Frontend (sender) not already registered\n     * - User (sender) has no deposit\n     * - _kickbackRate is in the range [0, 100%]\n     * ---\n     * Front end makes a one-time selection of kickback rate upon registering\n     */\n//    function registerFrontEnd(uint _kickbackRate) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the SIM contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's WSTETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint _debt, uint _coll) external;\n\n    /*\n     * Returns the total amount of WSTETH held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like WSTETH received from a self-destruct.\n     */\n    function getWSTETH() external view returns (uint);\n\n    /*\n     * Returns SIM held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalSIMDeposits() external view returns (uint);\n\n    /*\n     * Calculates the WSTETH gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorWSTETHGain(address _depositor) external view returns (uint);\n\n    /*\n     * Calculate the SHADY gain earned by a deposit since its last snapshots were taken.\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n     * which they made their deposit.\n     */\n    function getDepositorSHADYGain(address _depositor) external view returns (uint);\n\n    /*\n     * Return the SHADY gain earned by the front end.\n     */\n//    function getFrontEndSHADYGain(address _frontEnd) external view returns (uint);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedSIMDeposit(address _depositor) external view returns (uint);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n//    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\n\n    /*\n     * Fallback function\n     * Only callable by Active Pool, it just accounts for WSTETH received\n     * receive() external payable;\n     */\n    function receiveWSTETH(uint amount) external;\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IBase.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./ISIMToken.sol\";\nimport \"./ISHADYToken.sol\";\nimport \"./IVe.sol\";\n\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IBase {\n    \n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SIMTokenAddressChanged(address _newSIMTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n//    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event SHADYTokenAddressChanged(address _shadyTokenAddress);\n    event WSTETHVeDistibutorAddressChanged(address _shadyStakingAddress);\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation/*, uint _SIMGasCompensation*/);\n    event Redemption(uint _attemptedSIMAmount, uint _actualSIMAmount, uint _WSTETHSent, uint _WSTETHFee);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\n    event LTermsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\n    event TroveSnapshotsUpdated(uint _L_WSTETH, uint _L_SIMDebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n//        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _simTokenAddress,\n        address _sortedTrovesAddress,\n        address _shadyTokenAddress,\n        address _veAddress\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n    function simToken() external view returns (ISIMToken);\n    function shadyToken() external view returns (ISHADYToken);\n    function wstETHVeDistributor() external view returns (address);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint _SIMAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external;\n\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingWSTETHReward(address _borrower) external view returns (uint);\n\n    function getPendingSIMDebtReward(address _borrower) external view returns (uint);\n\n     function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(address _borrower) external view returns (\n        uint debt,\n        uint coll,\n        uint pendingSIMDebtReward,\n        uint pendingWSTETHReward\n    );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint);\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint SIMDebt) external view returns (uint);\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n    \n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \n\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \n\n    function getTCR(uint _price) external view returns (uint);\n\n    function checkRecoveryMode(uint _price) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IVe {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n\n//    function increaseF_WSTETH(uint _WSTETHFee) external;\n\n//    function increaseF_SIM(uint _SIMFee) external;\n\n    function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\n\n    function lockedDerivedAmount(uint veId) external view returns (uint);\n\n    function lockedEnd(uint veId) external view returns (uint);\n\n    function tokens(uint idx) external view returns (address);\n\n    function balanceOfNFT(uint) external view returns (uint);\n\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n\n    function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\n\n    function userPointEpoch(uint tokenId) external view returns (uint);\n\n    function epoch() external view returns (uint);\n\n    function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\n\n    function pointHistory(uint loc) external view returns (Point memory);\n\n    function checkpoint() external;\n\n    function increaseAmount(address _token, uint _tokenId, uint _value) external;\n\n    function totalSupplyAt(uint _block) external view returns (uint);\n}"
    },
    "contracts/interfaces/IVeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IVeDistributor {\n\n  function rewardToken() external view returns (address);\n\n  function checkpoint() external;\n\n  function checkpointTotalSupply() external;\n\n  function claim(uint _tokenId) external returns (uint);\n\n}\n"
    },
    "contracts/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/MultiTroveGetter.sol\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n\n        uint debt;\n        uint coll;\n        uint stake;\n\n        uint snapshotETH;\n        uint snapshotLUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(int _startIdx, uint _count)\n        external view returns (CombinedTroveData[] memory _troves)\n    {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n/*\n* https://github.com/liquity/dev/blob/main/packages/contracts/contracts/SortedTroves.sol\n* A sorted doubly linked list with nodes sorted in descending order.\n*\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n* which is like the ICR but without the price, i.e., just collateral / debt.\n*\n* The list optionally accepts insert position hints.\n*\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n* change dynamically as liquidation events occur.\n*\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n* Thus, Nodes remain sorted by current NICR.\n*\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n* to their position.\n*\n* The list is a modification of the following audited SortedDoublyLinkedList:\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n*\n*\n* Changes made in the Liquity implementation:\n*\n* - Keys have been removed from nodes\n*\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\n*\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n*/\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\n    string constant public NAME = \"SortedTroves\";\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId;                  // Id of next node (smaller NICR) in the list\n        address prevId;                  // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize;                     // Maximum size of the list\n        uint256 size;                        // Current size of the list\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters ---\n\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cant be zero\");\n        _checkContract(_troveManagerAddress);\n        _checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\n        }\n\n         data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size = data.size + 1;\n        emit NodeAdded(_id, _NICR);\n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size = data.size - 1;\n        emit NodeRemoved(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return data.nodes[_prevId].nextId == _nextId &&\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\n                   _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"SortedTroves: Caller is not the TroveManager\");\n    }\n\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\n                \"SortedTroves: Caller is neither BO nor TroveM\");\n    }\n}\n"
    },
    "contracts/test/TroveManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n\n    function computeICR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(uint _coll) external pure returns (uint) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getSIMGasCompensation() external pure returns (uint) {\n        return 0/*SIM_GAS_COMPENSATION*/;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing() external returns (uint) {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= DECIMAL_PRECISION);\n        \n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(uint _ETHDrawn) external view returns (uint) {\n        return _getRedemptionFee(_ETHDrawn);\n    }  \n\n    function getActualDebtFromComposite(uint _debtVal) external pure returns (uint) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/test/VeTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../Ve.sol\";\nimport \"../interfaces/ISHADYToken.sol\";\n\ncontract VeTester is Ve {\n    /*function unprotectedCallSHADYSendToVe(address shady_, address sender_, uint256 amount_) external {\n        ISHADYToken(shady_).sendToVe(sender_, amount_);\n    }*/\n}"
    },
    "contracts/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IStabilityPool.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/ISIMToken.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ISHADYToken.sol\";\nimport \"./interfaces/IVeDistributor.sol\";\nimport \"./dependencies/Base.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./VeDistributor.sol\";\n\n// https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\ncontract TroveManager is Base, Ownable, CheckContract, ITroveManager {\n    string constant public NAME = \"TroveManager\";\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public override stabilityPool;\n\n    ICollSurplusPool public collSurplusPool;\n\n    ISIMToken public override simToken;\n\n    ISHADYToken public override shadyToken;\n\n    address public override wstETHVeDistributor;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 30 days;\n\n    /*\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n    * Corresponds to (1 / ALPHA) in the white paper.\n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new SIM issuance)\n    uint public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_WSTETH and L_SIMDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An WSTETH gain of ( stake * [L_WSTETH - L_WSTETH(0)] )\n    * A SIMDebt increase  of ( stake * [L_SIMDebt - L_SIMDebt(0)] )\n    *\n    * Where L_WSTETH(0) and L_SIMDebt(0) are snapshots of L_WSTETH and L_SIMDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_WSTETH;\n    uint public L_SIMDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the WSTETH and SIM snapshots for a given active trove\n    struct RewardSnapshot { uint WSTETH; uint SIMDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastWSTETHError_Redistribution;\n    uint public lastSIMDebtError_Redistribution;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint SIMInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingSIMInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        uint collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        uint totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        ISIMToken simToken;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint remainingSIM;\n        uint totalSIMToRedeem;\n        uint totalWSTETHDrawn;\n        uint WSTETHFee;\n        uint WSTETHToSendToRedeemer;\n        uint decayedBaseRate;\n        uint price;\n        uint totalSIMSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint SIMLot;\n        uint WSTETHLot;\n        bool cancelledPartial;\n    }\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _simTokenAddress,\n        address _sortedTrovesAddress,\n        address _shadyTokenAddress,\n        address _wstEthVeDistributor\n    )\n        external\n        override\n        onlyOwner\n    {\n        _checkContract(_borrowerOperationsAddress);\n        _checkContract(_activePoolAddress);\n        _checkContract(_defaultPoolAddress);\n        _checkContract(_stabilityPoolAddress);\n        _checkContract(_collSurplusPoolAddress);\n        _checkContract(_priceFeedAddress);\n        _checkContract(_simTokenAddress);\n        _checkContract(_sortedTrovesAddress);\n        _checkContract(_shadyTokenAddress);\n        _checkContract(_wstEthVeDistributor);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        simToken = ISIMToken(_simTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        shadyToken = ISHADYToken(_shadyTokenAddress);\n        wstETHVeDistributor = _wstEthVeDistributor;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SIMTokenAddressChanged(_simTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit SHADYTokenAddressChanged(_shadyTokenAddress);\n        emit WSTETHVeDistibutorAddressChanged(_wstEthVeDistributor);\n\n        renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _SIMInStabPool\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        uint collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        (singleLiquidation.debtToOffset,\n        singleLiquidation.collToSendToSP,\n        singleLiquidation.debtToRedistribute,\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _SIMInStabPool);\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInNormalMode));\n        emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInNormalMode));\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _ICR,\n        uint _SIMInStabPool,\n        uint _TCR,\n        uint _price\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\n        (singleLiquidation.entireTroveDebt,\n        singleLiquidation.entireTroveColl,\n        vars.pendingDebtReward,\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n        vars.collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            _removeStake(_borrower);\n\n            (singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _SIMInStabPool);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n        /*\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is SIM in the Stability Pool, only offset, with no redistribution,\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n        * The remainder due to the capped rate will be claimable as collateral surplus.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _SIMInStabPool)) {\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\n            assert(_SIMInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\n            }\n\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.liquidateInRecoveryMode));\n\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _SIMInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _SIMInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_SIMInStabPool > 0) {\n        /*\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited SIM in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the SIM in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _SIMInStabPool);\n            collToSendToSP = _coll * debtToOffset / _debt;\n            debtToRedistribute = _debt - debtToOffset;\n            collToRedistribute = _coll - collToSendToSP;\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  Get its offset coll/debt and WSTETH gas comp, and close the trove.\n    */\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _price\n    )\n        internal\n        pure\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint cappedCollPortion = _entireTroveDebt * MCR / _price;\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\n        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            ISIMToken(address(0)),\n//            IVe(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0))/*,\n            address(0)*/\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.SIMInStabPool, _n);\n        } else { // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.SIMInStabPool, _n);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated WSTETH and SIM to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(contractsCache.activePool, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        ContractsCache memory _contractsCache,\n        uint _price,\n        uint _SIMInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingSIMInStabPool);\n\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.SIMInStabPool = stabilityPoolCached.getTotalSIMDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\n        } else {  //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.SIMInStabPool, _troveArray);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n        // Move liquidated WSTETH and SIM to the appropriate pools\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendWSTETH(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation/*, totals.totalSIMGasCompensation*/);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, /*totals.totalSIMGasCompensation,*/ totals.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) { continue; }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingSIMInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingSIMInStabPool, TCR, _price);\n\n                // Update aggregate trackers\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP - singleLiquidation.collGasCompensation - singleLiquidation.collSurplus;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\n            }\n\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _SIMInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingSIMInStabPool = _SIMInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingSIMInStabPool);\n                vars.remainingSIMInStabPool = vars.remainingSIMInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\n    internal pure returns(LiquidationTotals memory newTotals) {\n\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\n//        newTotals.totalSIMGasCompensation = oldTotals.totalSIMGasCompensation + singleLiquidation.SIMGasCompensation;\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence + singleLiquidation.entireTroveColl;\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, /*uint _SIM,*/ uint _WSTETH) internal {\n        /*if (_SIM > 0) {\n            simToken.returnFromPool(gasPoolAddress, _liquidator, _SIM);\n        }*/\n\n        if (_WSTETH > 0) {\n            _activePool.sendWSTETH(_liquidator, _WSTETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _SIM, uint _WSTETH) internal {\n        _defaultPool.decreaseSIMDebt(_SIM);\n        _activePool.increaseSIMDebt(_SIM);\n        _defaultPool.sendWSTETHToActivePool(_WSTETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for SIM up to _maxSIMamount\n    function _redeemCollateralFromTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint _maxSIMamount,\n        uint _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR\n    )\n        internal returns (SingleRedemptionValues memory singleRedemption)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.SIMLot = LiquityMath._min(_maxSIMamount, Troves[_borrower].debt);\n\n        // Get the WSTETHLot of equivalent value in USD\n        singleRedemption.WSTETHLot = singleRedemption.SIMLot * DECIMAL_PRECISION / _price;\n\n        // Decrease the debt and collateral of the current Trove according to the SIM lot and corresponding WSTETH to send\n        uint newDebt = (Troves[_borrower].debt) - singleRedemption.SIMLot;\n        uint newColl = (Troves[_borrower].coll) - singleRedemption.WSTETHLot;\n\n        if (newDebt == 0) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(_contractsCache, _borrower, newColl);\n            emit TroveUpdated(_borrower, 0, 0, 0, uint8(TroveManagerOperation.redeemCollateral));\n        } else {\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n\n            /*\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n            * certainly result in running out of gas.\n            *\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n            */\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                newDebt, newColl,\n                Troves[_borrower].stake,\n                uint8(TroveManagerOperation.redeemCollateral)\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n    * Called when a full redemption occurs, and closes the trove.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus WSTETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint _WSTETH) internal {\n        // send WSTETH from Active Pool to CollSurplus Pool\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _WSTETH);\n        _contractsCache.activePool.sendWSTETH(address(_contractsCache.collSurplusPool), _WSTETH);\n    }\n\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _SIMamount SIM to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining SIM amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _SIMamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    )\n        external\n        override\n    {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            simToken,\n            sortedTroves,\n            collSurplusPool\n        );\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice();\n        _requireTCRoverMCR(totals.price);\n        _requireAmountGreaterThanZero(_SIMamount);\n        _requireSIMBalanceCoversRedemption(contractsCache.simToken, msg.sender, _SIMamount);\n\n        totals.totalSIMSupplyAtStart = getEntireSystemDebt();\n        // Confirm redeemer's balance is less than total SIM supply\n        assert(contractsCache.simToken.balanceOf(msg.sender) <= totals.totalSIMSupplyAtStart);\n\n        totals.remainingSIM = _SIMamount;\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = contractsCache.sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of SIM is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = type(uint).max; }\n        while (currentBorrower != address(0) && totals.remainingSIM > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\n\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\n                contractsCache,\n                currentBorrower,\n                totals.remainingSIM,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalSIMToRedeem  = totals.totalSIMToRedeem + singleRedemption.SIMLot;\n            totals.totalWSTETHDrawn = totals.totalWSTETHDrawn + singleRedemption.WSTETHLot;\n\n            totals.remainingSIM = totals.remainingSIM - singleRedemption.SIMLot;\n            currentBorrower = nextUserToCheck;\n        }\n        require(totals.totalWSTETHDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total SIM supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(totals.totalWSTETHDrawn, totals.price, totals.totalSIMSupplyAtStart);\n\n        // Calculate the WSTETH fee\n        totals.WSTETHFee = _getRedemptionFee(totals.totalWSTETHDrawn);\n\n        _requireUserAcceptsFee(totals.WSTETHFee, totals.totalWSTETHDrawn, _maxFeePercentage);\n\n        // Send the WSTETH fee to the VeDistributor contract\n        contractsCache.activePool.sendWSTETH(wstETHVeDistributor, totals.WSTETHFee);\n        IVeDistributor(wstETHVeDistributor).checkpoint();\n\n        totals.WSTETHToSendToRedeemer = totals.totalWSTETHDrawn - totals.WSTETHFee;\n\n        emit Redemption(_SIMamount, totals.totalSIMToRedeem, totals.totalWSTETHDrawn, totals.WSTETHFee);\n\n        // Burn the total SIM that is cancelled with debt, and send the redeemed WSTETH to msg.sender\n        contractsCache.simToken.burn(msg.sender, totals.totalSIMToRedeem);\n        // Update Active Pool SIM, and send WSTETH to account\n        contractsCache.activePool.decreaseSIMDebt(totals.totalSIMToRedeem);\n        contractsCache.activePool.sendWSTETH(msg.sender, totals.WSTETHToSendToRedeemer);\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(address _borrower) public view override returns (uint) {\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\n\n        uint NICR = LiquityMath._computeNominalCR(currentWSTETH, currentSIMDebt);\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        (uint currentWSTETH, uint currentSIMDebt) = _getCurrentTroveAmounts(_borrower);\n\n        uint ICR = LiquityMath._computeCR(currentWSTETH, currentSIMDebt, _price);\n        return ICR;\n    }\n\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\n        uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n        uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n\n        uint currentWSTETH = Troves[_borrower].coll + pendingWSTETHReward;\n        uint currentSIMDebt = Troves[_borrower].debt + pendingSIMDebtReward;\n\n        return (currentWSTETH, currentSIMDebt);\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n            uint pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll + pendingWSTETHReward;\n            Troves[_borrower].debt = Troves[_borrower].debt + pendingSIMDebtReward;\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingSIMDebtReward, pendingWSTETHReward);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].coll,\n                Troves[_borrower].stake,\n                uint8(TroveManagerOperation.applyPendingRewards)\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_WSTETH and L_SIMDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].WSTETH = L_WSTETH;\n        rewardSnapshots[_borrower].SIMDebt = L_SIMDebt;\n        emit TroveSnapshotsUpdated(L_WSTETH, L_SIMDebt);\n    }\n\n    // Get the borrower's pending accumulated WSTETH reward, earned by their stake\n    function getPendingWSTETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotWSTETH = rewardSnapshots[_borrower].WSTETH;\n        uint rewardPerUnitStaked = L_WSTETH - snapshotWSTETH;\n\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingWSTETHReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\n\n        return pendingWSTETHReward;\n    }\n\n    // Get the borrower's pending accumulated SIM reward, earned by their stake\n    function getPendingSIMDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotSIMDebt = rewardSnapshots[_borrower].SIMDebt;\n        uint rewardPerUnitStaked = L_SIMDebt - snapshotSIMDebt;\n\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingSIMDebtReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\n\n        return pendingSIMDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /*\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        */\n        if (Troves[_borrower].status != Status.active) {return false;}\n\n        return (rewardSnapshots[_borrower].WSTETH < L_WSTETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingSIMDebtReward, uint pendingWSTETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingSIMDebtReward = getPendingSIMDebtReward(_borrower);\n        pendingWSTETHReward = getPendingWSTETHReward(_borrower);\n\n        debt = debt + pendingSIMDebtReward;\n        coll = coll + pendingWSTETHReward;\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes - stake;\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n        emit TotalStakesUpdated(totalStakes);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_WSTETH and L_SIMDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint WSTETHNumerator = _coll * DECIMAL_PRECISION + lastWSTETHError_Redistribution;\n        uint SIMDebtNumerator = _debt * DECIMAL_PRECISION + lastSIMDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint WSTETHRewardPerUnitStaked = WSTETHNumerator / totalStakes;\n        uint SIMDebtRewardPerUnitStaked = SIMDebtNumerator / totalStakes;\n\n        lastWSTETHError_Redistribution = WSTETHNumerator - WSTETHRewardPerUnitStaked * totalStakes;\n        lastSIMDebtError_Redistribution = SIMDebtNumerator - SIMDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_WSTETH = L_WSTETH + WSTETHRewardPerUnitStaked;\n        L_SIMDebt = L_SIMDebt + SIMDebtRewardPerUnitStaked;\n\n        emit LTermsUpdated(L_WSTETH, L_SIMDebt);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseSIMDebt(_debt);\n        _defaultPool.increaseSIMDebt(_debt);\n        _activePool.sendWSTETH(address(_defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].WSTETH = 0;\n        rewardSnapshots[_borrower].SIMDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    *\n    * the total WSTETH gas compensation from the liquidation sequence\n    *\n    * The WSTETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = _activePool.getWSTETH();\n        uint liquidatedColl = defaultPool.getWSTETH();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum SIM\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 SIM dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length - 1);\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function `_closeTrove`\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length - 1;\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR(uint _price) external view override returns (uint) {\n        return _getTCR(_price);\n    }\n\n    function checkRecoveryMode(uint _price) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an WSTETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or SIM borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _WSTETHDrawn,  uint _price, uint _totalSIMSupply) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn WSTETH back to SIM at face value rate (1 SIM:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedSIMFraction = _WSTETHDrawn * _price / _totalSIMSupply;\n\n        uint newBaseRate = decayedBaseRate + redeemedSIMFraction / BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _WSTETHDrawn) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _WSTETHDrawn);\n    }\n\n    function getRedemptionFeeWithDecay(uint _WSTETHDrawn) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _WSTETHDrawn);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _WSTETHDrawn) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate * _WSTETHDrawn / DECIMAL_PRECISION;\n        require(redemptionFee < _WSTETHDrawn, \"TroveManager: Fee would eat up all returned collateral\");\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR + _baseRate,\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _SIMDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _SIMDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _SIMDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _SIMDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _SIMDebt) internal pure returns (uint) {\n        return _borrowingRate * _SIMDebt / DECIMAL_PRECISION;\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or SIM borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp - lastFeeOperationTime;\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp - lastFeeOperationTime) / SECONDS_IN_ONE_MINUTE;\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireSIMBalanceCoversRedemption(ISIMToken _simToken, address _redeemer, uint _amount) internal view {\n        require(_simToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's SIM token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    function _requireTCRoverMCR(uint _price) internal view {\n        require(_getTCR(_price) >= MCR, \"TroveManager: Cannot redeem when TCR < MCR\");\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = shadyToken.getDeploymentStartTime();\n        require(block.timestamp >= systemDeploymentTime + BOOTSTRAP_PERIOD, \"TroveManager: Redemptions are not allowed during bootstrap phase\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal pure {\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll + _collIncrease;\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll - _collDecrease;\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt + _debtIncrease;\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt - _debtDecrease;\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "contracts/Ve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IVe.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/FixedPointMathLib.sol\";\nimport \"./dependencies/ControllableV3.sol\";\nimport \"./dependencies/VeLogo.sol\";\n\n// https://github.com/tetu-io/tetu-contracts-v2/blob/master/contracts/ve/VeTetu.sol\ncontract Ve is ControllableV3, ReentrancyGuardUpgradeable, CheckContract, IERC721, IERC721Metadata, IVe {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint;\n    using FixedPointMathLib for int128;\n\n    // Only for internal usage\n    struct DepositInfo {\n        address stakingToken;\n        uint tokenId;\n        uint value;\n        uint unlockTime;\n        uint lockedAmount;\n        uint lockedDerivedAmount;\n        uint lockedEnd;\n        DepositType depositType;\n    }\n\n    // Only for internal usage\n    struct CheckpointInfo {\n        uint tokenId;\n        uint oldDerivedAmount;\n        uint newDerivedAmount;\n        uint oldEnd;\n        uint newEnd;\n    }\n\n    enum TimeLockType {\n        UNKNOWN,\n        ADD_TOKEN,\n        WHITELIST_TRANSFER\n    }\n\n    /// @dev Version of this contract. Adjust manually on each code modification.\n    string public constant VE_VERSION = \"1.0.0\";\n    uint internal constant WEEK = 1 weeks;\n    uint internal constant MAX_TIME = 16 weeks;\n    int128 internal constant I_MAX_TIME = 16 weeks;\n    uint internal constant MULTIPLIER = 1 ether;\n    uint internal constant WEIGHT_DENOMINATOR = 100e18;\n    uint public constant MAX_ATTACHMENTS = 1;\n    uint public constant GOV_ACTION_TIME_LOCK = 18 hours;\n    string constant public override name = \"xSHADY\";\n    string constant public override symbol = \"xSHADY\";\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant _ERC721_INTERFACE_ID = 0x80ac58cd;\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    // *************************************************************\n    //                        VARIABLES\n    //                Keep names and ordering!\n    //                 Add only in the bottom.\n    // *************************************************************\n    address public troveManagerAddress;\n    address public borrowerOperationsAddress;\n    address public shadyAddress;\n\n    /// @dev Underlying tokens info\n    address[] public override tokens;\n    /// @dev token => weight\n    mapping(address => uint) public tokenWeights;\n    /// @dev token => is allowed for deposits\n    mapping(address => bool) public isValidToken;\n    /// @dev Current count of token\n    uint public tokenId;\n    /// @dev veId => stakingToken => Locked amount\n    mapping(uint => mapping(address => uint)) public override lockedAmounts;\n    /// @dev veId => Amount based on weights aka power\n    mapping(uint => uint) public override lockedDerivedAmount;\n    /// @dev veId => Lock end timestamp\n    mapping(uint => uint) public override lockedEnd;\n\n    // --- CHECKPOINTS LOGIC\n\n    /// @dev Epoch counter. Update each week.\n    uint public override epoch;\n    /// @dev epoch -> unsigned point\n    mapping(uint => Point) internal _pointHistory;\n    /// @dev user -> Point[userEpoch]\n    mapping(uint => Point[1000000000]) internal _userPointHistory;\n    /// @dev veId -> Personal epoch counter\n    mapping(uint => uint) public override userPointEpoch;\n    /// @dev time -> signed slope change\n    mapping(uint => int128) public slopeChanges;\n\n    // --- LOCK\n\n    /// @dev veId -> votes counter. With votes NFT unable to transfer\n    /// deprecated\n    mapping(uint => uint) public _deprecated_voted;\n\n    // --- STATISTICS\n\n    /// @dev veId -> Block number when last time NFT owner changed\n    mapping(uint => uint) public ownershipChange;\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal _idToOwner;\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal _idToApprovals;\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal _ownerToNFTokenCount;\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal _ownerToNFTokenIdList;\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) public tokenToOwnerIndex;\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) public ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal _supportedInterfaces;\n\n    // --- PERMISSIONS\n\n    /// @dev Whitelisted contracts will be able to transfer NFTs\n    mapping(address => bool) public isWhitelistedTransfer;\n    /// @dev Time-locks for governance actions. Zero means not announced and should not processed.\n    mapping(TimeLockType => uint) public govActionTimeLock;\n    /// @dev underlying token => true if we can stake token to some place, false if paused\n    mapping(address => bool) internal tokenFarmingStatus;\n\n    // *************************************************************\n    //                        EVENTS\n    // *************************************************************\n\n    event Deposit(\n        address indexed stakingToken,\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType depositType,\n        uint ts\n    );\n    event Withdraw(address indexed stakingToken, address indexed provider, uint tokenId, uint value, uint ts);\n    event Merged(address indexed stakingToken, address indexed provider, uint from, uint to);\n    event Split(uint parentTokenId, uint newTokenId, uint percent);\n    event TransferWhitelisted(address value);\n    event StakingTokenAdded(address value, uint weight);\n    event GovActionAnnounced(uint _type, uint timeToExecute);\n\n    // *************************************************************\n    //                        INIT\n    // *************************************************************\n\n\n    function setAddresses(\n        address troveManagerAddress_,\n        address borrowerOperationsAddress_,\n        address shadyAddress_,\n        address controller_\n    ) external initializer {\n        // the first token should have 18 decimals\n        require(IERC20Metadata(shadyAddress_).decimals() == uint8(18));\n\n        _checkContract(troveManagerAddress_);\n        _checkContract(borrowerOperationsAddress_);\n        _checkContract(shadyAddress_);\n\n        __Controllable_init(controller_);\n        __ReentrancyGuard_init();\n\n        troveManagerAddress = troveManagerAddress_;\n        borrowerOperationsAddress = borrowerOperationsAddress_;\n        shadyAddress = shadyAddress_;\n\n        _pointHistory[0].blk = block.number;\n        _pointHistory[0].ts = block.timestamp;\n        _addToken(shadyAddress_, 100e18);\n\n        _supportedInterfaces[_ERC165_INTERFACE_ID] = true;\n        _supportedInterfaces[_ERC721_INTERFACE_ID] = true;\n        _supportedInterfaces[_ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), 0);\n        // burn-ish\n        emit Transfer(address(this), address(0), 0);\n    }\n\n    // *************************************************************\n    //                        GOVERNANCE ACTIONS\n    // *************************************************************\n\n    function announceAction(TimeLockType _type) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        require(govActionTimeLock[_type] == 0 && _type != TimeLockType.UNKNOWN, \"WRONG_INPUT\");\n\n        govActionTimeLock[_type] = block.timestamp + GOV_ACTION_TIME_LOCK;\n        emit GovActionAnnounced(uint(_type), block.timestamp + GOV_ACTION_TIME_LOCK);\n    }\n\n    /// @dev Whitelist address for transfers. Removing from whitelist should be forbidden.\n    function whitelistTransferFor(address value) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        require(value != address(0), \"WRONG_INPUT\");\n        uint timeLock = govActionTimeLock[TimeLockType.WHITELIST_TRANSFER];\n        require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n        isWhitelistedTransfer[value] = true;\n        govActionTimeLock[TimeLockType.WHITELIST_TRANSFER] = 0;\n\n        emit TransferWhitelisted(value);\n    }\n\n    function addToken(address token, uint weight) external {\n        require(isGovernance(msg.sender), \"FORBIDDEN\");\n        uint timeLock = govActionTimeLock[TimeLockType.ADD_TOKEN];\n        require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n        _addToken(token, weight);\n        govActionTimeLock[TimeLockType.ADD_TOKEN] = 0;\n    }\n\n    function _addToken(address token, uint weight) internal {\n        require(token != address(0) && weight != 0, \"WRONG_INPUT\");\n        _requireERC20(token);\n\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            require(token != tokens[i], \"WRONG_INPUT\");\n        }\n\n        tokens.push(token);\n        tokenWeights[token] = weight;\n        isValidToken[token] = true;\n\n        emit StakingTokenAdded(token, weight);\n    }\n\n    // *************************************************************\n    //                        VIEWS\n    // *************************************************************\n\n    /// @dev Return length of staking tokens.\n    function tokensLength() external view returns (uint) {\n        return tokens.length;\n    }\n\n    /// @dev Current block timestamp\n    function blockTimestamp() external view returns (uint) {\n        return block.timestamp;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) public view override(ControllableV3, IERC165) returns (bool) {\n        return _supportedInterfaces[_interfaceID]\n        || _interfaceID == InterfaceIds.I_VE\n            || super.supportsInterface(_interfaceID);\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function getLastUserSlope(uint _tokenId) external view returns (int128) {\n        uint uEpoch = userPointEpoch[_tokenId];\n        return _userPointHistory[_tokenId][uEpoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function userPointHistoryTs(uint _tokenId, uint _idx) external view returns (uint) {\n        return _userPointHistory[_tokenId][_idx].ts;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return _ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view override returns (uint) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view override returns (address) {\n        return _idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId) external view override returns (address) {\n        return _idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n        return _ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID,\n    ///              is an operator of the owner, or is the owner of the token\n    function isApprovedOrOwner(address _spender, uint _tokenId) public view override returns (bool) {\n        address owner = _idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == _idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function balanceOfNFT(uint _tokenId) public view override returns (uint) {\n        // flash NFT protection\n        if (ownershipChange[_tokenId] == block.number) {\n            return 0;\n        }\n        return _balanceOfNFT(_tokenId, block.timestamp);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return _balanceOfNFT(_tokenId, _t);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return _balanceOfAtNFT(_tokenId, _block);\n    }\n\n    function userPointHistory(uint _tokenId, uint _loc) external view override returns (Point memory) {\n        return _userPointHistory[_tokenId][_loc];\n    }\n\n    function pointHistory(uint _loc) external view override returns (Point memory) {\n        return _pointHistory[_loc];\n    }\n\n    // *************************************************************\n    //                        NFT LOGIC\n    // *************************************************************\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint currentCount = _balance(_to);\n\n        _ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint currentCount = _balance(_from) - 1;\n        uint currentIndex = tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = _ownerToNFTokenIdList[_from][currentCount];\n\n            // Add\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            _ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // assume always call on new tokenId or after _removeTokenFrom() call\n        // Change the owner\n        _idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        _ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        require(_idToOwner[_tokenId] == _from, \"NOT_OWNER\");\n        // Change the owner\n        _idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        _ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Execute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal {\n        require(isApprovedOrOwner(_sender, _tokenId), \"NOT_OWNER\");\n        require(_to != address(0), \"WRONG_INPUT\");\n        // from address will be checked in _removeTokenFrom()\n\n        if (_idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            _idToApprovals[_tokenId] = address(0);\n        }\n        _removeTokenFrom(_from, _tokenId);\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownershipChange[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev Transfers forbidden for veTETU\n    function transferFrom(\n        address,\n        address,\n        uint\n    ) external pure override {\n        revert(\"FORBIDDEN\");\n        //    _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public override {\n        require(isWhitelistedTransfer[_to] || isWhitelistedTransfer[_from], \"FORBIDDEN\");\n\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n        require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /// @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n    /// The call is not executed if the target address is not a contract.\n    ///\n    /// @param _from address representing the previous owner of the given token ID\n    /// @param _to target address that will receive the tokens\n    /// @param _tokenId uint256 ID of the token to be transferred\n    /// @param _data bytes optional data to send along with the call\n    /// @return bool whether the call correctly returned the expected magic value\n    ///\n    function _checkOnERC721Received(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (_isContract(_to)) {\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external override {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) public override {\n        address owner = _idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0), \"WRONG_INPUT\");\n        // Throws if `_approved` is the current owner\n        require(_approved != owner, \"IDENTICAL_ADDRESS\");\n        // Check requirements\n        bool senderIsOwner = (owner == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll, \"NOT_OWNER\");\n        // Set the approval\n        _idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved) external override {\n        // Throws if `_operator` is the `msg.sender`\n        require(_operator != msg.sender, \"IDENTICAL_ADDRESS\");\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        require(_to != address(0), \"WRONG_INPUT\");\n        _addTokenTo(_to, _tokenId);\n        require(_checkOnERC721Received(address(0), _to, _tokenId, ''), \"ERC721: transfer to non ERC721Receiver implementer\");\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    function _checkpoint(CheckpointInfo memory info) internal {\n        Point memory uOld;\n        Point memory uNew;\n        int128 oldDSlope = 0;\n        int128 newDSlope = 0;\n        uint _epoch = epoch;\n\n        if (info.tokenId != 0) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (info.oldEnd > block.timestamp && info.oldDerivedAmount > 0) {\n                uOld.slope = int128(uint128(info.oldDerivedAmount)) / I_MAX_TIME;\n                uOld.bias = uOld.slope * int128(int256(info.oldEnd - block.timestamp));\n            }\n            if (info.newEnd > block.timestamp && info.newDerivedAmount > 0) {\n                uNew.slope = int128(uint128(info.newDerivedAmount)) / I_MAX_TIME;\n                uNew.bias = uNew.slope * int128(int256(info.newEnd - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDSlope = slopeChanges[info.oldEnd];\n            if (info.newEnd != 0) {\n                if (info.newEnd == info.oldEnd) {\n                    newDSlope = oldDSlope;\n                } else {\n                    newDSlope = slopeChanges[info.newEnd];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n        if (_epoch > 0) {\n            lastPoint = _pointHistory[_epoch];\n        }\n        uint lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint = lastPoint;\n        uint blockSlope = 0;\n        // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint ti = (lastCheckpoint / WEEK) * WEEK;\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            for (uint i = 0; i < 255; ++i) {\n                ti += WEEK;\n                int128 dSlope = 0;\n                if (ti > block.timestamp) {\n                    ti = block.timestamp;\n                } else {\n                    dSlope = slopeChanges[ti];\n                }\n                lastPoint.bias = (lastPoint.bias - lastPoint.slope * int128(int256(ti - lastCheckpoint))).positiveInt128();\n                lastPoint.slope = (lastPoint.slope + dSlope).positiveInt128();\n                lastCheckpoint = ti;\n                lastPoint.ts = ti;\n                lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (ti == block.timestamp) {\n                    lastPoint.blk = block.number;\n                    break;\n                } else {\n                    _pointHistory[_epoch] = lastPoint;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now pointHistory is filled until t=now\n\n        if (info.tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope = (lastPoint.slope + (uNew.slope - uOld.slope)).positiveInt128();\n            lastPoint.bias = (lastPoint.bias + (uNew.bias - uOld.bias)).positiveInt128();\n        }\n\n        // Record the changed point into history\n        _pointHistory[_epoch] = lastPoint;\n\n        if (info.tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract newUserSlope from [newLocked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (info.oldEnd > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                oldDSlope += uOld.slope;\n                if (info.newEnd == info.oldEnd) {\n                    oldDSlope -= uNew.slope;\n                    // It was a new deposit, not extension\n                }\n                slopeChanges[info.oldEnd] = oldDSlope;\n            }\n\n            if (info.newEnd > block.timestamp) {\n                if (info.newEnd > info.oldEnd) {\n                    newDSlope -= uNew.slope;\n                    // old slope disappeared at this point\n                    slopeChanges[info.newEnd] = newDSlope;\n                }\n                // else: we recorded it already in oldDSlope\n            }\n            // Now handle user history\n            uint userEpoch = userPointEpoch[info.tokenId] + 1;\n\n            userPointEpoch[info.tokenId] = userEpoch;\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            _userPointHistory[info.tokenId][userEpoch] = uNew;\n        }\n    }\n\n    // *************************************************************\n    //                  DEPOSIT/WITHDRAW LOGIC\n    // *************************************************************\n\n    /// @dev Pull tokens to this contract and try to stake\n    function _pullStakingToken(address _token, address _from, uint amount) internal {\n        IERC20(_token).safeTransferFrom(_from, address(this), amount);\n\n        // try to stake tokens if possible\n//        _stakeAvailableTokens(_token);\n    }\n\n    /// @dev Anyone can stake whitelisted tokens if they exist on this contract.\n    /*function stakeAvailableTokens(address _token) external {\n        _stakeAvailableTokens(_token);\n    }*/\n\n    /// @dev If allowed, stake given token available balance to suitable place for earn some profit\n    /*function _stakeAvailableTokens(address _token) internal {\n        if (tokenFarmingStatus[_token]) {\n            if (_token == _TETU_USDC_BPT) {\n                uint balance = IERC20(_token).balanceOf(address(this));\n                if (balance != 0) {\n                    IERC20(_token).safeApprove(_TETU_USDC_BPT_VAULT, balance);\n                    ISmartVault(_TETU_USDC_BPT_VAULT).depositAndInvest(balance);\n                }\n            }\n        }\n    }*/\n\n    /// @dev Unstake necessary amount, if possible\n    /*function _unstakeTokens(address _token, uint amount) internal {\n        uint tokenBalance = IERC20(_token).balanceOf(address(this));\n        if (amount != 0 && amount > tokenBalance) {\n            // withdraw only required amount\n            amount -= tokenBalance;\n            // no need to check whitelisting for withdraw\n            if (_token == _TETU_USDC_BPT) {\n                // add gap value for avoid rounding issues\n                uint shares = amount * 1e18 / ISmartVault(_TETU_USDC_BPT_VAULT).getPricePerFullShare() + 1e18;\n                uint sharesBalance = IERC20(_TETU_USDC_BPT_VAULT).balanceOf(address(this));\n                shares = shares > sharesBalance ? sharesBalance : shares;\n                ISmartVault(_TETU_USDC_BPT_VAULT).withdraw(shares);\n            }\n        }\n    }*/\n\n    /// @dev Anyone can withdraw all staked tokens if farming status = false\n    /*function emergencyWithdrawStakedTokens(address _token) external {\n        if (!tokenFarmingStatus[_token]) {\n            if (_token == _TETU_USDC_BPT) {\n                ISmartVault(_TETU_USDC_BPT_VAULT).exit();\n            }\n        }\n    }*/\n\n    /// @dev Transfer underlying token to recipient, unstake if need required amount\n    function _transferUnderlyingToken(address _token, address recipient, uint amount) internal {\n//        _unstakeTokens(_token, amount);\n        IERC20(_token).safeTransfer(recipient, amount);\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    function _depositFor(DepositInfo memory info) internal {\n\n        uint newLockedDerivedAmount = info.lockedDerivedAmount;\n        if (info.value != 0) {\n\n            // calculate new amounts\n            uint newAmount = info.lockedAmount + info.value;\n            newLockedDerivedAmount = _calculateDerivedAmount(\n                info.lockedAmount,\n                info.lockedDerivedAmount,\n                newAmount,\n                tokenWeights[info.stakingToken],\n                IERC20Metadata(info.stakingToken).decimals()\n            );\n            // update chain info\n            lockedAmounts[info.tokenId][info.stakingToken] = newAmount;\n            lockedDerivedAmount[info.tokenId] = newLockedDerivedAmount;\n        }\n\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        uint newLockedEnd = info.lockedEnd;\n        if (info.unlockTime != 0) {\n            lockedEnd[info.tokenId] = info.unlockTime;\n            newLockedEnd = info.unlockTime;\n        }\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            info.tokenId,\n            info.lockedDerivedAmount,\n            newLockedDerivedAmount,\n            info.lockedEnd,\n            newLockedEnd\n        ));\n\n        // move tokens to this contract, if necessary\n        address from = msg.sender;\n        if (info.value != 0 && info.depositType != DepositType.MERGE_TYPE) {\n            _pullStakingToken(info.stakingToken, from, info.value);\n        }\n\n        emit Deposit(info.stakingToken, from, info.tokenId, info.value, newLockedEnd, info.depositType, block.timestamp);\n    }\n\n    function _calculateDerivedAmount(\n        uint currentAmount,\n        uint oldDerivedAmount,\n        uint newAmount,\n        uint weight,\n        uint8 decimals\n    ) internal pure returns (uint) {\n        // subtract current derived balance\n        // rounded to UP for subtracting closer to 0 value\n        if (oldDerivedAmount != 0 && currentAmount != 0) {\n            currentAmount = currentAmount.divWadUp(10 ** decimals);\n            uint currentDerivedAmount = currentAmount.mulDivUp(weight, WEIGHT_DENOMINATOR);\n            if (oldDerivedAmount > currentDerivedAmount) {\n                oldDerivedAmount -= currentDerivedAmount;\n            } else {\n                // in case of wrong rounding better to set to zero than revert\n                oldDerivedAmount = 0;\n            }\n        }\n\n        // recalculate derived amount with new amount\n        // rounded to DOWN\n        // normalize decimals to 18\n        newAmount = newAmount.divWadDown(10 ** decimals);\n        // calculate the final amount based on the weight\n        newAmount = newAmount.mulDivDown(weight, WEIGHT_DENOMINATOR);\n        return oldDerivedAmount + newAmount;\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external override {\n        _checkpoint(CheckpointInfo(0, 0, 0, 0, 0));\n    }\n\n    function _lockInfo(address stakingToken, uint veId) internal view returns (\n        uint _lockedAmount,\n        uint _lockedDerivedAmount,\n        uint _lockedEnd\n    ) {\n        _lockedAmount = lockedAmounts[veId][stakingToken];\n        _lockedDerivedAmount = lockedDerivedAmount[veId];\n        _lockedEnd = lockedEnd[veId];\n    }\n\n    function _incrementTokenIdAndGet() internal returns (uint){\n        uint current = tokenId;\n        tokenId = current + 1;\n        return current + 1;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _createLock(address _token, uint _value, uint _lockDuration, address _to) internal returns (uint) {\n        require(_value > 0, \"WRONG_INPUT\");\n        // Lock time is rounded down to weeks\n        uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n        require(unlockTime > block.timestamp, \"LOW_LOCK_PERIOD\");\n        require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n        require(isValidToken[_token], \"INVALID_TOKEN\");\n\n        uint _tokenId = _incrementTokenIdAndGet();\n        _mint(_to, _tokenId);\n\n        _depositFor(DepositInfo({\n            stakingToken: _token,\n            tokenId: _tokenId,\n            value: _value,\n            unlockTime: unlockTime,\n            lockedAmount: 0,\n            lockedDerivedAmount: 0,\n            lockedEnd: 0,\n            depositType: DepositType.CREATE_LOCK_TYPE\n        }));\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function createLockFor(address _token, uint _value, uint _lockDuration, address _to)\n    external nonReentrant override returns (uint) {\n        return _createLock(_token, _value, _lockDuration, _to);\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    function createLock(address _token, uint _value, uint _lockDuration) external nonReentrant returns (uint) {\n        return _createLock(_token, _value, _lockDuration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _token Token for deposit. Should be whitelisted in this contract.\n    /// @param _tokenId ve token ID\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increaseAmount(address _token, uint _tokenId, uint _value) external nonReentrant override {\n        require(_value > 0, \"WRONG_INPUT\");\n        (uint _lockedAmount, uint _lockedDerivedAmount, uint _lockedEnd) = _lockInfo(_token, _tokenId);\n\n        require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n        require(isValidToken[_token], \"INVALID_TOKEN\");\n\n        _depositFor(DepositInfo({\n            stakingToken: _token,\n            tokenId: _tokenId,\n            value: _value,\n            unlockTime: 0,\n            lockedAmount: _lockedAmount,\n            lockedDerivedAmount: _lockedDerivedAmount,\n            lockedEnd: _lockedEnd,\n            depositType: DepositType.INCREASE_LOCK_AMOUNT\n        }));\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _tokenId ve token ID\n    /// @param _lockDuration New number of seconds until tokens unlock\n    function increaseUnlockTime(uint _tokenId, uint _lockDuration) external nonReentrant returns (\n        uint power,\n        uint unlockDate\n    )  {\n        uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n        uint _lockedEnd = lockedEnd[_tokenId];\n        // Lock time is rounded down to weeks\n        uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n        require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n        require(unlockTime > _lockedEnd, \"LOW_UNLOCK_TIME\");\n        require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n        require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n\n        _depositFor(DepositInfo({\n            stakingToken: address(0),\n            tokenId: _tokenId,\n            value: 0,\n            unlockTime: unlockTime,\n            lockedAmount: 0,\n            lockedDerivedAmount: _lockedDerivedAmount,\n            lockedEnd: _lockedEnd,\n            depositType: DepositType.INCREASE_UNLOCK_TIME\n        }));\n\n        power = balanceOfNFT(_tokenId);\n        unlockDate = lockedEnd[_tokenId];\n    }\n\n    /// @dev Merge two NFTs union their balances and keep the biggest lock time.\n    function merge(uint _from, uint _to) external nonReentrant {\n//        require(attachments[_from] == 0 && !isVoted(_from), \"ATTACHED\");\n        require(_from != _to, \"IDENTICAL_ADDRESS\");\n        require(_idToOwner[_from] == msg.sender && _idToOwner[_to] == msg.sender, \"NOT_OWNER\");\n\n        uint lockedEndFrom = lockedEnd[_from];\n        uint lockedEndTo = lockedEnd[_to];\n        require(lockedEndFrom > block.timestamp && lockedEndTo > block.timestamp, \"EXPIRED\");\n        uint end = lockedEndFrom >= lockedEndTo ? lockedEndFrom : lockedEndTo;\n        uint oldDerivedAmount = lockedDerivedAmount[_from];\n\n        uint length = tokens.length;\n        // we should use the old one for properly calculate checkpoint for the new ve\n        uint newLockedEndTo = lockedEndTo;\n        for (uint i; i < length; i++) {\n            address stakingToken = tokens[i];\n            uint _lockedAmountFrom = lockedAmounts[_from][stakingToken];\n            if (_lockedAmountFrom == 0) {\n                continue;\n            }\n            lockedAmounts[_from][stakingToken] = 0;\n\n            _depositFor(DepositInfo({\n                stakingToken: stakingToken,\n                tokenId: _to,\n                value: _lockedAmountFrom,\n                unlockTime: end,\n                lockedAmount: lockedAmounts[_to][stakingToken],\n                lockedDerivedAmount: lockedDerivedAmount[_to],\n                lockedEnd: newLockedEndTo,\n                depositType: DepositType.MERGE_TYPE\n            }));\n\n            // set new lock time to the current end lock\n            newLockedEndTo = end;\n\n            emit Merged(stakingToken, msg.sender, _from, _to);\n        }\n\n        lockedDerivedAmount[_from] = 0;\n        lockedEnd[_from] = 0;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _from,\n            oldDerivedAmount,\n            0,\n            lockedEndFrom,\n            lockedEndFrom\n        ));\n\n        _burn(_from);\n    }\n\n    /// @dev Split given veNFT. A new NFT will have a given percent of underlying tokens.\n    /// @param _tokenId ve token ID\n    /// @param percent percent of underlying tokens for new NFT with denominator 1e18 (1-(100e18-1)).\n    function split(uint _tokenId, uint percent) external nonReentrant {\n//        require(attachments[_tokenId] == 0 && !isVoted(_tokenId), \"ATTACHED\");\n        require(_idToOwner[_tokenId] == msg.sender, \"NOT_OWNER\");\n        require(percent != 0 && percent < 100e18, \"WRONG_INPUT\");\n\n        uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n        uint oldLockedDerivedAmount = _lockedDerivedAmount;\n        uint _lockedEnd = lockedEnd[_tokenId];\n\n        require(_lockedEnd > block.timestamp, \"EXPIRED\");\n\n        // crete new NFT\n        uint _newTokenId = _incrementTokenIdAndGet();\n        _mint(msg.sender, _newTokenId);\n\n        // migrate percent of locked tokens to the new NFT\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            address stakingToken = tokens[i];\n            uint _lockedAmount = lockedAmounts[_tokenId][stakingToken];\n            if (_lockedAmount == 0) {\n                continue;\n            }\n            uint amountForNewNFT = _lockedAmount * percent / 100e18;\n            require(amountForNewNFT != 0, \"LOW_PERCENT\");\n\n            uint newLockedDerivedAmount = _calculateDerivedAmount(\n                _lockedAmount,\n                _lockedDerivedAmount,\n                _lockedAmount - amountForNewNFT,\n                tokenWeights[stakingToken],\n                IERC20Metadata(stakingToken).decimals()\n            );\n\n            _lockedDerivedAmount = newLockedDerivedAmount;\n\n            lockedAmounts[_tokenId][stakingToken] = _lockedAmount - amountForNewNFT;\n\n            // increase values for new NFT\n            _depositFor(DepositInfo({\n                stakingToken: stakingToken,\n                tokenId: _newTokenId,\n                value: amountForNewNFT,\n                unlockTime: _lockedEnd,\n                lockedAmount: 0,\n                lockedDerivedAmount: lockedDerivedAmount[_newTokenId],\n                lockedEnd: _lockedEnd,\n                depositType: DepositType.MERGE_TYPE\n            }));\n        }\n\n        // update derived amount\n        lockedDerivedAmount[_tokenId] = _lockedDerivedAmount;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _tokenId,\n            oldLockedDerivedAmount,\n            _lockedDerivedAmount,\n            _lockedEnd,\n            _lockedEnd\n        ));\n\n        emit Split(_tokenId, _newTokenId, percent);\n    }\n\n    /// @notice Withdraw all staking tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdrawAll(uint _tokenId) external {\n        uint length = tokens.length;\n        for (uint i; i < length; ++i) {\n            address token = tokens[i];\n            if (lockedAmounts[_tokenId][token] != 0) {\n                withdraw(token, _tokenId);\n            }\n        }\n    }\n\n    /// @notice Withdraw given staking token for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(address stakingToken, uint _tokenId) public nonReentrant {\n        require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n//        require(attachments[_tokenId] == 0 && !isVoted(_tokenId), \"ATTACHED\");\n\n        (uint oldLockedAmount, uint oldLockedDerivedAmount, uint oldLockedEnd) =\n                        _lockInfo(stakingToken, _tokenId);\n        require(block.timestamp >= oldLockedEnd, \"NOT_EXPIRED\");\n        require(oldLockedAmount > 0, \"ZERO_LOCKED\");\n\n\n        uint newLockedDerivedAmount = _calculateDerivedAmount(\n            oldLockedAmount,\n            oldLockedDerivedAmount,\n            0,\n            tokenWeights[stakingToken],\n            IERC20Metadata(stakingToken).decimals()\n        );\n\n        // if no tokens set lock to zero\n        uint newLockEnd = oldLockedEnd;\n        if (newLockedDerivedAmount == 0) {\n            lockedEnd[_tokenId] = 0;\n            newLockEnd = 0;\n        }\n\n        // update derived amount\n        lockedDerivedAmount[_tokenId] = newLockedDerivedAmount;\n\n        // set locked amount to zero, we will withdraw all\n        lockedAmounts[_tokenId][stakingToken] = 0;\n\n        // update checkpoint\n        _checkpoint(CheckpointInfo(\n            _tokenId,\n            oldLockedDerivedAmount,\n            newLockedDerivedAmount,\n            oldLockedEnd,\n            newLockEnd\n        ));\n\n        // Burn the NFT\n        if (newLockedDerivedAmount == 0) {\n            _burn(_tokenId);\n        }\n\n        _transferUnderlyingToken(stakingToken, msg.sender, oldLockedAmount);\n\n        emit Withdraw(stakingToken, msg.sender, _tokenId, oldLockedAmount, block.timestamp);\n    }\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /// @notice Binary search to estimate timestamp for block number\n    /// @param _block Block to find\n    /// @param maxEpoch Don't go beyond this epoch\n    /// @return Approximate timestamp for block\n    function _findBlockEpoch(uint _block, uint maxEpoch) internal view returns (uint) {\n        // Binary search\n        uint _min = 0;\n        uint _max = maxEpoch;\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_pointHistory[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n        uint _epoch = userPointEpoch[_tokenId];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\n            require(_t >= lastPoint.ts, \"WRONG_INPUT\");\n            lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint(int256(lastPoint.bias));\n        }\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId) external view override returns (string memory) {\n        require(_idToOwner[_tokenId] != address(0), \"TOKEN_NOT_EXIST\");\n\n        uint _lockedEnd = lockedEnd[_tokenId];\n        return\n            VeLogo.tokenURI(\n            _tokenId,\n            uint(int256(lockedDerivedAmount[_tokenId])),\n            block.timestamp < _lockedEnd ? _lockedEnd - block.timestamp : 0,\n            _balanceOfNFT(_tokenId, block.timestamp)\n        );\n    }\n\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    /// @param _tokenId User's wallet NFT\n    /// @param _block Block to calculate the voting power at\n    /// @return Voting power\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        require(_block <= block.number, \"WRONG_INPUT\");\n\n        // Binary search\n        uint _min = 0;\n        uint _max = userPointEpoch[_tokenId];\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_userPointHistory[_tokenId][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory uPoint = _userPointHistory[_tokenId][_min];\n\n        uint maxEpoch = epoch;\n        uint _epoch = _findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = _pointHistory[_epoch];\n        uint dBlock = 0;\n        uint dt = 0;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = _pointHistory[_epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dt = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dt = block.timestamp - point0.ts;\n        }\n        uint blockTime = point0.ts;\n        if (dBlock != 0 && _block > point0.blk) {\n            blockTime += (dt * (_block - point0.blk)) / dBlock;\n        }\n\n        uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\n        return uint(uint128(uPoint.bias.positiveInt128()));\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param point The point (bias/slope) to start search from\n    /// @param t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function _supplyAt(Point memory point, uint t) internal view returns (uint) {\n        Point memory lastPoint = point;\n        uint ti = (lastPoint.ts / WEEK) * WEEK;\n        for (uint i = 0; i < 255; ++i) {\n            ti += WEEK;\n            int128 dSlope = 0;\n            if (ti > t) {\n                ti = t;\n            } else {\n                dSlope = slopeChanges[ti];\n            }\n            lastPoint.bias -= lastPoint.slope * int128(int256(ti - lastPoint.ts));\n            if (ti == t) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = ti;\n        }\n        return uint(uint128(lastPoint.bias.positiveInt128()));\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        uint _epoch = epoch;\n        Point memory lastPoint = _pointHistory[_epoch];\n        return _supplyAt(lastPoint, t);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view override returns (uint) {\n        require(_block <= block.number, \"WRONG_INPUT\");\n        uint _epoch = epoch;\n        uint targetEpoch = _findBlockEpoch(_block, _epoch);\n\n        Point memory point = _pointHistory[targetEpoch];\n        // it is possible only for a block before the launch\n        // return 0 as more clear answer than revert\n        if (point.blk > _block) {\n            return 0;\n        }\n        uint dt = 0;\n        if (targetEpoch < _epoch) {\n            Point memory pointNext = _pointHistory[targetEpoch + 1];\n            // next point block can not be the same or lower\n            dt = ((_block - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n        } else {\n            if (point.blk != block.number) {\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dt);\n    }\n\n    function _burn(uint _tokenId) internal {\n        address owner = ownerOf(_tokenId);\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(owner, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n}\n"
    },
    "contracts/VeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVe.sol\";\nimport \"./interfaces/IVeDistributor.sol\";\nimport \"./dependencies/ControllableV3.sol\";\n\n// https://github.com/tetu-io/tetu-contracts-v2/blob/master/contracts/ve/VeDistributor.sol\n/// @title Contract for distributing rewards to ve holders.\n///        Rewards will be staked to the veNFT without extending lock period.\n///        Based on Solidly contract.\n/// @author belbix\ncontract VeDistributor is ControllableV3, IVeDistributor {\n  using SafeERC20 for IERC20;\n\n  // for contract internal purposes, don't need to store in the interface\n  struct ClaimCalculationResult {\n    uint toDistribute;\n    uint userEpoch;\n    uint weekCursor;\n    uint maxUserEpoch;\n    bool success;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_DIST_VERSION = \"1.0.0\";\n  uint internal constant WEEK = 7 * 86400;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Voting escrow token address\n  IVe public ve;\n  /// @dev Token for ve rewards\n  address public override rewardToken;\n\n  // --- CHECKPOINT\n\n  /// @dev Cursor for the current epoch\n  uint public activePeriod;\n  /// @dev Tokens per week stored on checkpoint call. Predefined array size = max weeks size\n  uint[1000000000000000] public tokensPerWeek;\n  /// @dev Ve supply checkpoints. Predefined array size = max weeks size\n  uint[1000000000000000] public veSupply;\n  /// @dev Ve supply checkpoint time cursor\n  uint public timeCursor;\n  /// @dev Token balance updated on checkpoint/claim\n  uint public tokenLastBalance;\n  /// @dev Last checkpoint time\n  uint public lastTokenTime;\n\n  // --- CLAIM\n\n  /// @dev Timestamp when this contract was inited\n  uint public startTime;\n  /// @dev veID => week cursor stored on the claim action\n  mapping(uint => uint) public timeCursorOf;\n  /// @dev veID => epoch stored on the claim action\n  mapping(uint => uint) public userEpochOf;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CheckpointToken(\n    uint time,\n    uint tokens\n  );\n\n  event Claimed(\n    uint tokenId,\n    uint amount,\n    uint claimEpoch,\n    uint maxEpoch\n  );\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    address _ve,\n    address _rewardToken\n  ) external initializer {\n    __Controllable_init(controller_);\n    _requireERC20(_rewardToken);\n    _requireInterface(_ve, InterfaceIds.I_VE);\n\n    uint _t = block.timestamp / WEEK * WEEK;\n    startTime = _t;\n    lastTokenTime = _t;\n    timeCursor = _t;\n\n    rewardToken = _rewardToken;\n    ve = IVe(_ve);\n\n//    IERC20(_rewardToken).safeApprove(_ve, type(uint).max);\n  }\n\n  // *************************************************************\n  //                      CHECKPOINT\n  // *************************************************************\n\n  function checkpoint() external override {\n    uint _period = activePeriod;\n    // only trigger if new week\n    if (block.timestamp >= _period + 1 weeks) {\n      // set new period rounded to weeks\n      activePeriod = block.timestamp / 1 weeks * 1 weeks;\n      // checkpoint token balance that was just minted in veDist\n      _checkpointToken();\n      // checkpoint supply\n      _checkpointTotalSupply();\n    }\n  }\n\n  /// @dev Update tokensPerWeek value\n  function _checkpointToken() internal {\n    uint tokenBalance = IERC20(rewardToken).balanceOf(address(this));\n    uint toDistribute = tokenBalance - tokenLastBalance;\n    tokenLastBalance = tokenBalance;\n\n    uint t = lastTokenTime;\n    uint sinceLast = block.timestamp - t;\n    lastTokenTime = block.timestamp;\n    uint thisWeek = t / WEEK * WEEK;\n    uint nextWeek = 0;\n\n    // checkpoint should be called at least once per 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      nextWeek = thisWeek + WEEK;\n      if (block.timestamp < nextWeek) {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\n        break;\n      } else {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\n      }\n      t = nextWeek;\n      thisWeek = nextWeek;\n    }\n    emit CheckpointToken(block.timestamp, toDistribute);\n  }\n\n  /// @dev Adjust value based on time since last update\n  function adjustToDistribute(\n    uint toDistribute,\n    uint t0,\n    uint t1,\n    uint sinceLast\n  ) public pure returns (uint) {\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n      return toDistribute;\n    }\n    return toDistribute * (t0 - t1) / sinceLast;\n  }\n\n  /// @dev Search in the loop given timestamp through ve points history.\n  ///      Return minimal possible epoch.\n  function findTimestampEpoch(IVe _ve, uint _timestamp) public view returns (uint) {\n    uint _min = 0;\n    uint _max = _ve.epoch();\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVe.Point memory pt = _ve.pointHistory(_mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Search in the loop given timestamp through ve user points history.\n  ///      Return minimal possible epoch.\n  function findTimestampUserEpoch(\n    IVe _ve,\n    uint tokenId,\n    uint _timestamp,\n    uint maxUserEpoch\n  ) public view returns (uint) {\n    uint _min = 0;\n    uint _max = maxUserEpoch;\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVe.Point memory pt = _ve.userPointHistory(tokenId, _mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Return ve power at given timestamp\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\n    IVe _ve = ve;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint epoch = findTimestampUserEpoch(_ve, _tokenId, _timestamp, maxUserEpoch);\n    IVe.Point memory pt = _ve.userPointHistory(_tokenId, epoch);\n    return uint(int256(_positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\n  }\n\n  /// @dev Call ve checkpoint and write veSupply at the current timeCursor\n  function checkpointTotalSupply() external override {\n    _checkpointTotalSupply();\n  }\n\n  function _checkpointTotalSupply() internal {\n    IVe _ve = ve;\n    uint t = timeCursor;\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\n    _ve.checkpoint();\n\n    // assume will be called more frequently than 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      if (t > roundedTimestamp) {\n        break;\n      } else {\n        uint epoch = findTimestampEpoch(_ve, t);\n        IVe.Point memory pt = _ve.pointHistory(epoch);\n        veSupply[t] = adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n      }\n      t += WEEK;\n    }\n    timeCursor = t;\n  }\n\n  /// @dev Calculate ve supply based on bias and slop for the given timestamp\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) public pure returns (uint) {\n    if (t < ptTs) {\n      return 0;\n    }\n    int128 dt = int128(int256(t - ptTs));\n    if (ptBias < ptSlope * dt) {\n      return 0;\n    }\n    return uint(int256(_positiveInt128(ptBias - ptSlope * dt)));\n  }\n\n  // *************************************************************\n  //                      CLAIM\n  // *************************************************************\n\n  /// @dev Return available to claim earned amount\n  function claimable(uint _tokenId) external view returns (uint) {\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\n    return result.toDistribute;\n  }\n\n  /// @dev Claim rewards for given veID\n  function claim(uint _tokenId) external override returns (uint) {\n    IVe _ve = ve;\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    uint amount = _claim(_tokenId, _ve, _lastTokenTime);\n    if (amount != 0) {\n      IERC20(rewardToken).safeTransfer(IERC721(address(_ve)).ownerOf(_tokenId), amount);\n//      _ve.increaseAmount(rewardToken, _tokenId, amount);\n      tokenLastBalance -= amount;\n    }\n    return amount;\n  }\n\n  /// @dev Claim rewards for given veIDs\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    IVe _votingEscrow = ve;\n    uint total = 0;\n\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      uint _tokenId = _tokenIds[i];\n      if (_tokenId == 0) break;\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n      if (amount != 0) {\n        IERC20(rewardToken).safeTransfer(IERC721(address(_votingEscrow)).ownerOf(_tokenId), amount);\n//        _votingEscrow.increaseAmount(rewardToken, _tokenId, amount);\n        total += amount;\n      }\n    }\n    if (total != 0) {\n      tokenLastBalance -= total;\n    }\n\n    return true;\n  }\n\n  function _claim(uint _tokenId, IVe _ve, uint _lastTokenTime) internal returns (uint) {\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, _ve, _lastTokenTime);\n    if (result.success) {\n      userEpochOf[_tokenId] = result.userEpoch;\n      timeCursorOf[_tokenId] = result.weekCursor;\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\n    }\n    return result.toDistribute;\n  }\n\n  function _calculateClaim(\n    uint _tokenId,\n    IVe _ve,\n    uint _lastTokenTime\n  ) internal view returns (ClaimCalculationResult memory) {\n    uint userEpoch;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint _startTime = startTime;\n\n    if (maxUserEpoch == 0) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n\n    uint weekCursor = timeCursorOf[_tokenId];\n\n    if (weekCursor == 0) {\n      userEpoch = findTimestampUserEpoch(_ve, _tokenId, _startTime, maxUserEpoch);\n    } else {\n      userEpoch = userEpochOf[_tokenId];\n    }\n\n    if (userEpoch == 0) userEpoch = 1;\n\n    IVe.Point memory userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n    if (weekCursor == 0) {\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\n    }\n    if (weekCursor >= lastTokenTime) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n    if (weekCursor < _startTime) {\n      weekCursor = _startTime;\n    }\n\n    return calculateToDistribute(\n      _tokenId,\n      weekCursor,\n      _lastTokenTime,\n      userPoint,\n      userEpoch,\n      maxUserEpoch,\n      _ve\n    );\n  }\n\n  function calculateToDistribute(\n    uint _tokenId,\n    uint weekCursor,\n    uint _lastTokenTime,\n    IVe.Point memory userPoint,\n    uint userEpoch,\n    uint maxUserEpoch,\n    IVe _ve\n  ) public view returns (ClaimCalculationResult memory) {\n    IVe.Point memory oldUserPoint;\n    uint toDistribute;\n    for (uint i = 0; i < 50; i++) {\n      if (weekCursor >= _lastTokenTime) {\n        break;\n      }\n      if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n        userEpoch += 1;\n        oldUserPoint = userPoint;\n        if (userEpoch > maxUserEpoch) {\n          userPoint = IVe.Point(0, 0, 0, 0);\n        } else {\n          userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n        }\n      } else {\n        int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n        uint balanceOf = uint(int256(_positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\n        if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n          break;\n        }\n        toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\n        weekCursor += WEEK;\n      }\n    }\n    return ClaimCalculationResult(\n      toDistribute,\n      Math.min(maxUserEpoch, userEpoch - 1),\n      weekCursor,\n      maxUserEpoch,\n      true\n    );\n  }\n\n  function _positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /// @dev Block timestamp rounded to weeks\n  function timestamp() external view returns (uint) {\n    return block.timestamp / WEEK * WEEK;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VE_DISTRIBUTOR || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}